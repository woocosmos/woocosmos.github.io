<!DOCTYPE html>
<html>
  <head>
  <title>Jekyll을 사용한 github.io 블로그 개발기 – YunsooLog – 행간을 읽는 기계학습 이야기</title>
  <link rel="icon" href="/images/favicon.ico">
      <meta name="google-site-verification" content="NA4jg1Iffw6aA9VWjj3kqoo2jfOkPRxINJtYphd7VeI" />
    <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
    
    
    <meta name="description" content="요약
- 지금 이 블로그(woocosmos.github.io)를 구축한 전반적인 내용
- Jekyll 설치를 위해 ruby 개발 환경을 세팅한다
- 목적과 취향에 맞는 Jekyll 테마를 골라 fork 한다
- HTML/CSS/JavaScript를 활용하여 다양한 기능을 추가, 수정한다


개요

티스토리에서 운영하던 개발 블로그를 github.io 로 이관하는 작업을 진행하고 있다.
그 이유는 첫째, 티스토리에서 Markdown이 불안정하게 적용되기 때문이다. 둘째, HTML 및 JavaScript를 활용하여 자유자재로 커스터마이징할 수 있다는 점이 매력적으로 느껴졌기 때문이다.

물론 github.io 블로그는 카테고리 설정이 까다로워 대부분 태그 기반이라는 점, 그리고 검색이나 목차와 같은 기능은 직접 구현해야 한다는 번거로움이 단점으로 작용한다. 그러나 이참에 개발 블로그를 정식으로 세팅하고 JavaScript를 직접 부딪치며 배워보는 기회로 여겨보려 한다.

곧 게시물을 전부 이쪽으로 옮길 예정이지만 기존 티스토리 블로그도 열려 있으니 언제든 놀러오시라.

기본 세팅



github.io 블로그를 시작하기 위해서는 jekyll(지킬)을 세팅하는 것이 우선이다. Jekyll은 마크다운 언어로 작성한 텍스트를 정적 웹사이트로 생성해주는 변환 엔진이다. 한국어로 번역된 공식 문서를 이곳에서 확인할 수 있다.

Ruby

Jekyll은 Ruby 프로그램이기 때문에 Ruby를 먼저 설치해야 한다. 또한 Ruby의 라이브러리(즉, Gem)를 관리해주는 프레임워크인 RubyGems도 필요하다. OS에 따른 설치 방법은 공식 문서를 포함하여 다양한 칼럼에 소개되어 있으니 참고하면 되겠다.

개인적으로 Windows(회사 컴퓨터)와 Mac(개인 노트북)에 각각 Ruby를 설치하면서 다양한 트러블슈팅을 경험했는데, 대개 Ruby의 버전 관리 프레임워크인 rbenv로 설치를 관리하면서 많은 문제를 회피할 수 있었다.


  특히 Ruby의 버전이 3.0.0 이상이어야 한다는 에러를 가장 많이 부딪혔는데 rbenv로 원하는 버전으로 지정함으로써 문제에서 벗어날 수 있었다. 해당 블로그 프로젝트는 ruby-3.2.0으로 빌드했다.


준비물의 순서로 정리하자면 rbenv → Ruby → gem → bundler → jekyll 이다.

gem install jekyll 


더하여 개발의 편의성을 위해 jekyll 로컬 서버를 띄우려면 github-pages를 설치하는 것이 좋다. 이를 활용하여 파일의 변경사항을 save할 때마다 바로 반영된 것을 확인할 수 있다.

gem install github-pages
jekyll server --force_polling


  별도 옵션을 주지 않는 한 http://127.0.0.1:4000로 접속한다
  --force_polling : 해당 플래그 옵션으로 블로그를 새로고침해서 바로 변경된 내용을 확인할 수 있다. 이를 설정하지 않으면 매번 로컬 서버를 내렸다가 다시 올려야 한다.


Jekyll 테마

from scratch로 블로그를 구성하기보다는 특정 테마로 베이스 사이트를 세팅한 후에 기능을 추가하거나 변경하기로 했다. Jekyll 테마 사이트에서 목적과 취향에 맞는 테마를 골라보자.



결론적으로 한국어 가독성을 고려한 Kiko Now를 기본으로 하되, Tale이나 Catbook 등 다양한 테마를 레퍼런스로 삼아 기능을 추가하는 방향으로 진행했다.

이제 선택한 테마의 github 레포지토리로 이동하여 나의 레포지토리로 fork 해오면 된다. 이때 레포지토리 이름을 {username}.github.io로 설정하면 github에서 자동으로 해당 도메인으로 호스팅해준다. fork 직후에는 위 도메인으로 접속이 안 될 수도 있는데, 수 분 기다리거나 최소 하나의 변경 사항을 push 해주면 들어가진다.

마지막으로 작업 폴더에서 git clone하여 로컬 레포지토리를 생성한다.

config 수정

대부분 Jekyll 테마에서 그렇듯 커스터마이징의 첫 단계는 _config.yml 파일을 수정하는 것이다. 블로그 이름, SNS 링크 등 기본적인 내용을 이곳에 입력하도록 되어 있다.

이제 기본적인 세팅은 끝이다. 바로 MD 파일을 생성해서 포스트를 업로드할 수 있다. 개인적으로는 약간 번거롭더라도 복구 가능성을 위해 항상 git branch로 작업 후 master에 merge 하는 편이다.

git checkout -b post/blog-history
vi _posts/2024-08-19-blog-history.md
# 포스트 작성 후 ...
git add .
git commit -m '[post/init] 블로그 개발기'
git push
# master 에 반영
git checkout master
git merge post/blog-history


브랜치 네임이나 커밋 메시지의 컨벤션은 스스로 아래와 같이 정했다.

  post/… : 블로그글 관련 브랜치
  feature/… : 블로그 기능 관련 브랜치
  [post/init] : 블로그글 최초 배포 커밋
  [post/modi] : 이후 블로그글 수정 커밋


구글 검색 연동

내용

기능 추가

이제부터 이어지는 내용은 기능을 추가한 히스토리를 기록한 것이다.

JavaScript를 잘 모르다보니 Workaround 형식으로 구현한 내용도 많다. 개선 지점은 언제든 덧글이나 연락처로 알려주시면 감사하겠다.

back-to-top 버튼 구현

_includes/top.html에 인라인 JS로 구현되어 있다. 외부 라이브러리 없이 순수 JavaScript로 작성했다.


  스크롤 위치를 감지하여 일정 이상 내려가면 우측 하단에 원형 버튼이 나타남
  클릭 시 cosine easing 애니메이션으로 부드럽게 최상단으로 이동
  레이아웃(default.html, page.html, post.html)에서 {% include top.html %}로 삽입


검색 페이지 추가
검색 기능

Simple-Jekyll-Search 오픈소스를 활용했다.


  Jekyll 빌드 시 search.json에 전체 포스트의 제목, 태그, 날짜, 본문을 JSON으로 생성
  search-and-return.js에서 SimpleJekyllSearch를 초기화하고, 검색창 입력 시 JSON을 대상으로 클라이언트 사이드 검색 수행
  검색 결과는 제목, 날짜, 태그, 본문 미리보기로 구성


검색 결과 하이라이트

search-and-return.js의 templateMiddleware에서 구현했다.


  검색어를 정규식으로 변환하여 제목, 태그, 본문에서 매칭되는 부분을 &lt;b style="background:gold"&gt; 로 강조 표시
  본문의 경우 매칭 위치 앞뒤 15단어만 잘라서 표시하고, 본문 내 총 언급 횟수를 함께 출력
  태그는 각각 태그 페이지로의 링크를 포함



LaTex(수학 수식) 적용하기

LaTex를 렌더링해주는 KaTex 를 _includes/head.html의 head 부분에 추가한다.

  &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"&gt;
  &lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"&gt;&lt;/script&gt;
  &lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
          onload="renderMathInElement(document.body, {
            delimiters: [
              {left: '\\[', right: '\\]', display: true},
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
            ]
          });"&gt;
  &lt;/script&gt;



  delimiter를 명시한 이유는 inline LaTex를 제대로 인식하지 못했던 문제 때문이다
  명시한 이후에도 display LaTex가 적용되지 않는 문제가 있었다 : $$로 감싸도 \[\] 로 출력되었다 (사실 이것이 표준 display LaTex notation이라고 한다) 그래서 delimiter 항목으로 더 추가했다


이제 LaTex 문법대로 수식을 $ 기호 1개 혹은 2개 사이에 작성하면 알맞게 렌더링 된다

display LaTex

\[\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\]

$$
\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}
$$  


inline LaTex
문장 중간에 이렇게 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다

문장 중간에 이런 수식을 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다



목차(TOC) 추가
블로그글 옆 사이드바 형식의 목차를 추가한다. 아래는 플러그인을 설치해서 사용할 수 있는 jekyll-toc을 적용한 내용이다.

동일한 이름의 플러그인이 있는데, 후술할 Github Pages 이슈로부터 자유로운 것으로 보인다. 처음으로 돌아간다면 이것을 적용해볼지도…

설치 방법

Gemfile에 아래 라인을 추가한다
gem 'jekyll-toc'

bundle로 설치를 진행한다
bundle install

_config.yml 파일 중 플러그인 부분에 요소를 추가한다
plugins:
  - jekyll-sitemap
    ...
  - jekyll-toc # 추가


사용 방법

post 헤드에 toc 플래그를 추가한다
---
layout: post
title: "Jekyll을 사용한 github.io 블로그 개발기"
tags: [JavaScript]
comments: True
toc: true
---

post.html에 toc을 추가한다.
단순히 {{ content | toc }}로 수정해서 본문 위에 목차가 생성되도록 하는 방법도 있지만 목차의 레이아웃이나 기능을 다양하게 커스터마이징 하기 위해 별도 태그인 {% toc %}로 추가했다.
&lt;section class="entry"&gt;
    {% if page.toc %}
    &lt;aside&gt;
        &lt;nav class="nav-toc"&gt;
            &lt;h3&gt; 목차 &lt;/h3&gt;
            {% toc %}
        &lt;/nav&gt;
    &lt;/aside&gt;
    &lt;script src="{{ site.baseurl }}/assets/scroll-spy.js" type="text/javascript"&gt;&lt;/script&gt;
    {% endif %}
    {{ content }}
&lt;/section&gt;


  {% if page.toc %} : 헤드에 toc 플래그를 명시한 경우에만 목차가 추가되게 했다.
  &lt;aside&gt; : 본문 옆 사이드바 형식으로 표시하기 위해 사용했다
  &lt;nav&gt; : 목차의 제목을 클릭했을 때 해당 영역으로 이동하도록 링크를 연결하기 위해 사용했다
  &lt;h3&gt; 목차 &lt;/h3&gt; : 플러그인으로 자동 생성되는 HTML에는 제목이 없길래 따로 추가해주었다 (사실 page.toc 조건을 굳이 넣은 것도 이 제목 때문이다. toc: false으로 세팅해도 h3 태그는 남아 있었기 때문이다.)


목차 레이아웃

목차의 위치와 모양을 세팅하는 과정이다.

목차를 본문 좌측에 맞추고 스크롤과 상관없이 상단에 고정시키기
aside {
    float: right;
    position: sticky;
    width: fit-content;
    top: 10px;
    margin-right: -300px;
  }


  position을 sticky로 설정하고 top값을 조금이라도 부여하면 스크롤과 상관없이 화면 한 쪽에 고정되는 효과를 구현할 수 있다
  margin-right를 조정해서 본문과 너무 멀지도, 가깝지도 않게 위치시켰다


레이아웃을 심플하게 디자인하기
.nav-toc {
  font-size: smaller;
  border-left: 1px solid $lightGray;

  h3 {
    padding-left: 20px;
  }

  ul &gt; li {
    list-style-type: none; 
    &amp;:before {
      content: '';
    }

    ul {
      display: inline;
    }
  }

  ul &gt; li &gt; a.active {
    font-size: larger;
    font-weight: bold;
  }
}


  기본적으로 폰트 사이즈는 작게, 리스트 앞에 붙는 마커는 생략했다
    
      list-style-type: none를 주었는데도 마커가 생성되어 &amp;:before {content: '';}를 별도로 추가했다
    
  
  목차와 본문 사이 가는 구분선을 추가했다 (border-left)
  일부 하위 목차들이 가로로 나열되는(?) 이상한 현상이 있어서 display: inline을 추가했다
  목차가 하이라이트 대상일 때 폰트 사이즈와 굵기를 조금 키운다


목차 하이라이트 기능
스크롤의 위치에 따라 현재 보고 있는 콘텐츠의 목차를 하이라이트하는 기능이다. 위에서 toc 태그를 추가한 HTML 코드를 보면 scroll-spy.js라는 스크립트를 실행시키는 것을 볼 수 있는데, 이것이 스크롤 위치에 따라 하이라이트할 목차를 지정하는 역할을 한다.
전체 코드를 살펴보겠다.

// 브라우저가 HTML을 전부 읽고 DOM 트리를 완성했을 때 발생하는 이벤트
document.addEventListener('DOMContentLoaded', () =&gt; {

    // links : H1, H2, H3 깊이 까지만 목차를 읽어온다 (a 태그 셀렉트)
    const Hs = document.querySelectorAll('.nav-toc ul.section-nav li.toc-entry.toc-h1, .nav-toc ul.section-nav li.toc-entry.toc-h2, .nav-toc ul.section-nav li.toc-entry.toc-h3');
    const links = Array.from(Hs).map(h =&gt; { return h.querySelector('a') })
    
    // anchors : links 의 각 요소로부터 href 를 읽어온다
    const anchors = Array.from(links).map(link =&gt; {
        const href = link.getAttribute('href');
        if (href) {
            return document.querySelector(href);
        }
        return null;
    }).filter(anchor =&gt; anchor !== null);

    // 스크롤 발생시
    window.addEventListener('scroll', () =&gt; {
        if (anchors.length &gt; 0 &amp;&amp; links.length &gt; 0) {
            let scrollTop = window.scrollY;
            let activeIndex = -1;

            // 스크롤 위치와 제목의 위치가 가까울 경우 (격차가 300 이하)
            // 활성화할 제목의 인덱스를 저장한다
            anchors.forEach((anchor, i) =&gt; {
                if (scrollTop &gt;= anchor.offsetTop - 300) {
                activeIndex = i; 
                }
            });

            // 나머지 제목은 비활성화 한다
            links.forEach((link) =&gt; {
                link.classList.remove('active');
            });
            
            // 인덱스가 유효하면 제목을 활성화한다
            if (activeIndex &gt;= 0) {
                links[activeIndex].classList.add('active');
            }
        }
  });
});

코드의 동작 원리는 주석을 참고하면 된다.

개인적으로 까다로웠던 점은 특정 깊이(h3)까지만 목차를 읽어오는 것이었다. 모든 제목이 하이라이트되는 것을 원하지 않았고 h4 이상부터는 상위 제목을 하이라이트하는 게 목차로서 의미가 있다고 판단했다.

querySelectorAll를 사용해서 모든 제목의 a 태그를 바로 긁어올 수 있지만 특정 깊이까지만 읽어오기 위해서 H1부터 H3까지 직접 지정해서 읽어온 다음 그 안에서 a 태그를 가져오게 했다. 그 뿐만 아니라 숫자로 시작하는 제목( 예를 들면 … )은 href를 읽어올 때 에러가 발생했기 때문에 애초에 지정한 만큼만 읽고 그 안에서 파싱하는 방식이 가장 깔끔하다고 생각했다.

또 지속적으로 마주했던 에러는 links와 anchors 변수가 빈 배열을 반환하는 문제였는데, 이는 DOMContentLoaded 이벤트를 조건으로 추가함으로써 해결했다.

하여, 나만의 sticky highlighted TOC 이 완성되었다


gh-pages 생성

그러나 TOC 기능을 추가한 후 Github Pages에서 빌드/배포 실패가 떴다. 분명 로컬 서버에서는 잘 돌아갔는데 말이다.



에러 메시지에 ‘Unknown tag toc’이라고 적힌 것으로 보아 Jekyll-toc 플러그인 쪽 문제로 보였다.
실제로 Jekyll-toc 레포지토리의 이슈 채널에서 동일한 문제를 호소하는 글들을 확인할 수 있었다.


  Is Github Pages not supported? #151
  TOC on GitHub Pages #29
  Is Github Pages not supported? #151



  GitHub Pages cannot build sites using unsupported plugins. If you want to use unsupported plugins, generate your site locally and then push your site’s static files to GitHub.


이는 Github Pages 서비스에서 내가 사용한 toc 플러그인을 지원하지 않아 발생한 문제였다.
따라서 로컬로 사이트를 직접 빌드한 후 해당 내용을 배포하도록 하는 방법으로 문제를 해결할 수 있다. 이때 gh-pages라는 브랜치로 밀어넣고 root 경로로 설정해야 한다. 참고한 칼럼은 여기.

# 로컬에서 빌드한다
jekyll build
# _site 폴더를 어딘가로 대피시킨다
mv -r _site /path/to/tmp
git checkout --orphan gh-pages 
# 폴더를 비우고 _site 데이터를 다시 가져온다
rm -rf * 
cp -r /path/to/tmp/_site/* ./
git add -A
git commit -m "build locally and create gh-pages"
git push origin gh-pages

브랜치를 생성할 때 --orphan 옵션을 추가한 이유는 부모(master)로부터 커밋 히스토리를 이어 받지 않은 독립적인 브랜치를 새로 만들기 위함이다. 마치 레포지토리 안에 새로운 레포지토리를 시작한다고 생각할 수 있겠다.

마지막으로는 레포지토리에서 Settings &gt; Pages &gt; Source 그리고 Branch를 gh-pages로 수정하면 된다


문제는 이제 앞으로 변경사항을 반영할 때마다 _site 의 내용을 매번 옮겨놨다가 다른 데이터를 삭제하는 식으로 업데이트 해야 한다는 것이다. 위 과정은 향후 Github Actions를 활용해 자동화된 workflow로 구축할 예정이다.
" />
    <meta property="og:description" content="요약
- 지금 이 블로그(woocosmos.github.io)를 구축한 전반적인 내용
- Jekyll 설치를 위해 ruby 개발 환경을 세팅한다
- 목적과 취향에 맞는 Jekyll 테마를 골라 fork 한다
- HTML/CSS/JavaScript를 활용하여 다양한 기능을 추가, 수정한다


개요

티스토리에서 운영하던 개발 블로그를 github.io 로 이관하는 작업을 진행하고 있다.
그 이유는 첫째, 티스토리에서 Markdown이 불안정하게 적용되기 때문이다. 둘째, HTML 및 JavaScript를 활용하여 자유자재로 커스터마이징할 수 있다는 점이 매력적으로 느껴졌기 때문이다.

물론 github.io 블로그는 카테고리 설정이 까다로워 대부분 태그 기반이라는 점, 그리고 검색이나 목차와 같은 기능은 직접 구현해야 한다는 번거로움이 단점으로 작용한다. 그러나 이참에 개발 블로그를 정식으로 세팅하고 JavaScript를 직접 부딪치며 배워보는 기회로 여겨보려 한다.

곧 게시물을 전부 이쪽으로 옮길 예정이지만 기존 티스토리 블로그도 열려 있으니 언제든 놀러오시라.

기본 세팅



github.io 블로그를 시작하기 위해서는 jekyll(지킬)을 세팅하는 것이 우선이다. Jekyll은 마크다운 언어로 작성한 텍스트를 정적 웹사이트로 생성해주는 변환 엔진이다. 한국어로 번역된 공식 문서를 이곳에서 확인할 수 있다.

Ruby

Jekyll은 Ruby 프로그램이기 때문에 Ruby를 먼저 설치해야 한다. 또한 Ruby의 라이브러리(즉, Gem)를 관리해주는 프레임워크인 RubyGems도 필요하다. OS에 따른 설치 방법은 공식 문서를 포함하여 다양한 칼럼에 소개되어 있으니 참고하면 되겠다.

개인적으로 Windows(회사 컴퓨터)와 Mac(개인 노트북)에 각각 Ruby를 설치하면서 다양한 트러블슈팅을 경험했는데, 대개 Ruby의 버전 관리 프레임워크인 rbenv로 설치를 관리하면서 많은 문제를 회피할 수 있었다.


  특히 Ruby의 버전이 3.0.0 이상이어야 한다는 에러를 가장 많이 부딪혔는데 rbenv로 원하는 버전으로 지정함으로써 문제에서 벗어날 수 있었다. 해당 블로그 프로젝트는 ruby-3.2.0으로 빌드했다.


준비물의 순서로 정리하자면 rbenv → Ruby → gem → bundler → jekyll 이다.

gem install jekyll 


더하여 개발의 편의성을 위해 jekyll 로컬 서버를 띄우려면 github-pages를 설치하는 것이 좋다. 이를 활용하여 파일의 변경사항을 save할 때마다 바로 반영된 것을 확인할 수 있다.

gem install github-pages
jekyll server --force_polling


  별도 옵션을 주지 않는 한 http://127.0.0.1:4000로 접속한다
  --force_polling : 해당 플래그 옵션으로 블로그를 새로고침해서 바로 변경된 내용을 확인할 수 있다. 이를 설정하지 않으면 매번 로컬 서버를 내렸다가 다시 올려야 한다.


Jekyll 테마

from scratch로 블로그를 구성하기보다는 특정 테마로 베이스 사이트를 세팅한 후에 기능을 추가하거나 변경하기로 했다. Jekyll 테마 사이트에서 목적과 취향에 맞는 테마를 골라보자.



결론적으로 한국어 가독성을 고려한 Kiko Now를 기본으로 하되, Tale이나 Catbook 등 다양한 테마를 레퍼런스로 삼아 기능을 추가하는 방향으로 진행했다.

이제 선택한 테마의 github 레포지토리로 이동하여 나의 레포지토리로 fork 해오면 된다. 이때 레포지토리 이름을 {username}.github.io로 설정하면 github에서 자동으로 해당 도메인으로 호스팅해준다. fork 직후에는 위 도메인으로 접속이 안 될 수도 있는데, 수 분 기다리거나 최소 하나의 변경 사항을 push 해주면 들어가진다.

마지막으로 작업 폴더에서 git clone하여 로컬 레포지토리를 생성한다.

config 수정

대부분 Jekyll 테마에서 그렇듯 커스터마이징의 첫 단계는 _config.yml 파일을 수정하는 것이다. 블로그 이름, SNS 링크 등 기본적인 내용을 이곳에 입력하도록 되어 있다.

이제 기본적인 세팅은 끝이다. 바로 MD 파일을 생성해서 포스트를 업로드할 수 있다. 개인적으로는 약간 번거롭더라도 복구 가능성을 위해 항상 git branch로 작업 후 master에 merge 하는 편이다.

git checkout -b post/blog-history
vi _posts/2024-08-19-blog-history.md
# 포스트 작성 후 ...
git add .
git commit -m '[post/init] 블로그 개발기'
git push
# master 에 반영
git checkout master
git merge post/blog-history


브랜치 네임이나 커밋 메시지의 컨벤션은 스스로 아래와 같이 정했다.

  post/… : 블로그글 관련 브랜치
  feature/… : 블로그 기능 관련 브랜치
  [post/init] : 블로그글 최초 배포 커밋
  [post/modi] : 이후 블로그글 수정 커밋


구글 검색 연동

내용

기능 추가

이제부터 이어지는 내용은 기능을 추가한 히스토리를 기록한 것이다.

JavaScript를 잘 모르다보니 Workaround 형식으로 구현한 내용도 많다. 개선 지점은 언제든 덧글이나 연락처로 알려주시면 감사하겠다.

back-to-top 버튼 구현

_includes/top.html에 인라인 JS로 구현되어 있다. 외부 라이브러리 없이 순수 JavaScript로 작성했다.


  스크롤 위치를 감지하여 일정 이상 내려가면 우측 하단에 원형 버튼이 나타남
  클릭 시 cosine easing 애니메이션으로 부드럽게 최상단으로 이동
  레이아웃(default.html, page.html, post.html)에서 {% include top.html %}로 삽입


검색 페이지 추가
검색 기능

Simple-Jekyll-Search 오픈소스를 활용했다.


  Jekyll 빌드 시 search.json에 전체 포스트의 제목, 태그, 날짜, 본문을 JSON으로 생성
  search-and-return.js에서 SimpleJekyllSearch를 초기화하고, 검색창 입력 시 JSON을 대상으로 클라이언트 사이드 검색 수행
  검색 결과는 제목, 날짜, 태그, 본문 미리보기로 구성


검색 결과 하이라이트

search-and-return.js의 templateMiddleware에서 구현했다.


  검색어를 정규식으로 변환하여 제목, 태그, 본문에서 매칭되는 부분을 &lt;b style="background:gold"&gt; 로 강조 표시
  본문의 경우 매칭 위치 앞뒤 15단어만 잘라서 표시하고, 본문 내 총 언급 횟수를 함께 출력
  태그는 각각 태그 페이지로의 링크를 포함



LaTex(수학 수식) 적용하기

LaTex를 렌더링해주는 KaTex 를 _includes/head.html의 head 부분에 추가한다.

  &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"&gt;
  &lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"&gt;&lt;/script&gt;
  &lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
          onload="renderMathInElement(document.body, {
            delimiters: [
              {left: '\\[', right: '\\]', display: true},
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
            ]
          });"&gt;
  &lt;/script&gt;



  delimiter를 명시한 이유는 inline LaTex를 제대로 인식하지 못했던 문제 때문이다
  명시한 이후에도 display LaTex가 적용되지 않는 문제가 있었다 : $$로 감싸도 \[\] 로 출력되었다 (사실 이것이 표준 display LaTex notation이라고 한다) 그래서 delimiter 항목으로 더 추가했다


이제 LaTex 문법대로 수식을 $ 기호 1개 혹은 2개 사이에 작성하면 알맞게 렌더링 된다

display LaTex

\[\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\]

$$
\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}
$$  


inline LaTex
문장 중간에 이렇게 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다

문장 중간에 이런 수식을 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다



목차(TOC) 추가
블로그글 옆 사이드바 형식의 목차를 추가한다. 아래는 플러그인을 설치해서 사용할 수 있는 jekyll-toc을 적용한 내용이다.

동일한 이름의 플러그인이 있는데, 후술할 Github Pages 이슈로부터 자유로운 것으로 보인다. 처음으로 돌아간다면 이것을 적용해볼지도…

설치 방법

Gemfile에 아래 라인을 추가한다
gem 'jekyll-toc'

bundle로 설치를 진행한다
bundle install

_config.yml 파일 중 플러그인 부분에 요소를 추가한다
plugins:
  - jekyll-sitemap
    ...
  - jekyll-toc # 추가


사용 방법

post 헤드에 toc 플래그를 추가한다
---
layout: post
title: "Jekyll을 사용한 github.io 블로그 개발기"
tags: [JavaScript]
comments: True
toc: true
---

post.html에 toc을 추가한다.
단순히 {{ content | toc }}로 수정해서 본문 위에 목차가 생성되도록 하는 방법도 있지만 목차의 레이아웃이나 기능을 다양하게 커스터마이징 하기 위해 별도 태그인 {% toc %}로 추가했다.
&lt;section class="entry"&gt;
    {% if page.toc %}
    &lt;aside&gt;
        &lt;nav class="nav-toc"&gt;
            &lt;h3&gt; 목차 &lt;/h3&gt;
            {% toc %}
        &lt;/nav&gt;
    &lt;/aside&gt;
    &lt;script src="{{ site.baseurl }}/assets/scroll-spy.js" type="text/javascript"&gt;&lt;/script&gt;
    {% endif %}
    {{ content }}
&lt;/section&gt;


  {% if page.toc %} : 헤드에 toc 플래그를 명시한 경우에만 목차가 추가되게 했다.
  &lt;aside&gt; : 본문 옆 사이드바 형식으로 표시하기 위해 사용했다
  &lt;nav&gt; : 목차의 제목을 클릭했을 때 해당 영역으로 이동하도록 링크를 연결하기 위해 사용했다
  &lt;h3&gt; 목차 &lt;/h3&gt; : 플러그인으로 자동 생성되는 HTML에는 제목이 없길래 따로 추가해주었다 (사실 page.toc 조건을 굳이 넣은 것도 이 제목 때문이다. toc: false으로 세팅해도 h3 태그는 남아 있었기 때문이다.)


목차 레이아웃

목차의 위치와 모양을 세팅하는 과정이다.

목차를 본문 좌측에 맞추고 스크롤과 상관없이 상단에 고정시키기
aside {
    float: right;
    position: sticky;
    width: fit-content;
    top: 10px;
    margin-right: -300px;
  }


  position을 sticky로 설정하고 top값을 조금이라도 부여하면 스크롤과 상관없이 화면 한 쪽에 고정되는 효과를 구현할 수 있다
  margin-right를 조정해서 본문과 너무 멀지도, 가깝지도 않게 위치시켰다


레이아웃을 심플하게 디자인하기
.nav-toc {
  font-size: smaller;
  border-left: 1px solid $lightGray;

  h3 {
    padding-left: 20px;
  }

  ul &gt; li {
    list-style-type: none; 
    &amp;:before {
      content: '';
    }

    ul {
      display: inline;
    }
  }

  ul &gt; li &gt; a.active {
    font-size: larger;
    font-weight: bold;
  }
}


  기본적으로 폰트 사이즈는 작게, 리스트 앞에 붙는 마커는 생략했다
    
      list-style-type: none를 주었는데도 마커가 생성되어 &amp;:before {content: '';}를 별도로 추가했다
    
  
  목차와 본문 사이 가는 구분선을 추가했다 (border-left)
  일부 하위 목차들이 가로로 나열되는(?) 이상한 현상이 있어서 display: inline을 추가했다
  목차가 하이라이트 대상일 때 폰트 사이즈와 굵기를 조금 키운다


목차 하이라이트 기능
스크롤의 위치에 따라 현재 보고 있는 콘텐츠의 목차를 하이라이트하는 기능이다. 위에서 toc 태그를 추가한 HTML 코드를 보면 scroll-spy.js라는 스크립트를 실행시키는 것을 볼 수 있는데, 이것이 스크롤 위치에 따라 하이라이트할 목차를 지정하는 역할을 한다.
전체 코드를 살펴보겠다.

// 브라우저가 HTML을 전부 읽고 DOM 트리를 완성했을 때 발생하는 이벤트
document.addEventListener('DOMContentLoaded', () =&gt; {

    // links : H1, H2, H3 깊이 까지만 목차를 읽어온다 (a 태그 셀렉트)
    const Hs = document.querySelectorAll('.nav-toc ul.section-nav li.toc-entry.toc-h1, .nav-toc ul.section-nav li.toc-entry.toc-h2, .nav-toc ul.section-nav li.toc-entry.toc-h3');
    const links = Array.from(Hs).map(h =&gt; { return h.querySelector('a') })
    
    // anchors : links 의 각 요소로부터 href 를 읽어온다
    const anchors = Array.from(links).map(link =&gt; {
        const href = link.getAttribute('href');
        if (href) {
            return document.querySelector(href);
        }
        return null;
    }).filter(anchor =&gt; anchor !== null);

    // 스크롤 발생시
    window.addEventListener('scroll', () =&gt; {
        if (anchors.length &gt; 0 &amp;&amp; links.length &gt; 0) {
            let scrollTop = window.scrollY;
            let activeIndex = -1;

            // 스크롤 위치와 제목의 위치가 가까울 경우 (격차가 300 이하)
            // 활성화할 제목의 인덱스를 저장한다
            anchors.forEach((anchor, i) =&gt; {
                if (scrollTop &gt;= anchor.offsetTop - 300) {
                activeIndex = i; 
                }
            });

            // 나머지 제목은 비활성화 한다
            links.forEach((link) =&gt; {
                link.classList.remove('active');
            });
            
            // 인덱스가 유효하면 제목을 활성화한다
            if (activeIndex &gt;= 0) {
                links[activeIndex].classList.add('active');
            }
        }
  });
});

코드의 동작 원리는 주석을 참고하면 된다.

개인적으로 까다로웠던 점은 특정 깊이(h3)까지만 목차를 읽어오는 것이었다. 모든 제목이 하이라이트되는 것을 원하지 않았고 h4 이상부터는 상위 제목을 하이라이트하는 게 목차로서 의미가 있다고 판단했다.

querySelectorAll를 사용해서 모든 제목의 a 태그를 바로 긁어올 수 있지만 특정 깊이까지만 읽어오기 위해서 H1부터 H3까지 직접 지정해서 읽어온 다음 그 안에서 a 태그를 가져오게 했다. 그 뿐만 아니라 숫자로 시작하는 제목( 예를 들면 … )은 href를 읽어올 때 에러가 발생했기 때문에 애초에 지정한 만큼만 읽고 그 안에서 파싱하는 방식이 가장 깔끔하다고 생각했다.

또 지속적으로 마주했던 에러는 links와 anchors 변수가 빈 배열을 반환하는 문제였는데, 이는 DOMContentLoaded 이벤트를 조건으로 추가함으로써 해결했다.

하여, 나만의 sticky highlighted TOC 이 완성되었다


gh-pages 생성

그러나 TOC 기능을 추가한 후 Github Pages에서 빌드/배포 실패가 떴다. 분명 로컬 서버에서는 잘 돌아갔는데 말이다.



에러 메시지에 ‘Unknown tag toc’이라고 적힌 것으로 보아 Jekyll-toc 플러그인 쪽 문제로 보였다.
실제로 Jekyll-toc 레포지토리의 이슈 채널에서 동일한 문제를 호소하는 글들을 확인할 수 있었다.


  Is Github Pages not supported? #151
  TOC on GitHub Pages #29
  Is Github Pages not supported? #151



  GitHub Pages cannot build sites using unsupported plugins. If you want to use unsupported plugins, generate your site locally and then push your site’s static files to GitHub.


이는 Github Pages 서비스에서 내가 사용한 toc 플러그인을 지원하지 않아 발생한 문제였다.
따라서 로컬로 사이트를 직접 빌드한 후 해당 내용을 배포하도록 하는 방법으로 문제를 해결할 수 있다. 이때 gh-pages라는 브랜치로 밀어넣고 root 경로로 설정해야 한다. 참고한 칼럼은 여기.

# 로컬에서 빌드한다
jekyll build
# _site 폴더를 어딘가로 대피시킨다
mv -r _site /path/to/tmp
git checkout --orphan gh-pages 
# 폴더를 비우고 _site 데이터를 다시 가져온다
rm -rf * 
cp -r /path/to/tmp/_site/* ./
git add -A
git commit -m "build locally and create gh-pages"
git push origin gh-pages

브랜치를 생성할 때 --orphan 옵션을 추가한 이유는 부모(master)로부터 커밋 히스토리를 이어 받지 않은 독립적인 브랜치를 새로 만들기 위함이다. 마치 레포지토리 안에 새로운 레포지토리를 시작한다고 생각할 수 있겠다.

마지막으로는 레포지토리에서 Settings &gt; Pages &gt; Source 그리고 Branch를 gh-pages로 수정하면 된다


문제는 이제 앞으로 변경사항을 반영할 때마다 _site 의 내용을 매번 옮겨놨다가 다른 데이터를 삭제하는 식으로 업데이트 해야 한다는 것이다. 위 과정은 향후 Github Actions를 활용해 자동화된 workflow로 구축할 예정이다.
" />
    
    <meta name="author" content="YunsooLog" />

    
    <meta property="og:title" content="Jekyll을 사용한 github.io 블로그 개발기" />
    <meta property="twitter:title" content="Jekyll을 사용한 github.io 블로그 개발기" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link rel="alternate" type="application/rss+xml" title="YunsooLog - 행간을 읽는 기계학습 이야기" href="/feed.xml" />
  <script>
    document.cookie = "promo_shown=1; SameSite=Lax; path=/";
  </script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
          onload="renderMathInElement(document.body, {
            delimiters: [
              {left: '\\[', right: '\\]', display: true},
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
            ]
          });">
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
</head>
  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      <a href="/" class="site-avatar"><img src="/images/avatar.png"/></a>
      
      <div class="site-info">
        <h1 class="site-name"><a href="/">YunsooLog</a></h1>
        <p class="site-description">행간을 읽는 기계학습 이야기</p>
      </div>

      <nav>
        
        
        <a href="/about">About</a>
        
        
        
        <a href="/">Blog</a>
        
        
        
        <a href="/tags">Tags</a>
        
        
        
        <a href="/timeline">Timeline</a>
        
        
        
        <ul class="search-icon">
          <a href="/search">
          <svg 
            width="24" 
            height="24" 
            viewBox="0 0 24 24" 
            fill="none" 
            xmlns="http://www.w3.org/2000/svg">
            <path d="M10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18C11.8485 18 13.5451 17.3376 14.8458 16.2416L19.7071 21.1029C20.0976 21.4934 20.7308 21.4934 21.1213 21.1029C21.5118 20.7124 21.5118 20.0792 21.1213 19.6887L16.2416 14.809C17.3376 13.5083 18 11.8116 18 10C18 5.58172 14.4183 2 10 2ZM4 10C4 6.68629 6.68629 4 10 4C13.3137 4 16 6.68629 16 10C16 13.3137 13.3137 16 10 16C6.68629 16 4 13.3137 4 10Z" 
            fill="currentColor"></path>
          </svg>
          </a>
        </ul>

      </nav>
    </header>
  </div>
</div>

    <div id="main" role="main" class="container">
      <article class="post">
  <div class="inner-wrap">
    <h1>Jekyll을 사용한 github.io 블로그 개발기</h1>

    <div>
      <span class="date">
        2024-08-19
      </span>

      <ul class="tag">
        
        <li>
          <a href="https://woocosmos.github.io/tags#JavaScript">
            JavaScript
          </a>
        </li>
        
      </ul>
    </div>

    <section class="entry">
      
      <aside>
        <nav class="nav-toc">
          <h3> 목차 </h3>
          <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#개요">개요</a></li>
<li class="toc-entry toc-h1"><a href="#기본-세팅">기본 세팅</a>
<ul>
<li class="toc-entry toc-h2"><a href="#ruby">Ruby</a></li>
<li class="toc-entry toc-h2"><a href="#jekyll-테마">Jekyll 테마</a></li>
<li class="toc-entry toc-h2"><a href="#config-수정">config 수정</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#구글-검색-연동">구글 검색 연동</a></li>
<li class="toc-entry toc-h1"><a href="#기능-추가">기능 추가</a>
<ul>
<li class="toc-entry toc-h2"><a href="#back-to-top-버튼-구현">back-to-top 버튼 구현</a></li>
<li class="toc-entry toc-h2"><a href="#검색-페이지-추가">검색 페이지 추가</a>
<ul>
<li class="toc-entry toc-h3"><a href="#검색-기능">검색 기능</a></li>
<li class="toc-entry toc-h3"><a href="#검색-결과-하이라이트">검색 결과 하이라이트</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#latex수학-수식-적용하기">LaTex(수학 수식) 적용하기</a></li>
<li class="toc-entry toc-h2"><a href="#목차toc-추가">목차(TOC) 추가</a>
<ul>
<li class="toc-entry toc-h3"><a href="#목차-레이아웃">목차 레이아웃</a></li>
<li class="toc-entry toc-h3"><a href="#gh-pages-생성">gh-pages 생성</a></li>
</ul>
</li>
</ul>
</li>
</ul>
        </nav>
      </aside>
      <script src="/assets/scroll-spy.js" type="text/javascript"></script>
      
      <p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 지금 이 블로그(woocosmos.github.io)를 구축한 전반적인 내용
- Jekyll 설치를 위해 ruby 개발 환경을 세팅한다
- 목적과 취향에 맞는 Jekyll 테마를 골라 fork 한다
- HTML/CSS/JavaScript를 활용하여 다양한 기능을 추가, 수정한다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p><strong>티스토리에서 운영하던 개발 블로그를 github.io 로 이관하는 작업을 진행하고 있다.</strong><br />
그 이유는 첫째, 티스토리에서 Markdown이 불안정하게 적용되기 때문이다. 둘째, HTML 및 JavaScript를 활용하여 자유자재로 커스터마이징할 수 있다는 점이 매력적으로 느껴졌기 때문이다.</p>

<p>물론 github.io 블로그는 카테고리 설정이 까다로워 대부분 태그 기반이라는 점, 그리고 검색이나 목차와 같은 기능은 직접 구현해야 한다는 번거로움이 단점으로 작용한다. 그러나 이참에 개발 블로그를 정식으로 세팅하고 JavaScript를 직접 부딪치며 배워보는 기회로 여겨보려 한다.</p>

<p>곧 게시물을 전부 이쪽으로 옮길 예정이지만 <a href="https://woo-niverse.tistory.com/">기존 티스토리 블로그</a>도 열려 있으니 언제든 놀러오시라.</p>

<h1 id="기본-세팅">기본 세팅</h1>

<p><img src="https://github.com/user-attachments/assets/fb2c6368-b119-420e-ac38-a91483aca40f" alt="alt text" width="60%" /></p>

<p>github.io 블로그를 시작하기 위해서는 jekyll(지킬)을 세팅하는 것이 우선이다. Jekyll은 마크다운 언어로 작성한 텍스트를 정적 웹사이트로 생성해주는 변환 엔진이다. 한국어로 번역된 공식 문서를 <a href="https://jekyllrb-ko.github.io/">이곳</a>에서 확인할 수 있다.</p>

<h2 id="ruby">Ruby</h2>

<p>Jekyll은 Ruby 프로그램이기 때문에 Ruby를 먼저 설치해야 한다. 또한 Ruby의 라이브러리(즉, Gem)를 관리해주는 프레임워크인 RubyGems도 필요하다. OS에 따른 설치 방법은 <a href="https://jekyllrb-ko.github.io/docs/installation/">공식 문서</a>를 포함하여 다양한 칼럼에 소개되어 있으니 참고하면 되겠다.</p>

<p>개인적으로 Windows(회사 컴퓨터)와 Mac(개인 노트북)에 각각 Ruby를 설치하면서 다양한 트러블슈팅을 경험했는데, 대개 Ruby의 버전 관리 프레임워크인 <code class="language-plaintext highlighter-rouge">rbenv</code>로 설치를 관리하면서 많은 문제를 회피할 수 있었다.</p>

<blockquote>
  <p>특히 <strong>Ruby의 버전이 3.0.0 이상이어야 한다</strong>는 에러를 가장 많이 부딪혔는데 rbenv로 원하는 버전으로 지정함으로써 문제에서 벗어날 수 있었다. 해당 블로그 프로젝트는 <code class="language-plaintext highlighter-rouge">ruby-3.2.0</code>으로 빌드했다.</p>
</blockquote>

<p>준비물의 순서로 정리하자면 rbenv → Ruby → gem → bundler → jekyll 이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>jekyll 
</code></pre></div></div>

<p>더하여 개발의 편의성을 위해 jekyll 로컬 서버를 띄우려면 <code class="language-plaintext highlighter-rouge">github-pages</code>를 설치하는 것이 좋다. 이를 활용하여 파일의 변경사항을 save할 때마다 바로 반영된 것을 확인할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install github-pages
jekyll server --force_polling
</code></pre></div></div>
<ul>
  <li>별도 옵션을 주지 않는 한 <a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a>로 접속한다</li>
  <li><code class="language-plaintext highlighter-rouge">--force_polling</code> : 해당 플래그 옵션으로 블로그를 새로고침해서 바로 변경된 내용을 확인할 수 있다. 이를 설정하지 않으면 매번 로컬 서버를 내렸다가 다시 올려야 한다.</li>
</ul>

<h2 id="jekyll-테마">Jekyll 테마</h2>

<p>from scratch로 블로그를 구성하기보다는 특정 테마로 베이스 사이트를 세팅한 후에 기능을 추가하거나 변경하기로 했다. <a href="http://jekyllthemes.org/">Jekyll 테마 사이트</a>에서 목적과 취향에 맞는 테마를 골라보자.</p>

<p><img src="https://github.com/user-attachments/assets/3f3fda0a-0307-4f87-8a3f-6faba96ebcb1" alt="image" width="80%" /></p>

<p>결론적으로 한국어 가독성을 고려한 <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a>를 기본으로 하되, <a href="https://chesterhow.github.io/tale/">Tale</a>이나 <a href="https://starry99.github.io/catbook/">Catbook</a> 등 다양한 테마를 레퍼런스로 삼아 기능을 추가하는 방향으로 진행했다.</p>

<p>이제 선택한 테마의 github 레포지토리로 이동하여 나의 레포지토리로 fork 해오면 된다. 이때 레포지토리 이름을 <code class="language-plaintext highlighter-rouge">{username}.github.io</code>로 설정하면 github에서 자동으로 해당 도메인으로 호스팅해준다. fork 직후에는 위 도메인으로 접속이 안 될 수도 있는데, 수 분 기다리거나 최소 하나의 변경 사항을 push 해주면 들어가진다.</p>

<p>마지막으로 작업 폴더에서 git clone하여 로컬 레포지토리를 생성한다.</p>

<h2 id="config-수정">config 수정</h2>

<p>대부분 Jekyll 테마에서 그렇듯 커스터마이징의 첫 단계는 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일을 수정하는 것이다. 블로그 이름, SNS 링크 등 기본적인 내용을 이곳에 입력하도록 되어 있다.</p>

<p>이제 기본적인 세팅은 끝이다. 바로 MD 파일을 생성해서 포스트를 업로드할 수 있다. 개인적으로는 약간 번거롭더라도 복구 가능성을 위해 항상 git branch로 작업 후 master에 merge 하는 편이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> post/blog-history
vi _posts/2024-08-19-blog-history.md
<span class="c"># 포스트 작성 후 ...</span>
git add <span class="nb">.</span>
git commit <span class="nt">-m</span> <span class="s1">'[post/init] 블로그 개발기'</span>
git push
<span class="c"># master 에 반영</span>
git checkout master
git merge post/blog-history
</code></pre></div></div>

<p>브랜치 네임이나 커밋 메시지의 컨벤션은 스스로 아래와 같이 정했다.</p>
<ul>
  <li>post/… : 블로그글 관련 브랜치</li>
  <li>feature/… : 블로그 기능 관련 브랜치</li>
  <li>[post/init] : 블로그글 최초 배포 커밋</li>
  <li>[post/modi] : 이후 블로그글 수정 커밋</li>
</ul>

<h1 id="구글-검색-연동">구글 검색 연동</h1>

<p>내용</p>

<h1 id="기능-추가">기능 추가</h1>

<p>이제부터 이어지는 내용은 기능을 추가한 히스토리를 기록한 것이다.</p>

<p>JavaScript를 잘 모르다보니 Workaround 형식으로 구현한 내용도 많다. 개선 지점은 언제든 덧글이나 연락처로 알려주시면 감사하겠다.</p>

<h2 id="back-to-top-버튼-구현">back-to-top 버튼 구현</h2>

<p><code class="language-plaintext highlighter-rouge">_includes/top.html</code>에 인라인 JS로 구현되어 있다. 외부 라이브러리 없이 순수 JavaScript로 작성했다.</p>

<ul>
  <li>스크롤 위치를 감지하여 일정 이상 내려가면 우측 하단에 원형 버튼이 나타남</li>
  <li>클릭 시 <code class="language-plaintext highlighter-rouge">cosine easing</code> 애니메이션으로 부드럽게 최상단으로 이동</li>
  <li>레이아웃(<code class="language-plaintext highlighter-rouge">default.html</code>, <code class="language-plaintext highlighter-rouge">page.html</code>, <code class="language-plaintext highlighter-rouge">post.html</code>)에서 <code class="language-plaintext highlighter-rouge">{% include top.html %}</code>로 삽입</li>
</ul>

<h2 id="검색-페이지-추가">검색 페이지 추가</h2>
<h3 id="검색-기능">검색 기능</h3>

<p><a href="https://github.com/christian-fei/Simple-Jekyll-Search">Simple-Jekyll-Search</a> 오픈소스를 활용했다.</p>

<ul>
  <li>Jekyll 빌드 시 <code class="language-plaintext highlighter-rouge">search.json</code>에 전체 포스트의 제목, 태그, 날짜, 본문을 JSON으로 생성</li>
  <li><code class="language-plaintext highlighter-rouge">search-and-return.js</code>에서 <code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code>를 초기화하고, 검색창 입력 시 JSON을 대상으로 클라이언트 사이드 검색 수행</li>
  <li>검색 결과는 제목, 날짜, 태그, 본문 미리보기로 구성</li>
</ul>

<h3 id="검색-결과-하이라이트">검색 결과 하이라이트</h3>

<p><code class="language-plaintext highlighter-rouge">search-and-return.js</code>의 <code class="language-plaintext highlighter-rouge">templateMiddleware</code>에서 구현했다.</p>

<ul>
  <li>검색어를 정규식으로 변환하여 제목, 태그, 본문에서 매칭되는 부분을 <code class="language-plaintext highlighter-rouge">&lt;b style="background:gold"&gt;</code> 로 강조 표시</li>
  <li>본문의 경우 매칭 위치 앞뒤 15단어만 잘라서 표시하고, 본문 내 총 언급 횟수를 함께 출력</li>
  <li>태그는 각각 태그 페이지로의 링크를 포함</li>
</ul>

<hr />
<h2 id="latex수학-수식-적용하기">LaTex(수학 수식) 적용하기</h2>

<p>LaTex를 렌더링해주는 KaTex 를 <code class="language-plaintext highlighter-rouge">_includes/head.html</code>의 head 부분에 추가한다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;script </span><span class="na">defer</span> <span class="na">src=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">defer</span> <span class="na">src=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"</span>
          <span class="na">onload=</span><span class="s">"renderMathInElement(document.body, {
            delimiters: [
              {left: '\\[', right: '\\]', display: true},
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
            ]
          });"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<ul>
  <li>delimiter를 명시한 이유는 inline LaTex를 제대로 인식하지 못했던 문제 때문이다</li>
  <li>명시한 이후에도 display LaTex가 적용되지 않는 문제가 있었다 : $$로 감싸도 \[\] 로 출력되었다 (사실 이것이 표준 display LaTex notation이라고 한다) 그래서 delimiter 항목으로 더 추가했다</li>
</ul>

<p>이제 LaTex 문법대로 수식을 $ 기호 1개 혹은 2개 사이에 작성하면 알맞게 렌더링 된다</p>

<p><strong>display LaTex</strong></p>

\[\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\]

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$$
<span class="se">\s</span>um_{i=1}^{k} <span class="se">\s</span>um_{<span class="se">\m</span>athbf{x} <span class="se">\i</span>n S_{i}} <span class="se">\l</span>eft<span class="se">\|\m</span>athbf{x} - <span class="se">\b</span>oldsymbol{<span class="se">\m</span>u}_{i}<span class="se">\r</span>ight<span class="se">\|</span>^{2}
$$  
</code></pre></div></div>

<p><strong>inline LaTex</strong><br />
문장 중간에 이렇게 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>문장 중간에 이런 수식을 $<span class="se">\s</span>um_{<span class="se">\m</span>athbf {x} <span class="se">\i</span>n S_{i}}<span class="se">\m</span>athbf {x}$ 넣을 수 있다
</code></pre></div></div>
<hr />

<h2 id="목차toc-추가">목차(TOC) 추가</h2>
<p>블로그글 옆 사이드바 형식의 목차를 추가한다. 아래는 플러그인을 설치해서 사용할 수 있는 <a href="https://github.com/toshimaru/jekyll-toc">jekyll-toc</a>을 적용한 내용이다.</p>

<p><a href="https://github.com/allejo/jekyll-toc">동일한 이름의 플러그인</a>이 있는데, 후술할 Github Pages 이슈로부터 자유로운 것으로 보인다. 처음으로 돌아간다면 이것을 적용해볼지도…</p>

<p><strong>설치 방법</strong></p>

<p><code class="language-plaintext highlighter-rouge">Gemfile</code>에 아래 라인을 추가한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'jekyll-toc'
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">bundle</code>로 설치를 진행한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle install
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 중 플러그인 부분에 요소를 추가한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins:
  - jekyll-sitemap
    ...
  - jekyll-toc # 추가
</code></pre></div></div>

<p><strong>사용 방법</strong></p>

<p>post 헤드에 <code class="language-plaintext highlighter-rouge">toc</code> 플래그를 추가한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: post
title: "Jekyll을 사용한 github.io 블로그 개발기"
tags: [JavaScript]
comments: True
toc: true
---
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">post.html</code>에 toc을 추가한다.<br />
단순히 <code class="language-plaintext highlighter-rouge">{{ content | toc }}</code>로 수정해서 <em>본문 위에 목차가 생성</em>되도록 하는 방법도 있지만 목차의 레이아웃이나 기능을 다양하게 커스터마이징 하기 위해 별도 태그인 <code class="language-plaintext highlighter-rouge">{% toc %}</code>로 추가했다.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;section</span> <span class="na">class=</span><span class="s">"entry"</span><span class="nt">&gt;</span>
    {% if page.toc %}
    <span class="nt">&lt;aside&gt;</span>
        <span class="nt">&lt;nav</span> <span class="na">class=</span><span class="s">"nav-toc"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;h3&gt;</span> 목차 <span class="nt">&lt;/h3&gt;</span>
            {% toc %}
        <span class="nt">&lt;/nav&gt;</span>
    <span class="nt">&lt;/aside&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ site.baseurl }}/assets/scroll-spy.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
    {% endif %}
    {{ content }}
<span class="nt">&lt;/section&gt;</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">{% if page.toc %}</code> : 헤드에 toc 플래그를 명시한 경우에만 목차가 추가되게 했다.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code> : 본문 옆 사이드바 형식으로 표시하기 위해 사용했다</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;nav&gt;</code> : 목차의 제목을 클릭했을 때 해당 영역으로 이동하도록 링크를 연결하기 위해 사용했다</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;h3&gt; 목차 &lt;/h3&gt;</code> : 플러그인으로 자동 생성되는 HTML에는 제목이 없길래 따로 추가해주었다 (사실 page.toc 조건을 굳이 넣은 것도 이 제목 때문이다. toc: false으로 세팅해도 h3 태그는 남아 있었기 때문이다.)</li>
</ul>

<h3 id="목차-레이아웃">목차 레이아웃</h3>

<p>목차의 위치와 모양을 세팅하는 과정이다.</p>

<p><strong>목차를 본문 좌측에 맞추고 스크롤과 상관없이 상단에 고정시키기</strong></p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">aside</span> <span class="p">{</span>
    <span class="nl">float</span><span class="p">:</span> <span class="nb">right</span><span class="p">;</span>
    <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="p">;</span>
    <span class="nl">width</span><span class="p">:</span> <span class="n">fit-content</span><span class="p">;</span>
    <span class="nl">top</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
    <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-300px</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">position</code>을 sticky로 설정하고 <code class="language-plaintext highlighter-rouge">top</code>값을 조금이라도 부여하면 스크롤과 상관없이 화면 한 쪽에 고정되는 효과를 구현할 수 있다</li>
  <li><code class="language-plaintext highlighter-rouge">margin-right</code>를 조정해서 본문과 너무 멀지도, 가깝지도 않게 위치시켰다</li>
</ul>

<p><strong>레이아웃을 심플하게 디자인하기</strong></p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.nav-toc</span> <span class="p">{</span>
  <span class="nl">font-size</span><span class="p">:</span> <span class="nb">smaller</span><span class="p">;</span>
  <span class="nl">border-left</span><span class="p">:</span> <span class="m">1px</span> <span class="nb">solid</span> <span class="err">$</span><span class="n">lightGray</span><span class="p">;</span>

  <span class="err">h3</span> <span class="err">{</span>
    <span class="nl">padding-left</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nt">ul</span> <span class="o">&gt;</span> <span class="nt">li</span> <span class="p">{</span>
    <span class="nl">list-style-type</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span> 
    <span class="err">&amp;:before</span> <span class="err">{</span>
      <span class="nl">content</span><span class="p">:</span> <span class="s2">''</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nt">ul</span> <span class="p">{</span>
      <span class="nl">display</span><span class="p">:</span> <span class="nb">inline</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="err">}</span>

  <span class="nt">ul</span> <span class="o">&gt;</span> <span class="nt">li</span> <span class="o">&gt;</span> <span class="nt">a</span><span class="nc">.active</span> <span class="p">{</span>
    <span class="nl">font-size</span><span class="p">:</span> <span class="nb">larger</span><span class="p">;</span>
    <span class="nl">font-weight</span><span class="p">:</span> <span class="nb">bold</span><span class="p">;</span>
  <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>
<ul>
  <li>기본적으로 폰트 사이즈는 작게, 리스트 앞에 붙는 마커는 생략했다
    <ul>
      <li><code class="language-plaintext highlighter-rouge">list-style-type: none</code>를 주었는데도 마커가 생성되어 <code class="language-plaintext highlighter-rouge">&amp;:before {content: '';}</code>를 별도로 추가했다</li>
    </ul>
  </li>
  <li>목차와 본문 사이 가는 구분선을 추가했다 (<code class="language-plaintext highlighter-rouge">border-left</code>)</li>
  <li>일부 하위 목차들이 가로로 나열되는(?) 이상한 현상이 있어서 <code class="language-plaintext highlighter-rouge">display: inline</code>을 추가했다</li>
  <li>목차가 하이라이트 대상일 때 폰트 사이즈와 굵기를 조금 키운다</li>
</ul>

<p><strong>목차 하이라이트 기능</strong><br />
스크롤의 위치에 따라 현재 보고 있는 콘텐츠의 목차를 하이라이트하는 기능이다. 위에서 toc 태그를 추가한 HTML 코드를 보면 <code class="language-plaintext highlighter-rouge">scroll-spy.js</code>라는 스크립트를 실행시키는 것을 볼 수 있는데, 이것이 <strong>스크롤 위치에 따라 하이라이트할 목차를 지정</strong>하는 역할을 한다.<br />
전체 코드를 살펴보겠다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 브라우저가 HTML을 전부 읽고 DOM 트리를 완성했을 때 발생하는 이벤트
document.addEventListener('DOMContentLoaded', () =&gt; {

    // links : H1, H2, H3 깊이 까지만 목차를 읽어온다 (a 태그 셀렉트)
    const Hs = document.querySelectorAll('.nav-toc ul.section-nav li.toc-entry.toc-h1, .nav-toc ul.section-nav li.toc-entry.toc-h2, .nav-toc ul.section-nav li.toc-entry.toc-h3');
    const links = Array.from(Hs).map(h =&gt; { return h.querySelector('a') })
    
    // anchors : links 의 각 요소로부터 href 를 읽어온다
    const anchors = Array.from(links).map(link =&gt; {
        const href = link.getAttribute('href');
        if (href) {
            return document.querySelector(href);
        }
        return null;
    }).filter(anchor =&gt; anchor !== null);

    // 스크롤 발생시
    window.addEventListener('scroll', () =&gt; {
        if (anchors.length &gt; 0 &amp;&amp; links.length &gt; 0) {
            let scrollTop = window.scrollY;
            let activeIndex = -1;

            // 스크롤 위치와 제목의 위치가 가까울 경우 (격차가 300 이하)
            // 활성화할 제목의 인덱스를 저장한다
            anchors.forEach((anchor, i) =&gt; {
                if (scrollTop &gt;= anchor.offsetTop - 300) {
                activeIndex = i; 
                }
            });

            // 나머지 제목은 비활성화 한다
            links.forEach((link) =&gt; {
                link.classList.remove('active');
            });
            
            // 인덱스가 유효하면 제목을 활성화한다
            if (activeIndex &gt;= 0) {
                links[activeIndex].classList.add('active');
            }
        }
  });
});
</code></pre></div></div>
<p>코드의 동작 원리는 주석을 참고하면 된다.</p>

<p>개인적으로 까다로웠던 점은 특정 깊이(h3)까지만 목차를 읽어오는 것이었다. 모든 제목이 하이라이트되는 것을 원하지 않았고 h4 이상부터는 상위 제목을 하이라이트하는 게 목차로서 의미가 있다고 판단했다.</p>

<p><code class="language-plaintext highlighter-rouge">querySelectorAll</code>를 사용해서 <em>모든</em> 제목의 a 태그를 바로 긁어올 수 있지만 <em>특정 깊이까지만</em> 읽어오기 위해서 H1부터 H3까지 직접 지정해서 읽어온 다음 그 안에서 a 태그를 가져오게 했다. 그 뿐만 아니라 숫자로 시작하는 제목(<a href="https://woocosmos.github.io/swift-start/#1-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%84%A0%ED%83%9D"> 예를 들면 … </a>)은 href를 읽어올 때 에러가 발생했기 때문에 애초에 지정한 만큼만 읽고 그 안에서 파싱하는 방식이 가장 깔끔하다고 생각했다.</p>

<p>또 지속적으로 마주했던 에러는 links와 anchors 변수가 빈 배열을 반환하는 문제였는데, 이는 DOMContentLoaded 이벤트를 조건으로 추가함으로써 해결했다.</p>

<p>하여, 나만의 sticky highlighted TOC 이 완성되었다<br />
<img src="https://github.com/user-attachments/assets/257eecc6-c39b-4063-b99b-3448b8167d64" alt="image" /></p>

<h3 id="gh-pages-생성">gh-pages 생성</h3>

<p>그러나 TOC 기능을 추가한 후 Github Pages에서 빌드/배포 실패가 떴다. 분명 로컬 서버에서는 잘 돌아갔는데 말이다.</p>

<p><img src="https://github.com/user-attachments/assets/1060cd1e-0e19-45df-a006-af55b13daf18" alt="image" width="60%" /></p>

<p>에러 메시지에 ‘Unknown tag toc’이라고 적힌 것으로 보아 Jekyll-toc 플러그인 쪽 문제로 보였다.<br />
실제로 Jekyll-toc 레포지토리의 이슈 채널에서 동일한 문제를 호소하는 글들을 확인할 수 있었다.</p>

<ul>
  <li><a href="https://github.com/toshimaru/jekyll-toc/issues/151">Is Github Pages not supported? #151</a></li>
  <li><a href="https://github.com/toshimaru/jekyll-toc/issues/29">TOC on GitHub Pages #29</a></li>
  <li><a href="https://github.com/toshimaru/jekyll-toc/issues/151">Is Github Pages not supported? #151</a></li>
</ul>

<blockquote>
  <p>GitHub Pages cannot build sites using unsupported plugins. If you want to use unsupported plugins, generate your site locally and then push your site’s static files to GitHub.</p>
</blockquote>

<p>이는 Github Pages 서비스에서 내가 사용한 toc 플러그인을 지원하지 않아 발생한 문제였다.
따라서 <strong>로컬로 사이트를 직접 빌드</strong>한 후 해당 내용을 배포하도록 하는 방법으로 문제를 해결할 수 있다. 이때 <code class="language-plaintext highlighter-rouge">gh-pages</code>라는 브랜치로 밀어넣고 root 경로로 설정해야 한다. 참고한 <a href="https://dqdongg.com/blog/github/2018/12/29/Blog-Jekyll-toc-plugin.html#fn:2">칼럼</a>은 여기.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로컬에서 빌드한다</span>
jekyll build
<span class="c"># _site 폴더를 어딘가로 대피시킨다</span>
<span class="nb">mv</span> <span class="nt">-r</span> _site /path/to/tmp
git checkout <span class="nt">--orphan</span> gh-pages 
<span class="c"># 폴더를 비우고 _site 데이터를 다시 가져온다</span>
<span class="nb">rm</span> <span class="nt">-rf</span> <span class="k">*</span> 
<span class="nb">cp</span> <span class="nt">-r</span> /path/to/tmp/_site/<span class="k">*</span> ./
git add <span class="nt">-A</span>
git commit <span class="nt">-m</span> <span class="s2">"build locally and create gh-pages"</span>
git push origin gh-pages
</code></pre></div></div>
<p>브랜치를 생성할 때 <code class="language-plaintext highlighter-rouge">--orphan</code> 옵션을 추가한 이유는 부모(master)로부터 커밋 히스토리를 이어 받지 않은 독립적인 브랜치를 새로 만들기 위함이다. 마치 레포지토리 안에 새로운 레포지토리를 시작한다고 생각할 수 있겠다.</p>

<p>마지막으로는 레포지토리에서 Settings &gt; Pages &gt; Source 그리고 Branch를 gh-pages로 수정하면 된다
<img src="https://github.com/user-attachments/assets/e19c52f7-e095-4442-b0f0-12f2c59cbf1e" alt="image" /></p>

<p>문제는 이제 앞으로 변경사항을 반영할 때마다 _site 의 내용을 매번 옮겨놨다가 다른 데이터를 삭제하는 식으로 업데이트 해야 한다는 것이다. 위 과정은 향후 <strong>Github Actions를 활용해 자동화된 workflow로 구축</strong>할 예정이다.</p>

    </section>
  </div>

  <div class="pagination">
    
      <span class="prev" >
          <a href="https://woocosmos.github.io/swift-start/">
            &#xE000; 아이폰 iOS앱 개발 체험하기: 환경 세팅과 시뮬레이션
          </a>
      </span>
    
    
      <span class="next" >
          <a href="https://woocosmos.github.io/kmeans-algo/">
            K-Means Clustering 군집화 알고리즘 &#xE001;
          </a>
      </span>
    
  </div>

  <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'woocosmos';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
			dsq.setAttribute('data-timestamp', +new Date()); //추가
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  <script type="text/javascript">
    "use strict"; 
    function addBackToTop() 
        { function o() 
            { 
                t() >= z ? R && (D.className = "", R = !1) : R || (D.className = "hidden", R = !0) 
            } 
          function t() 
            { 
                return E.scrollTop || A && document.documentElement.scrollTop || 0 
            } 
          function e(o) 
            { 
                E.scrollTop = o, A && (document.documentElement.scrollTop = o) 
            } 
    
    var n, i, d, r, c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a = c.backgroundColor, s = void 0 === a ? "#000" : a, l = c.cornerOffset, u = void 0 === l ? 20 : l, m = c.diameter, p = void 0 === m ? 56 : m, h = c.ease, b = void 0 === h ? function (o) { return .5 * (1 - Math.cos(Math.PI * o)) } : h, v = c.id, f = void 0 === v ? "back-to-top" : v, x = c.innerHTML, g = void 0 === x ? '<svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg>' : x, w = c.onClickScrollTo, y = void 0 === w ? 0 : w, k = c.scrollContainer, E = void 0 === k ? document.body : k, T = c.scrollDuration, C = void 0 === T ? 100 : T, M = c.showWhenScrollTopIs, z = void 0 === M ? 1 : M, L = c.size, B = void 0 === L ? p : L, H = c.textColor, I = void 0 === H ? "#fff" : H, N = c.zIndex, S = void 0 === N ? 1 : N, q = E === document.body, A = q && document.documentElement; n = Math.round(.35 * B), i = Math.round(.2 * B), d = "#" + f + "{background:" + s + ";-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:" + u + "px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:" + I + ";cursor:pointer;display:block;height:" + B + "px;opacity:1;outline:0;position:fixed;right:" + u + "px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:" + B + "px;z-index:" + S + "}#" + f + " svg{display:block;fill:currentColor;height:" + n + "px;margin:" + i + "px auto 0;width:" + n + "px}#" + f + ".hidden{bottom:-" + B + "px;opacity:0}", (r = document.createElement("style")).appendChild(document.createTextNode(d)), document.head.insertAdjacentElement("afterbegin", r); var D = function () { var o = document.createElement("div"); return o.id = f, o.className = "hidden", o.innerHTML = g, o.addEventListener("click", function (o) { o.preventDefault(), function () { var o = "function" == typeof y ? y() : y, n = window, i = n.performance, d = n.requestAnimationFrame; if (C <= 0 || void 0 === i || void 0 === d) return e(o); var r = i.now(), c = t(), a = c - o; d(function o(t) { var n = Math.min((t - r) / C, 1); e(c - Math.round(b(n) * a)), n < 1 && d(o) }) }() }), document.body.appendChild(o), o }(), R = !0; (q ? window : E).addEventListener("scroll", o), o() } window.addEventListener("load", function () { var o = document.getElementById("back-to-top"), t = document.querySelector(".sticky-bottom"), e = document.querySelector(".fixed-bottom"); o && window.addEventListener("scroll", function () { if (t) { var n = t.getBoundingClientRect(); window.scrollY + window.innerHeight > document.body.scrollHeight - n.height ? (o.style.position = "fixed", o.style.bottom = n.height + 15 + "px") : (o.style.position = "fixed", o.style.bottom = "15px") } if (e) { var i = e.getBoundingClientRect(); o.style.position = "fixed", o.style.bottom = i.height + 15 + "px" } }) });
</script>
<script>
    addBackToTop();
</script>




</article>

    </div>
    
    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  
  <li><a href="mailto:woocosmos@gmail.com" class="icon-8 email" title="Email"><svg viewBox="0 0 512 512"><path d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/></svg><!--[if lt IE 9]><em>Email</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://github.com/woocosmos" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  
  <li><a href="https://www.linkedin.com/in/yunsoo-woo-245946213" class="icon-17 linkedin" title="LinkedIn"><svg viewBox="0 0 512 512"><path d="M186.4 142.4c0 19-15.3 34.5-34.2 34.5 -18.9 0-34.2-15.4-34.2-34.5 0-19 15.3-34.5 34.2-34.5C171.1 107.9 186.4 123.4 186.4 142.4zM181.4 201.3h-57.8V388.1h57.8V201.3zM273.8 201.3h-55.4V388.1h55.4c0 0 0-69.3 0-98 0-26.3 12.1-41.9 35.2-41.9 21.3 0 31.5 15 31.5 41.9 0 26.9 0 98 0 98h57.5c0 0 0-68.2 0-118.3 0-50-28.3-74.2-68-74.2 -39.6 0-56.3 30.9-56.3 30.9v-25.2H273.8z"/></svg><!--[if lt IE 9]><em>LinkedIn</em><![endif]--></a></li>
  

  

  

  

  

  

  

</ul>


<p>© 2026 Yunsoo Woo</p>

        </footer>
      </div>
    </div>

    <!--  -->

<script async src="https://www.googletagmanager.com/gtag/js?id=G-1YCJCQRD4F"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1YCJCQRD4F');
</script>
    <script type="text/javascript">
    "use strict"; 
    function addBackToTop() 
        { function o() 
            { 
                t() >= z ? R && (D.className = "", R = !1) : R || (D.className = "hidden", R = !0) 
            } 
          function t() 
            { 
                return E.scrollTop || A && document.documentElement.scrollTop || 0 
            } 
          function e(o) 
            { 
                E.scrollTop = o, A && (document.documentElement.scrollTop = o) 
            } 
    
    var n, i, d, r, c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a = c.backgroundColor, s = void 0 === a ? "#000" : a, l = c.cornerOffset, u = void 0 === l ? 20 : l, m = c.diameter, p = void 0 === m ? 56 : m, h = c.ease, b = void 0 === h ? function (o) { return .5 * (1 - Math.cos(Math.PI * o)) } : h, v = c.id, f = void 0 === v ? "back-to-top" : v, x = c.innerHTML, g = void 0 === x ? '<svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg>' : x, w = c.onClickScrollTo, y = void 0 === w ? 0 : w, k = c.scrollContainer, E = void 0 === k ? document.body : k, T = c.scrollDuration, C = void 0 === T ? 100 : T, M = c.showWhenScrollTopIs, z = void 0 === M ? 1 : M, L = c.size, B = void 0 === L ? p : L, H = c.textColor, I = void 0 === H ? "#fff" : H, N = c.zIndex, S = void 0 === N ? 1 : N, q = E === document.body, A = q && document.documentElement; n = Math.round(.35 * B), i = Math.round(.2 * B), d = "#" + f + "{background:" + s + ";-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;bottom:" + u + "px;-webkit-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);-moz-box-shadow:0 2px 5px 0 rgba(0,0,0,.26);box-shadow:0 2px 5px 0 rgba(0,0,0,.26);color:" + I + ";cursor:pointer;display:block;height:" + B + "px;opacity:1;outline:0;position:fixed;right:" + u + "px;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-transition:bottom .2s,opacity .2s;-o-transition:bottom .2s,opacity .2s;-moz-transition:bottom .2s,opacity .2s;transition:bottom .2s,opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:" + B + "px;z-index:" + S + "}#" + f + " svg{display:block;fill:currentColor;height:" + n + "px;margin:" + i + "px auto 0;width:" + n + "px}#" + f + ".hidden{bottom:-" + B + "px;opacity:0}", (r = document.createElement("style")).appendChild(document.createTextNode(d)), document.head.insertAdjacentElement("afterbegin", r); var D = function () { var o = document.createElement("div"); return o.id = f, o.className = "hidden", o.innerHTML = g, o.addEventListener("click", function (o) { o.preventDefault(), function () { var o = "function" == typeof y ? y() : y, n = window, i = n.performance, d = n.requestAnimationFrame; if (C <= 0 || void 0 === i || void 0 === d) return e(o); var r = i.now(), c = t(), a = c - o; d(function o(t) { var n = Math.min((t - r) / C, 1); e(c - Math.round(b(n) * a)), n < 1 && d(o) }) }() }), document.body.appendChild(o), o }(), R = !0; (q ? window : E).addEventListener("scroll", o), o() } window.addEventListener("load", function () { var o = document.getElementById("back-to-top"), t = document.querySelector(".sticky-bottom"), e = document.querySelector(".fixed-bottom"); o && window.addEventListener("scroll", function () { if (t) { var n = t.getBoundingClientRect(); window.scrollY + window.innerHeight > document.body.scrollHeight - n.height ? (o.style.position = "fixed", o.style.bottom = n.height + 15 + "px") : (o.style.position = "fixed", o.style.bottom = "15px") } if (e) { var i = e.getBoundingClientRect(); o.style.position = "fixed", o.style.bottom = i.height + 15 + "px" } }) });
</script>
<script>
    addBackToTop();
</script>





  </body>
</html>
