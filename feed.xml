<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://woocosmos.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://woocosmos.github.io/" rel="alternate" type="text/html" /><updated>2024-12-22T14:14:31+00:00</updated><id>http://woocosmos.github.io/feed.xml</id><title type="html">YunsooLog</title><subtitle>나름 진지한 ML Engineer</subtitle><entry><title type="html">[라즈베리 파이를 활용한 홈서버 구축] 01. 킥오프</title><link href="http://woocosmos.github.io/raspberry-pi-01/" rel="alternate" type="text/html" title="[라즈베리 파이를 활용한 홈서버 구축] 01. 킥오프" /><published>2024-12-22T00:00:00+00:00</published><updated>2024-12-22T00:00:00+00:00</updated><id>http://woocosmos.github.io/raspberry-pi-01</id><content type="html" xml:base="http://woocosmos.github.io/raspberry-pi-01/"><![CDATA[<h1 id="개요">개요</h1>

<p><img src="https://github.com/user-attachments/assets/3950b7db-9f10-4797-983e-d1e389cab2c2" alt="image" width="60%" /></p>

<p>라즈베리 파이(Raspberry Pi)를 활용한 홈서버 구축 프로젝트를 시작하려 한다. 이번 포스트에서는 프로젝트의 목적과 목표를 명확히 하고, 그에 맞춰 필요한 제품 스펙을 결정하는 과정을 기록한다.</p>

<h1 id="계기">계기</h1>

<blockquote>
  <p>며칠 전, 회사 워크숍에서 버킷리스트를 작성하는 시간을 가졌다. 다들 세계여행이나 내 집 마련 같은 것을 적었는데, 나는 홈서버 구축하기를 쓰고 있었다.
그러고 보니 인생 버킷리스트까지도 아니고 <em>그냥 당장 실행하면 되지 않을까?</em> 라는 생각이 들었다.</p>
</blockquote>

<p>작은 자취방에서 가지고 놀 수 있는 <strong>작은 컴퓨터</strong>를 갖고 싶다는 생각에서 시작했다. 운영체제는 리눅스로 해서 CLI 개발 환경의 고수가 되고 싶었다. VSCode 대신에 Vim 으로 코드를 작성하는 지독한 컨셉의 개발자가 되고 싶었다. (이건 농담이다)</p>

<p>지금까지 지나온 개발 환경을 순서대로 짚어보았다.</p>

<ol>
  <li><strong>구글 코랩</strong> : 밑바닥부터 시작하는 데 이만한 도구가 있을까. 버튼 클릭 하나로 구글 데이터센터의 고성능 GPU 를 사용할 수 있었다.</li>
  <li><strong>클라우드 서버</strong> : 프로젝트가 본격화되면서 코랩의 사용량 제한이 걸림돌으로 작용했다. 이에 AWS EC2 스팟 인스턴스를 하나 구입해서 사용하기 시작했다.</li>
  <li><strong>온프레미스 서버</strong> : 국가 사업에 선정되면서 그래픽 카드를 마련할 수 있게 되었다. 사무실 한 켠에서 열과 소음을 뿜어내던 그 녀석을 SSH 로 접근해서 마음대로 다뤄볼 수 있었다.</li>
  <li>(<em>현재</em>) <strong>로컬 환경</strong> : 이직하고 보니 컴퓨터마다 좋은 그래픽 카드가 하나씩 꽂혀 있었다. (스타트업에 있다 와서 그런지 충격적이었다) 물론 서버 인스턴스만큼은 넉넉하지 않지만, 적당한 크기의 모델 학습이나 추론은 로컬 환경에서도 거뜬했다.</li>
</ol>

<p>특히 LLM 모델이 거대화되고 API 로 접근하는 방식이 널리 퍼지면서 오히려 로컬 환경에서 개발하기 편리해졌다고 느낀다. 그러나 반대 급부로 그만한 사이즈의 모델을 튜닝하거나 다루기 위해서는 <strong>서버 환경에서의 개발 역량</strong> 또한 놓칠 수 없다고 생각한다.</p>

<p>아쉽지만 현재 회사에서는 프로젝트 상 로컬 환경을 활용하는 것이 최선이므로, 개인적으로 홈서버를 구축하고 스스로 연습하려는 것이다. 먼 이야기지만 나중에 회사에서 서버 인스턴스를 할당 받았을 때 실수나 사고 없이 안정적으로 해내는 모습을 보여드리고 싶기도 하고.</p>

<p><img src="https://github.com/user-attachments/assets/843ec181-9048-4cd4-be37-9a04ecf4fee1" alt="image" /></p>

<p>무엇보다도 전자 회로 기판을 조립해서 만든 작은 컴퓨터는 나만의 작은 공간을 창조한다는 감동을 준달까. 기계와 로우레벨의 교감을 주고 받는 것이다…</p>

<h1 id="목표">목표</h1>

<p>홈서버를 구축하고 난 뒤에 구체적으로 어떤 것들을 해볼 수 있을지 목표를 정리해보았다. 목표는 제품의 스펙을 결정하는 기준이 될 것이다. (나는 보통 목표를 질문의 형식으로 작성하는데, 그 질문들에 답변할 수 있을 때 목표를 이루었다고 여기기 때문이다)</p>

<ul>
  <li>리눅스 운영체제는 어떻게 동작하는 것일까?</li>
  <li>파이썬과 운영체제는 어떻게 상호작용하는 것일까?</li>
  <li>데이터를 최대한 효율적으로 처리하는 방법은 무엇일까?</li>
  <li>머신러닝 모델을 경량화하는 방법은 무엇일까?</li>
  <li>머신러닝 모델의 추론과 운영을 어떻게 컨테이너화할까?</li>
  <li>왜 C/C++ 개발 역량을 지닌 머신러닝 엔지니어가 우대 받는 걸까?</li>
</ul>

<p><strong>로우레벨 환경에서 운영체제와 파이썬 언어의 동작을 이해하는 것</strong>과 <strong>매우 한정된 성능 안에서 데이터 처리를 최적화하는 것</strong>으로 요약할 수 있겠다.</p>

<h1 id="절대적-우선순위">절대적 우선순위</h1>

<p>제품 스펙을 살펴보기 앞서 현실적으로 고려해야 할 두 가지를 먼저 언급하려 한다. 바로 <strong>가격</strong>과 <strong>사이즈</strong>다.</p>

<p>실습, 장난감 용도이기 때문에 큰 돈을 들일 생각이 없다. 가성비 전략으로 간다. 중고 물품도 적극 고려할 예정.</p>

<p>또한 활동 공간이 3평 남짓한 자취방에서 감당할 수 있어야 하므로 사이즈는 최대한 미니미니하게 해야 한다.</p>

<h1 id="구성-요소">구성 요소</h1>

<p><img src="https://github.com/user-attachments/assets/c3f8de55-84c7-4df3-b279-d21a5168a186" alt="image" /></p>

<p>오늘날 컴퓨터는 폰 노이만 구조를 뼈대로 하여 확장된 형태이다. 이번 프로젝트에서 어떤 구성품을 마련할지 고민하면서 이 폰 노이만 컴퓨터를 참고할 수 있었다.</p>

<p>폰 노이만 구조의 구성 요소는 CPU, 메모리, 프로그램이다. 이때 프로그램은 메모리 안에 저장되고 실행되는 명령어의 집합이다.</p>

<p>그러니까 하드웨어 관점에서 필수 요소는 <strong>처리 장치(CPU)</strong>, <strong>기억 장치(메모리)</strong>, 그리고 이들을 운영하고 제어하기 위한 <strong>입출력 장치</strong>다.</p>

<h2 id="cpu-와-메모리">CPU 와 메모리</h2>

<p>싱글보드 컴퓨터는 메인보드(Motherboard)에 처리 장치인 CPU와 주기억 장치인 RAM이 탑재되어 있는 것을 말한다. 라즈베리 파이가 대표적인 싱글보드 컴퓨터 제품.</p>

<p>사실 엔비디아에도 싱글보드 컴퓨터 라인업이 있으며 GPU 활용이 필요하다면 이쪽이 더 나을 수도 있다.</p>

<p><img src="https://github.com/user-attachments/assets/f1ebca65-b9bc-4ab1-9fa4-a0a45240d6af" alt="image" /></p>

<p>야속하게도 불과 5일 전 엔비디아에서 AI용 싱글보드 컴퓨터 개발자 키트를 매우 합리적인 가격에 출시한다는 <a href="https://www.aitimes.com/news/articleView.html?idxno=166348">소식</a>을 내놨다. <code class="language-plaintext highlighter-rouge">젯슨 오린 나노(Jetson ORIN™ Nano)</code> 라는 제품이고 249달러(한화 약 36만원)다. LLM 등 딥러닝 모델 처리에 특화된 제품이라고 한다.</p>

<blockquote>
  <p>너무나도 갖고 싶다…</p>
</blockquote>

<p>하지만 나의 절대적인 기준은 가격이기 때문에 욕심을 내려놓으려 한다. 젯슨 시리즈는 나중에 더 큰 집으로 이사 가면 모셔보겠다 🥲</p>

<hr />

<p>라즈베리 파이도 여러 제품이 있다. 몇 세대를 살지, 램 사이즈는 어느 정도로 할지 결정해야 한다.</p>

<p><strong>몇 세대를 살 것인가?</strong> ➡️ 4 세대</p>

<p>주로 4세대와 5세대를 많이 비교하는 것 같다.</p>

<p>2019년 출시된 4세대는 성능과 가격 측면에서 경쟁력이 있어 독보적으로 인기 있는 제품이라고 한다. 5세대는 비교적 최근인 2023년에 출시되었는데, 이전 세대에 비해 가격도 오른 데다 발열이나 어댑터 등 이슈가 있어 차라리 미니 PC를 사는 편이 낫다고 보는 견해가 많다. 나도 5세대 제품 가격 보고 ‘그냥 젯슨을 살까 …‘라고 고민했는데, 그럴 바에 <u>4세대를 선택하겠다</u>고 판단했다.</p>

<p><strong>램 사이즈는?</strong> ➡️ 4GB</p>

<p>1, 2, 4, 8GB 옵션이 있다. 모델 올리는 것을 생각하면 4GB 이상은 되어야 할 텐데, 4GB는 7만원대이고 8GB는 11만원대로 가격 차이가 난다. 성능보다 가격이 중요한 상황이므로 전자로 결정했다.</p>

<h3 id="상세-스펙">상세 스펙</h3>

<p>구체적인 스펙은 아래와 같다. <a href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/specifications/">공식 사이트</a>를 참고했다.</p>

<p><img src="https://github.com/user-attachments/assets/15ba5b82-4c60-4571-b6b2-c3f3e19f6b91" alt="image" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>카테고리</strong></th>
      <th style="text-align: left"><strong>내용</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>프로세서</strong></td>
      <td style="text-align: left">Broadcom BCM2711, 쿼드코어 Cortex-A72 (ARM v8) 64-bit SoC @ 1.8GHz</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>메모리(RAM)</strong></td>
      <td style="text-align: left">8GB</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>무선 연결</strong></td>
      <td style="text-align: left">2.4 GHz/5.0GHz 와이파이, Bluetooth 5.0, BLE</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>유선 연결(이더넷)</strong></td>
      <td style="text-align: left">기가비트 이더넷</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>USB 포트</strong></td>
      <td style="text-align: left">USB 3.0 포트 2개, USB 2.0 포트 2개</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>GPIO</strong></td>
      <td style="text-align: left">라즈베리 파이 표준 40핀 GPIO 헤더</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>디스플레이 출력</strong></td>
      <td style="text-align: left">micro-HDMI 포트 2개 (최대 4k60 지원)</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>디스플레이 인터페이스</strong></td>
      <td style="text-align: left">2-레인 MIPI DSI 디스플레이 포트</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>그래픽</strong></td>
      <td style="text-align: left">OpenGL ES 3.1, Vulkan 1.0</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>저장 장치</strong></td>
      <td style="text-align: left">Micro SD 카드 슬롯</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>전원 공급</strong></td>
      <td style="text-align: left">USB-C 포트/GPIO 헤더를 통한 전원 공급, 5V DC, 최소 3A</td>
    </tr>
  </tbody>
</table>

<h2 id="보조-기억-장치">보조 기억 장치</h2>

<p>라즈베리 파이4는 SD카드를 지원한다. 운영체제 설치까지 고려해서 용량이 32GB 는 되어야 할 것 같다.</p>

<p>우선 가장 무난하게 Sandisk Ultra 32GB (6천원대) 사용할 예정이다. 호환 가능한 <a href="https://elinux.org/RPi_SD_cards#Working_.2F_Non-working_SD_cards">SD 카드 리스트</a>도 확인해보자.</p>

<p>라즈베리 파이 환경에서 SD카드 제품별로 성능을 비교한 훌륭한 <a href="https://makeutil.tistory.com/254">블로그글</a>이 있으니 참고하시라.</p>

<h2 id="입출력-장치">입출력 장치</h2>

<p><img src="https://github.com/user-attachments/assets/e593651c-7542-4f6b-8145-91655025b426" alt="Image" /></p>

<p>이번에 선물 받은 하기비스 미니 모니터를 연결할 예정이다. 다만 전원 등 호환이 될지 모르겠다. <a href="https://ko.aliexpress.com/item/1005006767426312.html?srcSns=sns_KakaoTalk&amp;spreadType=socialShare&amp;bizType=ProductDetail&amp;social_params=6000213862574&amp;aff_fcid=056f945532e144c7ae1b3bbe9066a2b7-1734873003608-04553-_op0QH0f&amp;tt=MG&amp;aff_fsk=_op0QH0f&amp;aff_platform=default&amp;sk=_op0QH0f&amp;aff_trace_key=056f945532e144c7ae1b3bbe9066a2b7-1734873003608-04553-_op0QH0f&amp;shareId=6000213862574&amp;businessType=ProductDetail&amp;platform=AE&amp;terminal_id=8902864ebb8a43d7ac279d621575f15c&amp;afSmartRedirect=y">알리</a>에서 5만원대에 구입했는데, 현재 7만원대로 올랐다.</p>

<p>하기비스 모니터 설명으로 미루어봐서 micro HDMI to USB-C 어댑터가 필요할 것으로 보인다.</p>
<blockquote>
  <p>One Cable Connection Mode: USB3.1 Gen2 cable connects HOST port and USB-C port of the laptop, allowing for simultaneous IPS mini screen display and interface expansion. *Note: The USB-C interface of the laptop must be Thunderbolt 3/4, USB4, or a USB-C interface that supports the DisplayPort (DP) protocol in order to use this mode</p>
</blockquote>

<p>키보드는 집에 있는 키크론 키보드를 활용할 것이다.</p>

<p>사실 입출력 장치는 큰 걱정이 없다. 어차피 맥북으로 SSH 원격 접속할 예정이기 때문이다.</p>

<h2 id="네트워크">네트워크</h2>

<p>자취방의 와이파이를 연결할 예정이다. 다만 자취방 와이파이가 <em>매우 불안정하여</em> 제멋대로 끊길 때가 많은데 - 체감상 4~5시간에 한 번(…) - 이게 얼마나 큰 문제로 작용할지는 … 일단 연결해봐야 알겠다.</p>

<h2 id="전원-공급-장치">전원 공급 장치</h2>

<p>라즈베리 파이4 부터는 전원을 USB-C 타입으로 공급 받는다. 모니터를 연결했을 때 전류가 얼마나 될지 모르겠지만, 가장 안전하게 라즈베리 파이4에 맞게 나온 5V 4A <a href="https://www.devicemart.co.kr/goods/view?no=12544959">전용 어댑터</a>면 좋을 것 같다. 가격은 7천원.</p>

<h2 id="기타-장비">기타 장비</h2>

<p>그 외 케이스, 방열판, 쿨러 등 보조 부품들이 있다. 이것은 필수 부품들을 갖추고 나서 하나씩 모을 생각이다. 이왕이면 이쁜 것들로 고심해서 고르고 싶기도 하고.</p>

<h3 id="결산">결산</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>필수 부품</strong></th>
      <th style="text-align: left"><strong>가격</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>라즈베리 파이</strong></td>
      <td style="text-align: left">78,000원 ~</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>SD 카드</strong></td>
      <td style="text-align: left">6,200원 ~</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>micro HDMI to USB-C 어댑터</strong></td>
      <td style="text-align: left">제품을 찾을 수 없음;;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>전원 어댑터</strong></td>
      <td style="text-align: left">7,000원</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>보조 장비</strong></td>
      <td style="text-align: left">아직 모름</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>총합</strong></td>
      <td style="text-align: left">83,200원 이상</td>
    </tr>
  </tbody>
</table>

<p>대충 훑어봤지만 micro HDMI to USB-C 제품이 보이지 않는 게 약간 난감하다. micro HDMI 를 HDMI 로 변환한 후에 C타입으로 연결해야 할 것 같은 불길한 느낌. 그래도 필수 부품만 해서 10만원 이하로 맞출 수 있다면 충분히 만족스러울 것 같다.</p>

<h1 id="나가며">나가며</h1>

<p>오늘은 홈서버 프로젝트를 위해 목표와 장비의 스펙을 정리해보았다. 필수 부품을 하나씩 마련한 후에 운영체제 설치 등 세팅 과정을 블로그에 연재할 계획이다. 실습까지 갈 길이 멀지만 즐겁게, 꾸준히 해보자!</p>]]></content><author><name></name></author><category term="홈서버" /><summary type="html"><![CDATA[개요]]></summary></entry><entry><title type="html">내가 무엇을, 왜 하고 있는지 인지하기 [수습기간 회고]</title><link href="http://woocosmos.github.io/probation/" rel="alternate" type="text/html" title="내가 무엇을, 왜 하고 있는지 인지하기 [수습기간 회고]" /><published>2024-11-21T00:00:00+00:00</published><updated>2024-11-21T00:00:00+00:00</updated><id>http://woocosmos.github.io/probation</id><content type="html" xml:base="http://woocosmos.github.io/probation/"><![CDATA[<h1 id="들어가며">들어가며</h1>

<p>2024년 9월 지금의 조직으로 이동하여 3개월의 수습 기간 종료를 앞두고 있다. 합류와 동시에 바로 현업에 투입되었기 때문에 what/why/how를 정리하지 못한 채 정신없이 시간을 보냈다. 이번 수습 회고에서는 지금까지 해온 구체적인 ACTION을 직무 관점에서 ‘무엇을 했는지’로 추상화하고, ‘왜 그렇게 했는지’ 의도를 부여하려 한다. 그리고 과정 중에서 어려움을 느꼈거나 개선의 여지가 있는 지점을 파악할 것이다.</p>

<p>물론 프로젝트의 내용은 밝히기 어려우니 기술 스택을 중점으로 다룰 예정이다. 일부 구체적인 사례가 필요한 경우에는 간단한 예시로 대체하겠다.</p>

<h1 id="직무에-대해서">직무에 대해서</h1>

<p>지금 회사에서 나의 직무는 분석가다. 여기서 분석가는 UX분석가, 데이터분석가, AI엔지니어 등을 포괄적으로 지칭하는 말이다. 그 중에서 나는 <strong>AI엔지니어</strong>라는 포지션로 입사했지만 대체로 데이터 과학자, 데이터 분석가, ML엔지니어를 오가는 다양한 업무를 접했다.</p>

<p>이전 회사에서는 하나의 프로젝트에 소속된 상태였다. 따라서 해당 서비스의 데이터 안에서 여러 방면으로 경험할 수 있었다. 당연하게도 모든 일의 목적은 근본적으로 ‘서비스를 성공시키는 것’이기 때문에 업무마다 문제와 목표가 달라지곤 했다. 간단하게는 지표의 현황을 파악하는 것, 위험을 최소화하기 위해 pain point를 탐색하는 것, 서비스의 피처가 의도대로 작동하는지 확인하는 것, ML 기반의 새로운 컨텐츠를 리서치하는 것, 내부 개발진을 대상으로 데이터 기반의 의사결정을 도모하는 것 등등.</p>

<p>이렇게 분석가로서 다양한 영역의 작업을 경험한다는 것은 뚜렷한 장단점을 지닌다.</p>

<ul>
  <li>장점
    <ul>
      <li>다양한 스킬셋을 확보할 수 있었다</li>
      <li>비즈니스와 기술적 액션의 연결고리를 이해하게 되었다</li>
      <li>협업과 커뮤니케이션 역량을 강화했다</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>나의 역할과 커리어의 방향성 불분명했다</li>
      <li>특정 영역의 전문성을 쌓기 어려웠다</li>
    </ul>
  </li>
</ul>

<p>특히 <strong>비즈니스와 기술적 액션을 연결 짓는 역량</strong>은 나에게 대단한 발전이었다. <em>어쨌든 회사는 돈을 벌어야 한다.</em> 기술적으로 깊이를 더하거나 새로운 기술을 도입, 고도화하더라도 그것이 비즈니스 임팩트를 창출하거나 의사결정에 실질적으로 기여하지 못한다면 “그래서 이걸 해서 뭐?” 라는 허무한 질문으로 끝나버릴 수 있는 것이다. 조직과 나의 성과로 연결되는 일을 해야 한다는 중요한 깨달음을 얻었다. (물론 리서치 중심의 조직이거나 학술적 목적이 주가 되는 곳이라면 상황이 다를 수 있다)</p>

<p>한편 <strong>커리어의 방향성이 불분명하다</strong>는 것은 여전히 고민 지점이다. 예를 들어 데이터 직군의 채용 공고를 아무거나 눌러 읽어본다. JD에 나열된 기술 역량을 살펴보면 <em>애매하다</em>. 채용공고만 봐도 나의 경험과 역량이 여러 포지션에 걸쳐져 있다는 것을 알 수 있다. 심지어는 특정 자격 요건에 해당 되더라도 “내가 이걸 해봤다고 말할 수 있나?” 라고 자문하게 된다. 해본 건 맞다. 그런데 그것을 전문적으로, 깊이 있게, 비즈니스 성과로 이어지도록 해냈는지는 확신을 갖기 어려운 것이다.</p>

<p>실제로 지난 면접에서 오간 대화를 통해 <strong>나의 전문성이 부족하다</strong>는 것을 깨달을 수 있었다. 최종적으로는 불합격한 포지션이었다.</p>

<dl>
  <dt>면접관</dt>
  <dd>A 모델의 학습 과정에 B 모델을 접목 시킨 이유가 무엇이었나요?</dd>
  <dt>나</dt>
  <dd>B 모델의 XX적 특성이 문제와 연결된다고 생각해서 적용했습니다.</dd>
  <dt>면접관</dt>
  <dd>실제로 그 접근 방식이 잘 워킹하는지 어떻게 검증하셨나요?</dd>
  <dt>나</dt>
  <dd>OOO 지표가 기존보다 빠르게 수렴하는 것을 확인할 수 있었습니다.</dd>
  <dt>면접관</dt>
  <dd>B 모델의 내부 요소가 A 모델에 어떤 영향을 미쳐서 성능이 향상되는지 <strong>검증</strong>해본 적 있나요?</dd>
  <dt>나</dt>
  <dd>(일단 적용하는 데만 공수를 겁나 들였고 전반적인 성능만 확인해서 할 말이 없음)</dd>
  <dt>면접관</dt>
  <dd>B 모델의 +++ 를 추출해서 시각화하는 방식은 생각해보셨나요?</dd>
  <dt>나</dt>
  <dd>그런 검증 방식은 떠올리지 못했습니다.</dd>
</dl>

<p class="center"><img src="https://github.com/user-attachments/assets/b1c0aff0-1bba-43a6-9ded-799580fe7559" alt="image" class="center-image" />
<em>창피하다…</em></p>

<p>그렇다. 나는 ‘일단 해본다’에서 그쳐온 것이다. 아니, 사실은 내가 정확히 <strong>무엇을, 어떻게, 왜</strong> 했는지조차 설명할 수준이 안 되었던 것이다. 일련의 깨달음을 끝으로 나는 <u>기본기와 전문성을 갖추는 것</u> 그리고 <u>내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것</u>에 집중하기로 결심한다.</p>

<h1 id="작업-정리">작업 정리</h1>

<p>정리한 방식은 이렇다.</p>
<ul>
  <li>업무 일지를 기반으로 구체적인 작업을 리스트로 나열한다</li>
  <li>각 항목을 추상적인 표현으로 바꾸고 큼직한 <u>키워드</u>로 분류한다</li>
  <li>각 항목의 의도를 설명한다</li>
  <li>어려웠거나 개선의 여지가 있는 지점을 짚는다</li>
</ul>

<p>예를 들어,</p>

<ul>
  <li><strong>ACTION</strong>
    <ul>
      <li>Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다</li>
    </ul>
  </li>
  <li><strong>WHAT</strong>
    <ul>
      <li>클라우드 기반의 데이터 웨어하우스의 구조를 이해하고 여러 소스로부터 데이터를 통합하는 SQL 쿼리를 작성했다 =&gt; <mark>Data Engineering</mark></li>
    </ul>
  </li>
  <li><strong>WHY</strong>
    <ul>
      <li>최신 데이터를 정확하고 효율적으로 통합함으로써 데이터 분석과 시각화의 기반을 마련하고자 했다</li>
    </ul>
  </li>
  <li><strong>HOW</strong>
    <ul>
      <li><strong>복잡한 SQL 쿼리</strong> : API로 fetch 한 JSON 배치가 통째로 한 셀에 들어가 매우 nested된 형식이었다. 더 효율적인 데이터 추출을 위해 최적화할 필요가 있다.</li>
      <li><strong>낯선 데이터베이스의 구조 파악</strong> : 구조화된 문서로 세부 사항을 기록하고, 필요한 경우 자체 데이터 사전(Data Dictionary)을 구축할 수 있다</li>
    </ul>
  </li>
</ul>

<p>실제로 수행한 업무는 <code class="language-plaintext highlighter-rouge">Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다</code> 이지만, 데이터 직무의 관점에서 무슨 일을 한 건지 객관화, 추상화할 수 있게 된다.</p>

<hr />

<p>정리 결과, 키워드는 크게 네 가지로 나눌 수 있었다. 각 키워드에 해당하는 WHAT 들을 아래 나열해본다.</p>

<style>
table {
  width: 100%;
  border-collapse: collapse;
}
th, td:first-child {
  background-color: transparent; /* Remove background for this row */
}
thead tr:first-child {
  background-color: #f2f2f2; /* Green color for header row */
}
tr:nth-child(2) {
  text-align: center;
  background-color: #f2f2f2; /* Remove background for the second row */
}
</style>

<table>
  <thead>
    <tr>
      <th><strong>협업 및 운영</strong></th>
      <th><strong>데이터 분석</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>- 데이터 분석을 위한 Ubuntu 개발 환경 구축 <br /> - CI/CD 도구와 협업 도구 통합 설정 <br /> - 데이터플랫폼 계정 및 라이센스 할당, 스펙 설정 <br /> - API 및 데이터 웨어하우스 활용 가이드 제공 <br /> - 외부 리소스 활용한 아이디어, 방향성 제시</td>
      <td>- NLP 모델 활용한 다국어 데이터 처리 리서치 <br /> - LLM 프롬프트와 호출 비용 분석 <br />- 통계 기반 가설 검증과 인사이트 도출 <br />- 비즈니스 목적에 맞춘 모델 평가 지표 설계</td>
    </tr>
    <tr>
      <td><strong>데이터 엔지니어링</strong></td>
      <td><strong>데이터 시각화</strong></td>
    </tr>
    <tr>
      <td>- 데이터 그레인 정의, API 활용 가능성 리서치 <br /> - 외부 API 기반의 데이터 수집 <br /> - 클라우드 기반 데이터 웨어하우스 연동 최적화 <br /> - 데이터베이스 메타 분석과 문서화 <br /> - SQL 쿼리 최적화 및 성능 모니터링, 검증 <br />- 데이터 정합성 문제 해결 및 관계 테이블 설계 <br /> - 대시보드용 요약 테이블 운영 <br />- 데이터 통합 플랫폼 활용한 파이프라인 구축</td>
      <td>- 데이터 기반 대시보드 설계 및 구현 <br /> - 대시보드 설계 단계의 시뮬레이션 및 피드백 수집 <br /> - BI 도구와 클라우드/정적 데이터 연동 <br /> - 인포그래픽 및 웹앱 설계, 제작</td>
    </tr>
  </tbody>
</table>

<p>지난 3개월 동안 진행한 내용 중 제일 비중이 컸던 키워드는 <strong>데이터 엔지니어링</strong>이었다. 글 서두에 합류 직후 현업에 바로 투입되었다고 언급했는데, 데이터 인프라를 셋업하기 위한 업무를 주로 진행했기 때문이다.</p>

<p>“당장 필요하니까 해본다”의 방식으로 일을 진행해왔는데, 이렇게 정리함으로써 내가 무엇을 하고 있는지 보다 명확하게 파악할 수 있었다. 특히 구체적인 업무 내용을 데이터 분야의 용어로 추상화할 수 있다는 점이 만족스럽다. 머릿속에서 명쾌하게 설명할 수 있게 되었다고 느낀 요소들을 몇 가지 나열해보면 이렇다.</p>

<p><strong>데이터(통합)플랫폼</strong><br />
데이터를 통합, 활용하기 위한 각종 시스템을 ‘데이터 통합 플랫폼’이라는 용어로 표현할 수 있었다. Snowflake, Tableau 등이 여기에 해당된다.</p>

<p><strong>데이터웨어하우스(DHW)</strong><br />
데이터베이스 이론에서 항상 보던 이 용어가 바로 여기에 쓰인다는 것을 알았다. ‘대용량 데이터를 중앙 집중식으로 관리하는 저장소’ 라는 정의로는 크게 와닿지 않았는데, 실제 업무를 해온 환경을 돌아보면 데이터 레이크, 웨어하우스, 데이터 마트 등으로 모두 설명할 수 있었다.</p>

<p><strong>데이터 그레인 (Granularity)</strong><br />
데이터를 적재, 분석하는 세부 수준을 일컫는 말이다. ‘데이터를 어떤 기준과 단위로 다뤄야 하지?’ 라는 고민이 곧 데이터 그레인에 대한 정의였음을 알았다.</p>

<p><strong>데이터베이스 메타 분석</strong><br />
쿼리를 작성하기 위해서는 데이터베이스의 구조부터 전반적으로 파악해야 했다. 이러한 일련의 작업은 메타 분석이라는 이름으로 정리할  수 있었다.</p>

<p><strong>데이터 정합성</strong><br />
샘플이 중복되거나, 일관되지 않거나, 누락되기도 했다. 또 맵핑하는 key에 따라 결과가 부정확하기도 했다. 데이터를 정확하게 추출한다는 것은 데이터의 정합성을 체크했음을 전제로 한다.</p>

<p><strong>요약 테이블</strong><br />
여러 소스로부터 데이터를 수집하고 가공, 집계한 결과를 하나의 테이블에 밀어 넣었다. 단순하게 ‘대시보드용 테이블’이라고 부르던 것을 요약 테이블이라는 말로 설명할 수 있게 되었다.</p>

<p>그 외에도 API가 무엇인지 실질적으로 이해했고, 데이터베이스의 기본 요소나 성능 최적화에 대해서도 고려할 수 있게 되었다. 면접에서 “API 가 무엇인가요?” 라고 물어보았을 때,  “Application Programming Interface의 줄임말입니다” 라고 외운 대로 읊는 수준에서 한 걸음 더 발전한 느낌이랄까.</p>

<h1 id="나가며">나가며</h1>

<p>마지막으로 나의 결심을 다시 한번 상기해보겠다.</p>

<ol>
  <li>기본기와 전문성을 갖추는 것</li>
  <li>내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것</li>
</ol>

<p>사실 1번과 2번은 아주 밀접하게 연결되어 있었다. 기본적인 지식이 있어야 내가 무슨 일을 하는지 이해할 수 있다.</p>

<p>지난 3개월은 각종 불안과 불확신으로 가득했다. 특히 실력을 키워야 한다는 강박관념이 제일 컸다. 때로는 퇴근하면서 “오늘 엄청나게 바빴지만, 실제적으로 한 일은 없는 것 같다” 라는 불안감에 떨기도 했다. 하지만 이번 회고를 통해 <strong>내가 해본 적 없는 영역의 기본기를 쌓는 과정</strong>이었음을 배웠다. 어떻게 보면 퍼즐이 맞춰지는 과정과도 같았다. ‘그래서 팀원이 그때 그렇게 했구나’ 혹은 ‘그래서 SQLD 시험에 그런 내용이 포함되어 있었구나’ 라고 깨달은 것이다.</p>

<p>어쩌면 이것은 비전공자의 숙명일지도 모른다. <em>이 모든 걸 전공 수업에서 진작에 배웠다면 좀 달랐을까?</em> 하는 상상이 스쳐 지나갔지만, 이제 그런 걱정은 소용이 없다. 앞으로 무엇을 할지가 더 중요하니까. ML엔지니어답게 베이즈 업데이트해갈 뿐이다.</p>

<p>(난데없지만 나의 성장 과정이 베이즈 확률 모델처럼 작동한다고 느껴졌다. 초보적인 이해라는 사전 확률에서 시작하여 다양한 경험과 시행착오를 통해 데이터를 쌓고 사후 확률로서 업데이트된 실력으로 나아가는 것이다 … 이런 비유가 자꾸 떠오르는 것은 인문학도의 숙명이라고 하자.)</p>

<p>여전히 내가 무엇을 하고 싶은지 딱 잘라 말하기 어렵고 나의 직무에 대해서 자신 있게 설명하지 못한다. 그럼에도 불구하고 다행인 것은 <strong>아직도 하고 싶은 게 너무나도 많다</strong>는 것이다! ML엔지니어가 아니면 안 된다는 고집과 스페셜리스트가 되는 것에 대한 로망은 잠시 내려놓고, 초심으로 돌아가려 한다. “앞으로 무엇이 되어야 한다” 라는 강박에서 벗어나기 위함이다. “지금 당장 할 수 있는 것”을 수행하고 그 경험을 잘 정리하는 것이 어제의 나보다 나아지는 길일 테다.</p>

<p>그럼, 내일도 힘 내보자.</p>]]></content><author><name></name></author><category term="회고" /><summary type="html"><![CDATA[들어가며 2024년 9월 지금의 조직으로 이동하여 3개월의 수습 기간 종료를 앞두고 있다. 합류와 동시에 바로 현업에 투입되었기 때문에 what/why/how를 정리하지 못한 채 정신없이 시간을 보냈다. 이번 수습 회고에서는 지금까지 해온 구체적인 ACTION을 직무 관점에서 ‘무엇을 했는지’로 추상화하고, ‘왜 그렇게 했는지’ 의도를 부여하려 한다. 그리고 과정 중에서 어려움을 느꼈거나 개선의 여지가 있는 지점을 파악할 것이다. 물론 프로젝트의 내용은 밝히기 어려우니 기술 스택을 중점으로 다룰 예정이다. 일부 구체적인 사례가 필요한 경우에는 간단한 예시로 대체하겠다. 직무에 대해서 지금 회사에서 나의 직무는 분석가다. 여기서 분석가는 UX분석가, 데이터분석가, AI엔지니어 등을 포괄적으로 지칭하는 말이다. 그 중에서 나는 AI엔지니어라는 포지션로 입사했지만 대체로 데이터 과학자, 데이터 분석가, ML엔지니어를 오가는 다양한 업무를 접했다. 이전 회사에서는 하나의 프로젝트에 소속된 상태였다. 따라서 해당 서비스의 데이터 안에서 여러 방면으로 경험할 수 있었다. 당연하게도 모든 일의 목적은 근본적으로 ‘서비스를 성공시키는 것’이기 때문에 업무마다 문제와 목표가 달라지곤 했다. 간단하게는 지표의 현황을 파악하는 것, 위험을 최소화하기 위해 pain point를 탐색하는 것, 서비스의 피처가 의도대로 작동하는지 확인하는 것, ML 기반의 새로운 컨텐츠를 리서치하는 것, 내부 개발진을 대상으로 데이터 기반의 의사결정을 도모하는 것 등등. 이렇게 분석가로서 다양한 영역의 작업을 경험한다는 것은 뚜렷한 장단점을 지닌다. 장점 다양한 스킬셋을 확보할 수 있었다 비즈니스와 기술적 액션의 연결고리를 이해하게 되었다 협업과 커뮤니케이션 역량을 강화했다 단점 나의 역할과 커리어의 방향성 불분명했다 특정 영역의 전문성을 쌓기 어려웠다 특히 비즈니스와 기술적 액션을 연결 짓는 역량은 나에게 대단한 발전이었다. 어쨌든 회사는 돈을 벌어야 한다. 기술적으로 깊이를 더하거나 새로운 기술을 도입, 고도화하더라도 그것이 비즈니스 임팩트를 창출하거나 의사결정에 실질적으로 기여하지 못한다면 “그래서 이걸 해서 뭐?” 라는 허무한 질문으로 끝나버릴 수 있는 것이다. 조직과 나의 성과로 연결되는 일을 해야 한다는 중요한 깨달음을 얻었다. (물론 리서치 중심의 조직이거나 학술적 목적이 주가 되는 곳이라면 상황이 다를 수 있다) 한편 커리어의 방향성이 불분명하다는 것은 여전히 고민 지점이다. 예를 들어 데이터 직군의 채용 공고를 아무거나 눌러 읽어본다. JD에 나열된 기술 역량을 살펴보면 애매하다. 채용공고만 봐도 나의 경험과 역량이 여러 포지션에 걸쳐져 있다는 것을 알 수 있다. 심지어는 특정 자격 요건에 해당 되더라도 “내가 이걸 해봤다고 말할 수 있나?” 라고 자문하게 된다. 해본 건 맞다. 그런데 그것을 전문적으로, 깊이 있게, 비즈니스 성과로 이어지도록 해냈는지는 확신을 갖기 어려운 것이다. 실제로 지난 면접에서 오간 대화를 통해 나의 전문성이 부족하다는 것을 깨달을 수 있었다. 최종적으로는 불합격한 포지션이었다. 면접관 A 모델의 학습 과정에 B 모델을 접목 시킨 이유가 무엇이었나요? 나 B 모델의 XX적 특성이 문제와 연결된다고 생각해서 적용했습니다. 면접관 실제로 그 접근 방식이 잘 워킹하는지 어떻게 검증하셨나요? 나 OOO 지표가 기존보다 빠르게 수렴하는 것을 확인할 수 있었습니다. 면접관 B 모델의 내부 요소가 A 모델에 어떤 영향을 미쳐서 성능이 향상되는지 검증해본 적 있나요? 나 (일단 적용하는 데만 공수를 겁나 들였고 전반적인 성능만 확인해서 할 말이 없음) 면접관 B 모델의 +++ 를 추출해서 시각화하는 방식은 생각해보셨나요? 나 그런 검증 방식은 떠올리지 못했습니다. 창피하다… 그렇다. 나는 ‘일단 해본다’에서 그쳐온 것이다. 아니, 사실은 내가 정확히 무엇을, 어떻게, 왜 했는지조차 설명할 수준이 안 되었던 것이다. 일련의 깨달음을 끝으로 나는 기본기와 전문성을 갖추는 것 그리고 내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것에 집중하기로 결심한다. 작업 정리 정리한 방식은 이렇다. 업무 일지를 기반으로 구체적인 작업을 리스트로 나열한다 각 항목을 추상적인 표현으로 바꾸고 큼직한 키워드로 분류한다 각 항목의 의도를 설명한다 어려웠거나 개선의 여지가 있는 지점을 짚는다 예를 들어, ACTION Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다 WHAT 클라우드 기반의 데이터 웨어하우스의 구조를 이해하고 여러 소스로부터 데이터를 통합하는 SQL 쿼리를 작성했다 =&gt; Data Engineering WHY 최신 데이터를 정확하고 효율적으로 통합함으로써 데이터 분석과 시각화의 기반을 마련하고자 했다 HOW 복잡한 SQL 쿼리 : API로 fetch 한 JSON 배치가 통째로 한 셀에 들어가 매우 nested된 형식이었다. 더 효율적인 데이터 추출을 위해 최적화할 필요가 있다. 낯선 데이터베이스의 구조 파악 : 구조화된 문서로 세부 사항을 기록하고, 필요한 경우 자체 데이터 사전(Data Dictionary)을 구축할 수 있다 실제로 수행한 업무는 Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다 이지만, 데이터 직무의 관점에서 무슨 일을 한 건지 객관화, 추상화할 수 있게 된다. 정리 결과, 키워드는 크게 네 가지로 나눌 수 있었다. 각 키워드에 해당하는 WHAT 들을 아래 나열해본다. 협업 및 운영 데이터 분석 - 데이터 분석을 위한 Ubuntu 개발 환경 구축 - CI/CD 도구와 협업 도구 통합 설정 - 데이터플랫폼 계정 및 라이센스 할당, 스펙 설정 - API 및 데이터 웨어하우스 활용 가이드 제공 - 외부 리소스 활용한 아이디어, 방향성 제시 - NLP 모델 활용한 다국어 데이터 처리 리서치 - LLM 프롬프트와 호출 비용 분석 - 통계 기반 가설 검증과 인사이트 도출 - 비즈니스 목적에 맞춘 모델 평가 지표 설계 데이터 엔지니어링 데이터 시각화 - 데이터 그레인 정의, API 활용 가능성 리서치 - 외부 API 기반의 데이터 수집 - 클라우드 기반 데이터 웨어하우스 연동 최적화 - 데이터베이스 메타 분석과 문서화 - SQL 쿼리 최적화 및 성능 모니터링, 검증 - 데이터 정합성 문제 해결 및 관계 테이블 설계 - 대시보드용 요약 테이블 운영 - 데이터 통합 플랫폼 활용한 파이프라인 구축 - 데이터 기반 대시보드 설계 및 구현 - 대시보드 설계 단계의 시뮬레이션 및 피드백 수집 - BI 도구와 클라우드/정적 데이터 연동 - 인포그래픽 및 웹앱 설계, 제작 지난 3개월 동안 진행한 내용 중 제일 비중이 컸던 키워드는 데이터 엔지니어링이었다. 글 서두에 합류 직후 현업에 바로 투입되었다고 언급했는데, 데이터 인프라를 셋업하기 위한 업무를 주로 진행했기 때문이다. “당장 필요하니까 해본다”의 방식으로 일을 진행해왔는데, 이렇게 정리함으로써 내가 무엇을 하고 있는지 보다 명확하게 파악할 수 있었다. 특히 구체적인 업무 내용을 데이터 분야의 용어로 추상화할 수 있다는 점이 만족스럽다. 머릿속에서 명쾌하게 설명할 수 있게 되었다고 느낀 요소들을 몇 가지 나열해보면 이렇다. 데이터(통합)플랫폼 데이터를 통합, 활용하기 위한 각종 시스템을 ‘데이터 통합 플랫폼’이라는 용어로 표현할 수 있었다. Snowflake, Tableau 등이 여기에 해당된다. 데이터웨어하우스(DHW) 데이터베이스 이론에서 항상 보던 이 용어가 바로 여기에 쓰인다는 것을 알았다. ‘대용량 데이터를 중앙 집중식으로 관리하는 저장소’ 라는 정의로는 크게 와닿지 않았는데, 실제 업무를 해온 환경을 돌아보면 데이터 레이크, 웨어하우스, 데이터 마트 등으로 모두 설명할 수 있었다. 데이터 그레인 (Granularity) 데이터를 적재, 분석하는 세부 수준을 일컫는 말이다. ‘데이터를 어떤 기준과 단위로 다뤄야 하지?’ 라는 고민이 곧 데이터 그레인에 대한 정의였음을 알았다. 데이터베이스 메타 분석 쿼리를 작성하기 위해서는 데이터베이스의 구조부터 전반적으로 파악해야 했다. 이러한 일련의 작업은 메타 분석이라는 이름으로 정리할 수 있었다. 데이터 정합성 샘플이 중복되거나, 일관되지 않거나, 누락되기도 했다. 또 맵핑하는 key에 따라 결과가 부정확하기도 했다. 데이터를 정확하게 추출한다는 것은 데이터의 정합성을 체크했음을 전제로 한다. 요약 테이블 여러 소스로부터 데이터를 수집하고 가공, 집계한 결과를 하나의 테이블에 밀어 넣었다. 단순하게 ‘대시보드용 테이블’이라고 부르던 것을 요약 테이블이라는 말로 설명할 수 있게 되었다. 그 외에도 API가 무엇인지 실질적으로 이해했고, 데이터베이스의 기본 요소나 성능 최적화에 대해서도 고려할 수 있게 되었다. 면접에서 “API 가 무엇인가요?” 라고 물어보았을 때, “Application Programming Interface의 줄임말입니다” 라고 외운 대로 읊는 수준에서 한 걸음 더 발전한 느낌이랄까. 나가며 마지막으로 나의 결심을 다시 한번 상기해보겠다. 기본기와 전문성을 갖추는 것 내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것 사실 1번과 2번은 아주 밀접하게 연결되어 있었다. 기본적인 지식이 있어야 내가 무슨 일을 하는지 이해할 수 있다. 지난 3개월은 각종 불안과 불확신으로 가득했다. 특히 실력을 키워야 한다는 강박관념이 제일 컸다. 때로는 퇴근하면서 “오늘 엄청나게 바빴지만, 실제적으로 한 일은 없는 것 같다” 라는 불안감에 떨기도 했다. 하지만 이번 회고를 통해 내가 해본 적 없는 영역의 기본기를 쌓는 과정이었음을 배웠다. 어떻게 보면 퍼즐이 맞춰지는 과정과도 같았다. ‘그래서 팀원이 그때 그렇게 했구나’ 혹은 ‘그래서 SQLD 시험에 그런 내용이 포함되어 있었구나’ 라고 깨달은 것이다. 어쩌면 이것은 비전공자의 숙명일지도 모른다. 이 모든 걸 전공 수업에서 진작에 배웠다면 좀 달랐을까? 하는 상상이 스쳐 지나갔지만, 이제 그런 걱정은 소용이 없다. 앞으로 무엇을 할지가 더 중요하니까. ML엔지니어답게 베이즈 업데이트해갈 뿐이다. (난데없지만 나의 성장 과정이 베이즈 확률 모델처럼 작동한다고 느껴졌다. 초보적인 이해라는 사전 확률에서 시작하여 다양한 경험과 시행착오를 통해 데이터를 쌓고 사후 확률로서 업데이트된 실력으로 나아가는 것이다 … 이런 비유가 자꾸 떠오르는 것은 인문학도의 숙명이라고 하자.) 여전히 내가 무엇을 하고 싶은지 딱 잘라 말하기 어렵고 나의 직무에 대해서 자신 있게 설명하지 못한다. 그럼에도 불구하고 다행인 것은 아직도 하고 싶은 게 너무나도 많다는 것이다! ML엔지니어가 아니면 안 된다는 고집과 스페셜리스트가 되는 것에 대한 로망은 잠시 내려놓고, 초심으로 돌아가려 한다. “앞으로 무엇이 되어야 한다” 라는 강박에서 벗어나기 위함이다. “지금 당장 할 수 있는 것”을 수행하고 그 경험을 잘 정리하는 것이 어제의 나보다 나아지는 길일 테다. 그럼, 내일도 힘 내보자.]]></summary></entry><entry><title type="html">결정트리 모델(Decision Tree)이 나의 문제를 해결해줄 수 있을까?</title><link href="http://woocosmos.github.io/decision-tree/" rel="alternate" type="text/html" title="결정트리 모델(Decision Tree)이 나의 문제를 해결해줄 수 있을까?" /><published>2024-10-23T00:00:00+00:00</published><updated>2024-10-23T00:00:00+00:00</updated><id>http://woocosmos.github.io/decision-tree</id><content type="html" xml:base="http://woocosmos.github.io/decision-tree/"><![CDATA[<h1 id="들어가며">들어가며</h1>

<p>아래와 같은 설문조사가 있다. 응답자들은 0 ~ 10점 선지 중 하나를 선택한다.</p>

<p><img src="https://github.com/user-attachments/assets/c7d0a9d9-b6cb-4888-93ec-d53b07c7a496" alt="image" /></p>

<p><br />
이러한 응답 데이터를 활용해서 특정 값을 예측하려 한다. 어떤 모델을 쓰면 좋을까? 이 문제 상황에서 가장 먼저 떠올린 것은 <strong>결정트리 모델</strong>이었다. 최소 0부터 최대 10으로 스케일이 한정된 정수 데이터가 주어졌으며, 결정트리 모델은 조건 (예를 들면, $x &gt; 4$ ?)에 따라 샘플을 나누며 가지를 뻗어나가기 때문이다. 문제를 해결하는 데 결정트리가 적절한 모델이라는 <em>직관적인</em> 느낌을 받았다.</p>

<p>그러나 내가 설명할 수 있는 최선은 여기까지였다. “내가 모델의 개념과 원리를 근본적으로 이해하고 있나?” 반성하게 되었고, 이 글을 쓰게 된 계기가 되었다.</p>

<blockquote>
  <p>제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가?</p>
</blockquote>

<p>즉, 이 질문에 답변하기 위해 해당 모델을 공부한 글이다.</p>

<h1 id="개념">개념</h1>

<p><strong>결정트리 Decision Tree</strong>, 의사결정 나무라고도 부른다.</p>

<p>데이터를 기준에 따라 반복 분할함으로써 계층적인 구조로 하위 집합을 형성하는 방법론</p>

<h2 id="역사로-이해하기">역사로 이해하기</h2>

<p>결정트리 모델의 시초는 1960년대 사회과학에서 찾아볼 수 있다. 이후 1980년대 데이터 과학 분야의 발전과 함께 결정트리 방법론이 소개되고 다양한 모델이 개발, 활용되기 시작했다.</p>

<p>우선 1963년에 발간된 사회과학서 <a href="https://www.jstor.org/stable/2283276">Problems in the Analysis of Survey Data, and a Proposal</a>에 초기 개념이 소개되었다. 고차원의 다중공선성을 띠는 설문조사 데이터를 다루기 위한 방법론으로, 오차제곱합(SSE)를 최소화하도록 하위 그룹으로 분할한다.</p>

<p>사회과학 분야에서 다룰 법한 간단한 예제를 상상해봤다. 응답자의 나이, 성별, 연봉 수준을 수집했으며 이에 따른 직업 만족도를 비교하려 한다. 그런데 나이가 많을수록 연봉 수준이 높아지기도 하고, 분포 상 응답자가 여자일수록 나이대가 낮아진다. 이러한 변수 간 상호작용을 고려하면서 종속변수(직업 만족도)의 차이를 설명하기 위해 응답자를 <mark>그룹</mark>으로 나눠볼 수 있다. 30대 미만/이상으로 나눠도 좋고, 성별에 따라 나눠도 좋다. 중요한 건 나눠진 <strong>그룹끼리 직업 만족도를 비교했을 때 차이가 커지도록</strong> 하는 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/ae6dc78a-b9d4-488a-9045-762f49075f6d" alt="image" />
그룹끼리 차이가 커지도록 그룹을 나누는 이유는, 그룹 안의 <strong>동질성이 높다</strong>는 것과 같은 의미이기 때문이다. 한 그룹의 평균을 예측값으로 삼는다고 치자. 그룹의 동질성이 높을수록 그룹 내 샘플들은 평균에 가까이 몰려 있을 테니 <u>실제값과 예측값 간의 오차</u>가 전반적으로 줄어든다.</p>

<p>이렇듯 직업 만족도가 가장 크게 차이나는 두 그룹으로 나눠 <em>첫번째</em> 분할을 마쳤다. 그 다음에 오차가 더 큰 그룹을 선택한 다음 그 안에서 또 분할한다. 마찬가지로 그룹 간 차이가 크게 발생하는, 다시 말해 오차를 최소화하는 분할 기준을 결정한다. 분할을 반복한다.</p>

<p><img src="https://github.com/user-attachments/assets/8f40122d-dd94-4ca5-b1ce-b09108ae2e31" alt="image" />
<em>Problems in the Analysis of Survey Data, and a Proposal(1963), 17페이지. 오늘날 결정트리 모델을 시각화한 모습과 같다.</em></p>

<p>사회과학 분야에서 분할의 결과는 이렇게 활용할 수 있다. ‘30세 미만 남성 노동직 그룹과 여성 고졸 그룹의 직업 만족도가 75점 수준으로 비슷하다’ - 한편 머신러닝 분야라면? 입력 데이터에 대해 예측값을 출력하는 모델을 생성하는 데 활용할 수 있겠다! 30세 미만 남성 노동직이 입력으로 들어오면 75점 가량으로 예측하는 것이다.</p>

<p>이어 1984년 <a href="https://books.google.co.kr/books/about/Classification_and_Regression_Trees.html?id=JwQx-WOmSyQC&amp;redir_esc=y">Classification and Regression Trees</a>에서 결정트리 방법론을 기반으로 한 알고리즘 CART가 발표됐다. Classification And Regression Tree의 줄임말이다. 이어 CART의 업그레이드 버전인 ID3(Iterative Dichotomiser 3), C4.5, C5.0 등이 발표되면서 결정트리 모델이 더욱 발전해나갔다. 오늘날 많이 사용하는 Random Forest, XGBoost도 결정트리 방법론을 기반으로 개발된 알고리즘들이다.</p>

<h1 id="분할의-기준">분할의 기준</h1>

<p>CART, ID3, C4.5, C5.0 알고리즘은 모두 결정트리 방법론을 기반으로 한다. 하지만 분할 기준을 무엇으로 설정하는지에 따라 다른 알고리즘으로 발전한 결과다. 앞서 언급한 예제에서는 간단하게 그룹별 직업 만족도의 평균값 차이를 기준으로 분할했지만, 실제 알고리즘에서는 더 효율적이거나 정교한 지표를 분할의 기준으로 삼는다.</p>

<p>분할 기준의 본질은 <strong>불순도(impurity)</strong>를 낮추는 것이다. 앞서 그룹 내 동질성을 높이는 것이 중요하다고 언급했다. 이는 <strong>불순도를 낮춘다</strong>는 말과 의미가 동일하다.</p>

<p><img src="https://github.com/user-attachments/assets/fbdefbc1-ead0-43b6-9e94-5c5de12ab235" alt="image" /></p>

<p><em>다른 데이터가 많이 섞여 있을수록 동질성이 떨어지며 이는 곧 불순도가 높은 상태다</em></p>

<p>분할의 결과로 얼마나 동질성이 높아지거나 낮아졌는지, 불순도를 수치화하는 방식은 크게 두 가지. 지니 계수와 엔트로피(정보 이득)다.
소개한 알고리즘 중 CART는 지니 계수를 사용하며, ID3, C4.5, C5.0은 엔트로피 및 정보 이득을 사용한다.</p>

<h2 id="지니-계수gini-coefficient">지니 계수(Gini coefficient)</h2>

<p>지니 계수가 높을수록 불순도가 높다고 판단한다.</p>

\[\text{Gini} = \sum_{j=1}^{J} p_{j}(1-p_{j}) = 1 - \sum_{j=1}^{J} p_{j}^{2}\]

<dl>
  <dt>$J$</dt>
  <dd>각 클래스</dd>
  <dt>$p_{j}$</dt>
  <dd>샘플이 클래스 $j$에 속할 확률</dd>
  <dt>$p_{j}(1-p_{j})$</dt>
  <dd>같은 클래스의 샘플을 뽑을 확률과 이어 다른 클래스의 샘플을 뽑을 확률을 곱하여 한 노드 안이 얼마나 섞여 있는지 나타내준다</dd>
</dl>

<p>지니 계수는 경제학에서 소득이 얼마나 불평등하게 분포되었는지 나타내는 데 쓴다. 결정트리 모델의 맥락에서는 분할된 노드에 얼마나 다른 클래스 샘플이 섞여 있는지 표현해준다. <br />
$p_{j}^{2}$은 그 클래스의 샘플이 두 번 연속 추출될 확률이기 때문에 값이 높을수록 동질성이 높다는 의미다. 지니 계수는 이를 전체에서 뺌으로써 불순도를 계산한 결과다.</p>

<p>위에서 첨부한 이미지를 통해 분할 결과를 지니 계수로 평가해보겠다.</p>

<p><img src="https://github.com/user-attachments/assets/ddaea2b9-6167-4293-ad45-550316e7b1e0" alt="image" /></p>

<p>각 클래스에 대해 $p(1-p)$를 구한 후 합친다.</p>

<p><strong>좌측 노드</strong></p>

<ul>
  <li>노랑 클래스 : 4개 중 2개이므로, $p_{\text{노랑}} = 0.5$. 즉, $0.5 * (1 - 0.5)$.</li>
  <li>초록 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$.</li>
  <li>검정 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$.</li>
</ul>

<p>$\text{Gini}_{\text{좌측}} = 0.25 + 0.1875 + 0.1875 = 0.625$</p>

<p><strong>우측 노드</strong></p>

<ul>
  <li>노랑 클래스 : 3개 중 1개이므로, $p_{\text{노랑}} \approx 0.333$. 즉, $0.333 * (1 - 0.3335)$.</li>
  <li>초록 클래스 : 3개 중 2개이므로, $p_{\text{초록}} \approx 0.667$. 즉, $0.667 * (1 - 0.667)$.</li>
</ul>

<p>$\text{Gini}_{\text{좌측}} = 0.222 + 0.111 = 0.445$</p>

<p>그 다음 분할된 개수를 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다.</p>

\[\text{Gini}_{\text{예시1}} = \frac{4}{7} \times 0.625 + \frac{3}{7} \times 0.445 \approx 0.548\]

<p><br /></p>

<p><img src="https://github.com/user-attachments/assets/2915e5fb-c00a-43ca-85ef-838f220f5032" alt="image" /></p>

<p>해당 분할 결과에 대해서도 동일하게 구한다.</p>

\[\text{Gini}_{\text{예시2}} = \frac{3}{7} \times 0 + \frac{4}{7} \times 0.375 = 0.214\]

<p><em>좌측 노드에서 다른 클래스가 추출될 확률($1-p$)는 $0$이므로 계산 결과도 $0$이 된다.</em></p>

<p><img src="https://github.com/user-attachments/assets/39f7029e-ff17-48d9-a4cf-2520dc142d50" alt="image" /></p>

<p>분할 전 지니 계수가 $0.612$ 라는 점을 고려하면, 두 분할 방식 모두 지니 계수가 줄어들어 불순도가 낮아진 상태이다. 둘 중에서는 <em>이렇게!</em> 의 지니 계수 $0.214$ 가 <em>이렇게?</em> 의 $0.548$ 보다 더 낮으므로 더 적합한 분할이라고 판단할 수 있다.</p>

<h2 id="엔트로피entropy">엔트로피(Entropy)</h2>

<p>엔트로피는 <em>정보량의 기대값</em>을 의미한다.</p>

\[\text{Entropy} = -\sum_{j=1}^{J} p_{j} \log{(p_{j})}\]

<dl>
  <dt>$J$</dt>
  <dd>각 클래스</dd>
  <dt>$p_{j}$</dt>
  <dd>샘플이 클래스 $j$에 속할 확률</dd>
  <dt>$-\log{(p_{j})}$</dt>
  <dd>클래스 $j$에 대한 정보량</dd>
</dl>

<p>정보 이론에서는 <u>의외</u>인 사건이 발생할 때 <strong>정보량(Information Content)</strong>이 더 많다고 본다. 여기서 ‘의외인 사건’은 곧 사건의 확률이 낮다는 것을 의미한다. (11월은 강우 확률이 낮으니까 11월에 눈이 오는 것은 의외인 사건이며 정보량이 많은 것이기도 하다. 1월에 눈이 오는 사건에 비해서 말이다.)</p>

<p><img src="https://github.com/user-attachments/assets/acb1c007-51cd-46f1-b27d-f7bc0d18fd31" alt="image" /></p>

<p>이처럼 확률이 낮을수록 정보량이 많고 높을수록 정보량이 낮아지는 것은 확률에 로그를 취하고 음수화한 값으로 표현할 수 있다. 그리고 이 정보량에 확률을 곱함으로써 구한 <u>기댓값</u>을 엔트로피라고 부른다.</p>

\[-p_{j} \times \log{(p_{j})}\]

<blockquote>
  <p>확률이 낮다 =&gt; 정보량이 많다 =&gt; 엔트로피가 높다 &lt;=&gt; 사건을 예측하기 어렵다</p>
</blockquote>

<p>노드에 다양한 클래스가 혼재되어 있을수록 어떤 클래스가 추출될지 예측하기 어렵다. 따라서 불순도를 측정하는 방식으로 엔트로피를 쓸 수 있다.</p>

<h3 id="정보획득량-information-gain">정보획득량 (Information Gain)</h3>

<p>결정트리 알고리즘 ID3 에서는 ‘정보획득량’을 불순도 지표로 사용하는데, 이는 분할 전후의 엔트로피 차이를 계산한 값이다.</p>

\[IG(S, A) = H(S) - \sum_{t \in T} p(t) H(t) = H(S) - H(S|A)\]

<dl>
  <dt>$IG(S, A)$</dt>
  <dd>$A$ 속성을 기준으로 $S$를 분할했을 때의 정보 획득량</dd>
  <dt>$H(S)$</dt>
  <dd>$S$의 엔트로피</dd>
  <dt>$T$</dt>
  <dd>$S$를 분할함으로써 생성된 노드들</dd>
  <dt>$p(t)$</dt>
  <dd>$S$ 대비 노드 $t$의 비율(크기)</dd>
  <dt>$H(t)$</dt>
  <dd>노드 $t$의 엔트로피</dd>
  <dt>$H(S|A)$</dt>
  <dd>$A$ 속성을 기준으로 $S$를 분할하여 생성된 노드들의 $H(t)$를 가중 평균한 값</dd>
</dl>

<p>‘<em>이렇게!</em>’ 분할 방식을 정보 획득량에 따라 평가해보자. 나이 30살을 기준으로 샘플을 분할했다고 가정했다.</p>

<p><img src="https://github.com/user-attachments/assets/020adc3f-9cb1-4a3c-8d6f-e9fc7b754d58" alt="image" /></p>

<p>먼저 분할 전 엔트로피 $H(S)$를 구한다. 엔트로피 식 $-\sum_{j=1}^{J} p_{j} \log{(p_{j})}$ 을 적용하면 된다.</p>

<ul>
  <li>노랑 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$</li>
  <li>초록 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$</li>
  <li>검정 클래스 : 7개 중 1개이므로, $- \frac{1}{7} \log \frac{1}{7}$</li>
</ul>

<p>$H(S) \approx 0.523 + 0.523 + 0.402 = 1.448$</p>

<p>다음으로 분할 후 엔트로피 $H(S|A)$를 구한다. 이는 각 노드의 엔트로피를 가중 평균하여 계산한다.</p>

<p><strong>True 노드</strong></p>

<ul>
  <li>초록 클래스 : 3개 중 3개이므로, $- \frac{3}{3} \log \frac{3}{3} = 0$</li>
</ul>

<p>$H(\text{True}) = 0$</p>

<p><strong>False 노드</strong></p>

<ul>
  <li>노랑 클래스 : 4개 중 3개이므로, $- \frac{3}{4} \log \frac{3}{4} = 0$</li>
  <li>검정 클래스 : 4개 중 1개이므로, $- \frac{1}{4} \log \frac{1}{4} = 0$</li>
</ul>

<p>$H(\text{True}) \approx 0.311 + 0.5 = 0.811$</p>

<p>그 다음 분할된 비율을 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다.</p>

<p>$H(S|A) = \frac{3}{7} \cdot H(\text{True}) + \frac{4}{7} \cdot H(\text{False}) \approx 0.463$</p>

<p>최종적으로 분할 전에 비해 정보량을 비교한다.</p>

\[IG(S, A) = H(S) - H(S|A) \approx 1.448 - 0.463 = 0.985\]

<p><img src="https://github.com/user-attachments/assets/46c1934c-769d-4d09-b71f-b52ba8edb1bc" alt="image" /></p>

<p>분할 전후의 엔트로피를 비교한 결과 정보 이득은 약 $0.985$이다. 반면 <em>이렇게?</em> 분할 방식의 정보 이득을 계산하면 $0.198$로 비교적 정보 이득이 적은 것을 알 수 있다.</p>

<p>이처럼 불순도를 낮추는 방향으로 데이터를 분할하는 것을 반복함으로써 계층적인 트리 구조를 형성하는 것이 결정트리 방법론이다. 여기서 ‘불순도’를 어떤 지표로 평가할지, 언제까지 분할을 반복할지, 어떤 노드를 주로 참고할지 등 구체적인 활용 방식에 따라 다른 알고리즘이 될 수 있다.</p>

<h1 id="직관-설명하기">직관 설명하기</h1>

<blockquote>
  <p>제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가?</p>
</blockquote>

<p>지금까지 결정트리 방법론의 등장 맥락, 분할의 기준을 살펴보았다. 이제 처음의 질문으로 돌아가보자.</p>

<p><strong>“제한된 범위”</strong></p>

<p>결정트리 모델은 값이 좁은 범위로 제한된 데이터에 대해 유리할 수 있다. 결정트리가 <u>비모수적 모델(non-parametric models)</u>이기 때문이다.<br />
결정트리 모델은 주어진 데이터를 거듭된 조건에 따라 쪼개 나간다. 특정 분포를 가정하지 않고 <strong>주어진 데이터에 따라 비선형적인 구조를 형성</strong>한다는 의미다. 반면 선형회귀와 같은 모수적 모델은 <strong>모든 범위의 데이터에 대해서 유효한 분포(함수)</strong>가 있다고 가정하고 이에 맞춰 파라미터를 학습(fit)한다. 실제 데이터에 비해 함수 가정이 과도할 수 있다. 우리는 0 ~ 10 의 범위에서 벗어나는 입력은 전혀 고려하지 않고 있단 말이다.</p>

<p><strong>“정수”</strong></p>

<p>결정트리 모델은 특정 임계값을 기준으로 데이터를 분할하는데, 정수형 데이터는 이산적(discrete) 성격을 띠므로 <u>분할 자체가 직관적이고 간단해진다</u>. 예를 들어 ‘5번 질문에 대한 응답이 3점 이상’이라는 분할 조건을 세우는 건 간단하고 직관적이다. 하지만 데이터가 연속형이었으면 ‘A 속성이 0.3728 이상’과 같이 정밀한 임계값을 정해야 했을 것이다. 당연히 더 많은 경우의 수를 고려해야 하기 때문에 난이도가 높아진다.</p>

<p><strong>“응답 데이터”</strong></p>

<p>설문 참여자들은 비슷한 질문에 대해 비슷하게 응답하는 경향이 있을 것이다. 예를 들어 ‘인생이 행복합니까?’ 라는 질문에 그렇다고 응답할수록, ‘생활이 만족스럽습니까?’ 라는 질문에도 그렇다고 응답할 것이다. 이처럼 변수 간 상관관계가 존재하는 다중공선성의 문제에 결정트리 모델이 유리하다. 애초에 결정트리는 사회과학 연구에서 일종의 교차분석과 유사한 방법론으로 제시되지 않았는가?<br />
결정트리는 불순도가 (지니 계수든 엔트로피든) 가장 크게 감소하는 조건을 선택하여 분할을 실시하기 때문에 <u>가장 중요한 변수가 우선적으로 선택되는 효과</u>가 있다. 그 결과 비슷한 패턴의 변수들은 자연스럽게 제외되기 때문에 변수 간 상관관계는 결정트리 모델에 큰 해가 되지 않는다.</p>

<h1 id="나가며">나가며</h1>

<p>결정트리의 작동 맥락과 주요 지표를 살펴봄으로써 나의 직관을 설명할 수 있었다. 이 과정에서 ‘비모수형 모델’의 개념을 명확하게 이해할 수 있게 되었고, 머신러닝 분야에서 ‘엔트로피’가 가지는 의미를 다시 상기할 수 있었다. 이번 공부를 통해 나의 직관이 어느 정도 의미 있었다는 결론을 내렸으므로, 이제 실제 적용하는 일만 남았다.</p>

<p>분량이 너무 길어져서 가지치기나 정지규칙, 코드 등 더 깊은 내용은 다루지 못했지만 모델의 본질과 연결되는 직관을 이해했다는 점에서 만족스러운 공부였다. 이어서 결정트리 방법론을 기반으로 하는 다양한 머신러닝 모델에 대해서 하나씩 공부하는 시간을 가져보겠다.</p>]]></content><author><name></name></author><category term="머신러닝" /><summary type="html"><![CDATA[들어가며 아래와 같은 설문조사가 있다. 응답자들은 0 ~ 10점 선지 중 하나를 선택한다. 이러한 응답 데이터를 활용해서 특정 값을 예측하려 한다. 어떤 모델을 쓰면 좋을까? 이 문제 상황에서 가장 먼저 떠올린 것은 결정트리 모델이었다. 최소 0부터 최대 10으로 스케일이 한정된 정수 데이터가 주어졌으며, 결정트리 모델은 조건 (예를 들면, $x &gt; 4$ ?)에 따라 샘플을 나누며 가지를 뻗어나가기 때문이다. 문제를 해결하는 데 결정트리가 적절한 모델이라는 직관적인 느낌을 받았다. 그러나 내가 설명할 수 있는 최선은 여기까지였다. “내가 모델의 개념과 원리를 근본적으로 이해하고 있나?” 반성하게 되었고, 이 글을 쓰게 된 계기가 되었다. 제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가? 즉, 이 질문에 답변하기 위해 해당 모델을 공부한 글이다. 개념 결정트리 Decision Tree, 의사결정 나무라고도 부른다. 데이터를 기준에 따라 반복 분할함으로써 계층적인 구조로 하위 집합을 형성하는 방법론 역사로 이해하기 결정트리 모델의 시초는 1960년대 사회과학에서 찾아볼 수 있다. 이후 1980년대 데이터 과학 분야의 발전과 함께 결정트리 방법론이 소개되고 다양한 모델이 개발, 활용되기 시작했다. 우선 1963년에 발간된 사회과학서 Problems in the Analysis of Survey Data, and a Proposal에 초기 개념이 소개되었다. 고차원의 다중공선성을 띠는 설문조사 데이터를 다루기 위한 방법론으로, 오차제곱합(SSE)를 최소화하도록 하위 그룹으로 분할한다. 사회과학 분야에서 다룰 법한 간단한 예제를 상상해봤다. 응답자의 나이, 성별, 연봉 수준을 수집했으며 이에 따른 직업 만족도를 비교하려 한다. 그런데 나이가 많을수록 연봉 수준이 높아지기도 하고, 분포 상 응답자가 여자일수록 나이대가 낮아진다. 이러한 변수 간 상호작용을 고려하면서 종속변수(직업 만족도)의 차이를 설명하기 위해 응답자를 그룹으로 나눠볼 수 있다. 30대 미만/이상으로 나눠도 좋고, 성별에 따라 나눠도 좋다. 중요한 건 나눠진 그룹끼리 직업 만족도를 비교했을 때 차이가 커지도록 하는 것이다. 그룹끼리 차이가 커지도록 그룹을 나누는 이유는, 그룹 안의 동질성이 높다는 것과 같은 의미이기 때문이다. 한 그룹의 평균을 예측값으로 삼는다고 치자. 그룹의 동질성이 높을수록 그룹 내 샘플들은 평균에 가까이 몰려 있을 테니 실제값과 예측값 간의 오차가 전반적으로 줄어든다. 이렇듯 직업 만족도가 가장 크게 차이나는 두 그룹으로 나눠 첫번째 분할을 마쳤다. 그 다음에 오차가 더 큰 그룹을 선택한 다음 그 안에서 또 분할한다. 마찬가지로 그룹 간 차이가 크게 발생하는, 다시 말해 오차를 최소화하는 분할 기준을 결정한다. 분할을 반복한다. Problems in the Analysis of Survey Data, and a Proposal(1963), 17페이지. 오늘날 결정트리 모델을 시각화한 모습과 같다. 사회과학 분야에서 분할의 결과는 이렇게 활용할 수 있다. ‘30세 미만 남성 노동직 그룹과 여성 고졸 그룹의 직업 만족도가 75점 수준으로 비슷하다’ - 한편 머신러닝 분야라면? 입력 데이터에 대해 예측값을 출력하는 모델을 생성하는 데 활용할 수 있겠다! 30세 미만 남성 노동직이 입력으로 들어오면 75점 가량으로 예측하는 것이다. 이어 1984년 Classification and Regression Trees에서 결정트리 방법론을 기반으로 한 알고리즘 CART가 발표됐다. Classification And Regression Tree의 줄임말이다. 이어 CART의 업그레이드 버전인 ID3(Iterative Dichotomiser 3), C4.5, C5.0 등이 발표되면서 결정트리 모델이 더욱 발전해나갔다. 오늘날 많이 사용하는 Random Forest, XGBoost도 결정트리 방법론을 기반으로 개발된 알고리즘들이다. 분할의 기준 CART, ID3, C4.5, C5.0 알고리즘은 모두 결정트리 방법론을 기반으로 한다. 하지만 분할 기준을 무엇으로 설정하는지에 따라 다른 알고리즘으로 발전한 결과다. 앞서 언급한 예제에서는 간단하게 그룹별 직업 만족도의 평균값 차이를 기준으로 분할했지만, 실제 알고리즘에서는 더 효율적이거나 정교한 지표를 분할의 기준으로 삼는다. 분할 기준의 본질은 불순도(impurity)를 낮추는 것이다. 앞서 그룹 내 동질성을 높이는 것이 중요하다고 언급했다. 이는 불순도를 낮춘다는 말과 의미가 동일하다. 다른 데이터가 많이 섞여 있을수록 동질성이 떨어지며 이는 곧 불순도가 높은 상태다 분할의 결과로 얼마나 동질성이 높아지거나 낮아졌는지, 불순도를 수치화하는 방식은 크게 두 가지. 지니 계수와 엔트로피(정보 이득)다. 소개한 알고리즘 중 CART는 지니 계수를 사용하며, ID3, C4.5, C5.0은 엔트로피 및 정보 이득을 사용한다. 지니 계수(Gini coefficient) 지니 계수가 높을수록 불순도가 높다고 판단한다. \[\text{Gini} = \sum_{j=1}^{J} p_{j}(1-p_{j}) = 1 - \sum_{j=1}^{J} p_{j}^{2}\] $J$ 각 클래스 $p_{j}$ 샘플이 클래스 $j$에 속할 확률 $p_{j}(1-p_{j})$ 같은 클래스의 샘플을 뽑을 확률과 이어 다른 클래스의 샘플을 뽑을 확률을 곱하여 한 노드 안이 얼마나 섞여 있는지 나타내준다 지니 계수는 경제학에서 소득이 얼마나 불평등하게 분포되었는지 나타내는 데 쓴다. 결정트리 모델의 맥락에서는 분할된 노드에 얼마나 다른 클래스 샘플이 섞여 있는지 표현해준다. $p_{j}^{2}$은 그 클래스의 샘플이 두 번 연속 추출될 확률이기 때문에 값이 높을수록 동질성이 높다는 의미다. 지니 계수는 이를 전체에서 뺌으로써 불순도를 계산한 결과다. 위에서 첨부한 이미지를 통해 분할 결과를 지니 계수로 평가해보겠다. 각 클래스에 대해 $p(1-p)$를 구한 후 합친다. 좌측 노드 노랑 클래스 : 4개 중 2개이므로, $p_{\text{노랑}} = 0.5$. 즉, $0.5 * (1 - 0.5)$. 초록 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$. 검정 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$. $\text{Gini}_{\text{좌측}} = 0.25 + 0.1875 + 0.1875 = 0.625$ 우측 노드 노랑 클래스 : 3개 중 1개이므로, $p_{\text{노랑}} \approx 0.333$. 즉, $0.333 * (1 - 0.3335)$. 초록 클래스 : 3개 중 2개이므로, $p_{\text{초록}} \approx 0.667$. 즉, $0.667 * (1 - 0.667)$. $\text{Gini}_{\text{좌측}} = 0.222 + 0.111 = 0.445$ 그 다음 분할된 개수를 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다. \[\text{Gini}_{\text{예시1}} = \frac{4}{7} \times 0.625 + \frac{3}{7} \times 0.445 \approx 0.548\] 해당 분할 결과에 대해서도 동일하게 구한다. \[\text{Gini}_{\text{예시2}} = \frac{3}{7} \times 0 + \frac{4}{7} \times 0.375 = 0.214\] 좌측 노드에서 다른 클래스가 추출될 확률($1-p$)는 $0$이므로 계산 결과도 $0$이 된다. 분할 전 지니 계수가 $0.612$ 라는 점을 고려하면, 두 분할 방식 모두 지니 계수가 줄어들어 불순도가 낮아진 상태이다. 둘 중에서는 이렇게! 의 지니 계수 $0.214$ 가 이렇게? 의 $0.548$ 보다 더 낮으므로 더 적합한 분할이라고 판단할 수 있다. 엔트로피(Entropy) 엔트로피는 정보량의 기대값을 의미한다. \[\text{Entropy} = -\sum_{j=1}^{J} p_{j} \log{(p_{j})}\] $J$ 각 클래스 $p_{j}$ 샘플이 클래스 $j$에 속할 확률 $-\log{(p_{j})}$ 클래스 $j$에 대한 정보량 정보 이론에서는 의외인 사건이 발생할 때 정보량(Information Content)이 더 많다고 본다. 여기서 ‘의외인 사건’은 곧 사건의 확률이 낮다는 것을 의미한다. (11월은 강우 확률이 낮으니까 11월에 눈이 오는 것은 의외인 사건이며 정보량이 많은 것이기도 하다. 1월에 눈이 오는 사건에 비해서 말이다.) 이처럼 확률이 낮을수록 정보량이 많고 높을수록 정보량이 낮아지는 것은 확률에 로그를 취하고 음수화한 값으로 표현할 수 있다. 그리고 이 정보량에 확률을 곱함으로써 구한 기댓값을 엔트로피라고 부른다. \[-p_{j} \times \log{(p_{j})}\] 확률이 낮다 =&gt; 정보량이 많다 =&gt; 엔트로피가 높다 &lt;=&gt; 사건을 예측하기 어렵다 노드에 다양한 클래스가 혼재되어 있을수록 어떤 클래스가 추출될지 예측하기 어렵다. 따라서 불순도를 측정하는 방식으로 엔트로피를 쓸 수 있다. 정보획득량 (Information Gain) 결정트리 알고리즘 ID3 에서는 ‘정보획득량’을 불순도 지표로 사용하는데, 이는 분할 전후의 엔트로피 차이를 계산한 값이다. \[IG(S, A) = H(S) - \sum_{t \in T} p(t) H(t) = H(S) - H(S|A)\] $IG(S, A)$ $A$ 속성을 기준으로 $S$를 분할했을 때의 정보 획득량 $H(S)$ $S$의 엔트로피 $T$ $S$를 분할함으로써 생성된 노드들 $p(t)$ $S$ 대비 노드 $t$의 비율(크기) $H(t)$ 노드 $t$의 엔트로피 $H(S|A)$ $A$ 속성을 기준으로 $S$를 분할하여 생성된 노드들의 $H(t)$를 가중 평균한 값 ‘이렇게!’ 분할 방식을 정보 획득량에 따라 평가해보자. 나이 30살을 기준으로 샘플을 분할했다고 가정했다. 먼저 분할 전 엔트로피 $H(S)$를 구한다. 엔트로피 식 $-\sum_{j=1}^{J} p_{j} \log{(p_{j})}$ 을 적용하면 된다. 노랑 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$ 초록 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$ 검정 클래스 : 7개 중 1개이므로, $- \frac{1}{7} \log \frac{1}{7}$ $H(S) \approx 0.523 + 0.523 + 0.402 = 1.448$ 다음으로 분할 후 엔트로피 $H(S|A)$를 구한다. 이는 각 노드의 엔트로피를 가중 평균하여 계산한다. True 노드 초록 클래스 : 3개 중 3개이므로, $- \frac{3}{3} \log \frac{3}{3} = 0$ $H(\text{True}) = 0$ False 노드 노랑 클래스 : 4개 중 3개이므로, $- \frac{3}{4} \log \frac{3}{4} = 0$ 검정 클래스 : 4개 중 1개이므로, $- \frac{1}{4} \log \frac{1}{4} = 0$ $H(\text{True}) \approx 0.311 + 0.5 = 0.811$ 그 다음 분할된 비율을 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다. $H(S|A) = \frac{3}{7} \cdot H(\text{True}) + \frac{4}{7} \cdot H(\text{False}) \approx 0.463$ 최종적으로 분할 전에 비해 정보량을 비교한다. \[IG(S, A) = H(S) - H(S|A) \approx 1.448 - 0.463 = 0.985\] 분할 전후의 엔트로피를 비교한 결과 정보 이득은 약 $0.985$이다. 반면 이렇게? 분할 방식의 정보 이득을 계산하면 $0.198$로 비교적 정보 이득이 적은 것을 알 수 있다. 이처럼 불순도를 낮추는 방향으로 데이터를 분할하는 것을 반복함으로써 계층적인 트리 구조를 형성하는 것이 결정트리 방법론이다. 여기서 ‘불순도’를 어떤 지표로 평가할지, 언제까지 분할을 반복할지, 어떤 노드를 주로 참고할지 등 구체적인 활용 방식에 따라 다른 알고리즘이 될 수 있다. 직관 설명하기 제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가? 지금까지 결정트리 방법론의 등장 맥락, 분할의 기준을 살펴보았다. 이제 처음의 질문으로 돌아가보자. “제한된 범위” 결정트리 모델은 값이 좁은 범위로 제한된 데이터에 대해 유리할 수 있다. 결정트리가 비모수적 모델(non-parametric models)이기 때문이다. 결정트리 모델은 주어진 데이터를 거듭된 조건에 따라 쪼개 나간다. 특정 분포를 가정하지 않고 주어진 데이터에 따라 비선형적인 구조를 형성한다는 의미다. 반면 선형회귀와 같은 모수적 모델은 모든 범위의 데이터에 대해서 유효한 분포(함수)가 있다고 가정하고 이에 맞춰 파라미터를 학습(fit)한다. 실제 데이터에 비해 함수 가정이 과도할 수 있다. 우리는 0 ~ 10 의 범위에서 벗어나는 입력은 전혀 고려하지 않고 있단 말이다. “정수” 결정트리 모델은 특정 임계값을 기준으로 데이터를 분할하는데, 정수형 데이터는 이산적(discrete) 성격을 띠므로 분할 자체가 직관적이고 간단해진다. 예를 들어 ‘5번 질문에 대한 응답이 3점 이상’이라는 분할 조건을 세우는 건 간단하고 직관적이다. 하지만 데이터가 연속형이었으면 ‘A 속성이 0.3728 이상’과 같이 정밀한 임계값을 정해야 했을 것이다. 당연히 더 많은 경우의 수를 고려해야 하기 때문에 난이도가 높아진다. “응답 데이터” 설문 참여자들은 비슷한 질문에 대해 비슷하게 응답하는 경향이 있을 것이다. 예를 들어 ‘인생이 행복합니까?’ 라는 질문에 그렇다고 응답할수록, ‘생활이 만족스럽습니까?’ 라는 질문에도 그렇다고 응답할 것이다. 이처럼 변수 간 상관관계가 존재하는 다중공선성의 문제에 결정트리 모델이 유리하다. 애초에 결정트리는 사회과학 연구에서 일종의 교차분석과 유사한 방법론으로 제시되지 않았는가? 결정트리는 불순도가 (지니 계수든 엔트로피든) 가장 크게 감소하는 조건을 선택하여 분할을 실시하기 때문에 가장 중요한 변수가 우선적으로 선택되는 효과가 있다. 그 결과 비슷한 패턴의 변수들은 자연스럽게 제외되기 때문에 변수 간 상관관계는 결정트리 모델에 큰 해가 되지 않는다. 나가며 결정트리의 작동 맥락과 주요 지표를 살펴봄으로써 나의 직관을 설명할 수 있었다. 이 과정에서 ‘비모수형 모델’의 개념을 명확하게 이해할 수 있게 되었고, 머신러닝 분야에서 ‘엔트로피’가 가지는 의미를 다시 상기할 수 있었다. 이번 공부를 통해 나의 직관이 어느 정도 의미 있었다는 결론을 내렸으므로, 이제 실제 적용하는 일만 남았다. 분량이 너무 길어져서 가지치기나 정지규칙, 코드 등 더 깊은 내용은 다루지 못했지만 모델의 본질과 연결되는 직관을 이해했다는 점에서 만족스러운 공부였다. 이어서 결정트리 방법론을 기반으로 하는 다양한 머신러닝 모델에 대해서 하나씩 공부하는 시간을 가져보겠다.]]></summary></entry><entry><title type="html">📖 『JAX/Flax로 딥러닝 레벨업』(제이펍) 리뷰</title><link href="http://woocosmos.github.io/jax-lev-up-review/" rel="alternate" type="text/html" title="📖 『JAX/Flax로 딥러닝 레벨업』(제이펍) 리뷰" /><published>2024-10-13T00:00:00+00:00</published><updated>2024-10-13T00:00:00+00:00</updated><id>http://woocosmos.github.io/jax-lev-up-review</id><content type="html" xml:base="http://woocosmos.github.io/jax-lev-up-review/"><![CDATA[<p><img src="https://github.com/user-attachments/assets/76f397ea-6ed8-404c-99bc-e8c43ca4c04d" alt="IMG_4524" class="center-image" /></p>

<p><br />
IT 실용서 전문 출판사 제이펍으로부터 책 『<a href="https://product.kyobobook.co.kr/detail/S000214172972"><strong>JAX/Flax로 딥러닝 레벨업</strong></a>』를 무료로 제공 받았다.</p>

<h1 id="개요">개요</h1>

<dl>
  <dt>도서명</dt>
  <dd>JAX/Flax로 딥러닝 레벨업</dd>
  <dt>지은이</dt>
  <dd>이영빈 , 유현아 , 김한빈 , 조영빈 , 이태호 , 장진우 , 박정현 , 김형섭 , 이승현</dd>
  <dt>발행사</dt>
  <dd>제이펍</dd>
  <dt>초판 발행</dt>
  <dd>2024년 9월 23일</dd>
  <dt>정가</dt>
  <dd>24,000원</dd>
</dl>

<hr />

<p>베타리더 후기에 따르면 『JAX/Flax로 딥러닝 레벨업』은 무려 국내 최초 JAX 입문서라고 한다. 최근 성장하고 있는 JAX 생태계의 활성화에 기여하는 의미가 있겠다.</p>

<p>개인적으로 JAX는 ‘고성능 딥러닝 연산이 가능한 numpy’ 정도로 알고 있는 상태였고 직접 활용해본 적은 없었다. 이번 책 리뷰를 계기로 Numpy와의 차이점과 JAX/Flax의 주요 특징을 이해하고 실제 튜토리얼을 따라가는 경험을 쌓으려 한다.</p>

<p>책은 크게 JAX/Flax를 소개하는 부분과 JAX/Flax를 활용하여 딥러닝 모델을 구현하는 부분으로 이뤄져 있다. 파이썬 프로그래밍과 기본적인 머신러닝 개념은 책을 읽기 위한 선수 지식으로 요구된다.</p>

<h1 id="jax란">Jax란?</h1>

<blockquote>
  <p>한마디로 표현하면 자동 미분과 XLA를 결합해서 사용하는 고성능 머신러닝 프레임워크입니다 … JAX의 가장 큰 강점은 XLA를 적용해서 사용할 수 있다는 점입니다.</p>
</blockquote>

<p>PyTorch, Tensorflow 등 다른 딥러닝 프레임워크도 자동 미분을 지원하지만, JAX는 이에 더해 <strong>XLA(Accelerated Linear Algebra)</strong>이 가능하다는 것이 핵심이다. XLA는 GPU/TPU 위에서 numpy를 컴파일하고 실행하는 컴파일러다. JAX는 JIT(Just-In-Time) 컴파일을 통해 파이썬 코드를 XLA에 최적화된 기계어로 변환하기 때문에 <a href="https://woocosmos.github.io/pytorch-basic/#autograd-%EC%9E%90%EB%8F%99%EB%AF%B8%EB%B6%84">PyTorch의 동적 그래프</a>보다도 빠르고 효율적으로 연산할 수 있다는 것이다.</p>

<p>파이썬은 기본적으로 인터프리터 방식으로 실행되기 때문에 코드를 한 줄씩 읽고 해석하는 데 시간이 소요된다. 여기서 JIT 컴파일을 사용한다면 <strong>코드를 실행하는 시점</strong>에 성능과 연관되는 일부분을 미리 기계어로 컴파일하여 속도가 빨라진다고 이해했다.</p>

<h2 id="flax">Flax</h2>

<blockquote>
  <p>JAX + Flexibility를 합쳐져서 만들었으며 엔지니어들이 JAX를 조금 더 쉽게 사용할 수 있는 프레임워크이며, 다른 딥러닝 프레임워크들처럼 레이어(층) 개념을 지원합니다.</p>
</blockquote>

<p>여기까지 읽었을 때 Tensorflow &amp; Keras 와 유사한 개념(관계)이 아닌가 싶었는데, JAX/Flax는 Low-level의 섬세한 컨트롤이 가능하다는 점에 방점이 찍혀 있는 것 같다. 그와 달리 Keras는 높은 수준의 추상화가 이루어져 있고 사용자 친화적이다. 똑같이 구글에서 개발한 프레임워크지만 지향하는 철학이 다르다는 점이 재밌다.</p>

<p>책에 따르면 구글에서 개발한 모델들은 대부분 JAX로 작성되어 있고, 심지어 Hugging Face의 기존 모델들도 JAX로 변환하고 있다고 한다.</p>

<h2 id="함수형-프로그래밍">함수형 프로그래밍</h2>

<p>JAX/Flax의 활용 방식을 더 잘 파악할 수 있도록 책은 <strong>함수형 프로그래밍</strong>에 대해서 별도 챕터로 설명한다. 명령어의 흐름(순서)대로 상태를 변경하고 결과를 전달하는 것이 핵심인 절차적 프로그래밍과 다르게, 함수형 프로그래밍은 외부 상태와 상관없이 주어진 입력에 동일한 출력값을 내놓는 <em>순수 함수</em>를 사용한다. 따라서 <em>부수 효과</em>가 제거되며 상태가 변화하지 않는 불변성을 강조한다. 여기서 절차적 프로그래밍과 함수형 프로그래밍을 설명할 때 간단한 파이썬 예제가 첨부되어 있어서 이해가 편했다.</p>

<p>JAX, 나아가 딥러닝 연산에 있어서 이 개념을 이해하는 것이 중요한 이유를 세 가지로 제시하고 있다.</p>

<ol>
  <li>XLA 컴파일에 최적화된 처리가 가능해진다</li>
  <li>병렬처리와 분산처리에 유용하다</li>
  <li>코드를 모듈화함으로써 재사용성이 높아진다</li>
</ol>

<h1 id="jax-기본">JAX 기본</h1>

<p>백문이 불여일견, 직접 JAX 를 활용해보며 책의 내용을 따라가보겠다.</p>

<h2 id="설치">설치</h2>

<p>다행히도 JAX가 Mac M1을 공식 지원한다고 하여 <code class="language-plaintext highlighter-rouge">conda</code>로 쉽게 설치할 수 있었다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create <span class="nt">-n</span> jax-env <span class="nv">python</span><span class="o">=</span>3.9
conda activate jax-env
pip <span class="nb">install </span>jax jaxlib
</code></pre></div></div>

<p>import 하기</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">jax</span>
<span class="kn">import</span> <span class="n">jax.numpy</span> <span class="k">as</span> <span class="n">jnp</span>
</code></pre></div></div>

<h2 id="numpy와-비교">numpy와 비교</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x1</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span>
<span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>        <span class="c1"># [5. 7. 9.]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>  <span class="c1"># &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;
</span></code></pre></div></div>

<p>위 예제에서 보듯 jax.numpy는 기존 numpy 와 거의 똑같은 API를 제공하고 있다.</p>

<h2 id="grad-함수">grad 함수</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">grad</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>    <span class="c1"># Array(6., dtype=float32, weak_type=True)
</span></code></pre></div></div>

<p>JAX에서 미분, 즉 gradient를 계산해주는 <code class="language-plaintext highlighter-rouge">grad</code>를 사용한 예제다.</p>

<h2 id="부수-효과의-방지">부수 효과의 방지</h2>

<p>JAX는 부수 효과를 제거하는 함수형 프로그래밍의 제약을 따르고 있다. 책에서 제공해준 아래 예제를 참고해보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">x_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span>      <span class="c1"># [999   2   3]
</span></code></pre></div></div>

<p>numpy로 생성한 배열은 직접 접근해서 요소를 변경할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_2</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">x_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
<span class="c1"># TypeError: '&lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;' object does not support item assignment. JAX arrays are immutable.
</span></code></pre></div></div>

<p>반면 jax.numpy로 생성한 배열은 직접적인 수정을 허용하지 않는다. 이는 ‘외부 데이터’인 배열의 상태가 변형되면서 부수 효과가 발생하는 것을 방지하기 위함이다.<br />
만약 배열의 일부를 수정하는 작업을 진행하고 싶다면 부수 효과가 없는 순수 함수를 사용해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_2</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nf">modify</span><span class="p">(</span><span class="n">x_2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>    <span class="c1"># Array([999,   2,   3], dtype=int32)
</span></code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">modify(x)</code>는 부수 효과가 없는 순수 함수라고 볼 수 있는 것이며, 책은 <code class="language-plaintext highlighter-rouge">jax.grad</code>와 <code class="language-plaintext highlighter-rouge">jax.jit</code> 같은 함수는 순수 함수로 작성되어야 한다고 설명하고 있다.</p>

<h2 id="jit-컴파일">JIT 컴파일</h2>

<dl>
  <dt>변환</dt>
  <dd>주어진 함수를 변경하거나 수정하는 방식. 성능 최적화나 자동 미분을 가능하게 함.</dd>
</dl>

<p>책은 JAX에서 <mark>변환</mark>(transformation)이라는 키워드가 중요하다고 말한다. JAX에서 변환은 <code class="language-plaintext highlighter-rouge">jaxpr</code>, 즉 JAX 표현식이라는 중간 언어(intermediate language)를 통해 이루어진다. <code class="language-plaintext highlighter-rouge">jax.jit</code>가 대표적인 jax 변환이라고 소개된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.67</span><span class="p">,</span> <span class="n">lamdba_</span><span class="o">=</span><span class="mf">1.05</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lamdba_</span> <span class="o">*</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>

<span class="c1"># 일반
</span><span class="nf">selu</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">block_until_ready</span><span class="p">()</span>

<span class="c1"># XLA
</span><span class="n">selu_jit</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">jit</span><span class="p">(</span><span class="n">selu</span><span class="p">)</span>
<span class="nf">selu_jit</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">block_until_ready</span><span class="p">()</span> <span class="c1"># 비동기 실행
</span></code></pre></div></div>

<p>위 내용은 활성화 함수 SELU(Scaled Exponential Linear Unit)를 구현하고 호출한 내용이다.</p>

<p><img src="https://github.com/user-attachments/assets/859541e3-c76b-4791-a1f4-b624e2570fa8" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">selu(x)</code> 대신에 jit 변환을 적용한 <code class="language-plaintext highlighter-rouge">selu_jit(x)</code>가 7배 빠르다고 설명하고 있다. (구글 Colab T4 기준)</p>

<p>책을 읽으면서 흥미로웠던 부분은 <code class="language-plaintext highlighter-rouge">jax.jit</code>은 컴파일된 계산 그래프를 캐싱하여 재사용한다는 점이었다. 다만 <code class="language-plaintext highlighter-rouge">jax.jit</code>을 반복문 내부에서 호출할 경우 컴파일 과정이 불필요하게 반복될 수 있으니 지양하라고 안내하고 있다.</p>

<h1 id="flax-1">Flax</h1>

<p>마지막으로 Flax 를 활용한 예제를 살펴보겠다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">flax.linen</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">random</span>

<span class="n">key</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nc">PRNGKey</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="n">out_dims</span><span class="p">:</span> <span class="nb">int</span>
    
    <span class="nd">@nn.compact</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">reshape</span><span class="p">((</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">out_dims</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">out_dims</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p><em>책에 import 하는 부분은 없어서 추가했다</em><br />
<code class="language-plaintext highlighter-rouge">nn.Module</code> 에서 상속받아 모델을 생성한다는 점에서 PyTorch 와 유사한 방식의 API 라고 느껴졌고 금방 적응할 수 있겠다는 생각이 든다.</p>

<hr />

<h1 id="나가며">나가며</h1>

<p>『JAX/Flax로 딥러닝 레벨업』에서 JAX 핵심 개념을 위주로 살펴보며 책을 리뷰해보았다. <em>요즘 시점에서 왜 굳이 새로운 딥러닝 프레임워크가 필요할까?</em> 라고 막연히 궁금해 하며 리뷰어 신청을 했는데, 좋은 기회로 책도 제공 받고 JAX와 Flax에 대해 가볍게 배워볼 수 있는 시간이었다.</p>

<p>JAX가 지향하는 철학과 함께 그것이 녹아든 핵심 기능을 세세하게 설명해주기 때문에 JAX 입문서로 아주 알맞은 도서라는 생각이 들었다. 특히 함수형 프로그래밍 개념만을 설명하기 위해 별도 지면을 할애했다는 점에서는 JAX의 의미를 제대로 전달하겠다는 강한 의지도 보였다.</p>

<p>아마 JAX로 입문하기까지 가장 큰 장벽은 앞서 내가 떠올린 것과 같이 “왜 꼭 이것이어야 하는가?” 라는 의문일 텐데, 이 책을 읽는다면 그 장벽 정도는 충분히 넘을 수 있겠다. numpy 하나로 모델을 구현하는 정도로 low-level에서 모델링과 학습 과정 등을 유연하게 통제할 수 있다는 점이 JAX/Flax의 가장 강력한 정체성이라고 느꼈다. 구글 TPU를 사용하는 ML엔지니어라면 시간을 들여서라도 JAX를 적용할 가치가 있을 듯하다.</p>

<p>그 외에 CLIP, GPT 같은 최신 모델의 fine-tuning 을 예제로 다룬 점도 인상적이었다. ML 분야에 입문한 이후로 출판서를 활용해서 공부를 하는 건 정말 오랜만인데, 역시 최신 책이니 최신 모델도 다루는구나 - 싶었다.</p>

<p>다만 책 서문에서 이미 밝혔다시피 딥러닝 개념과 프레임워크에 대한 기본적인 지식이 있어야 책의 내용을 제대로 이해할 수 있다는 점은 염두에 둘 필요가 있겠다. 확실히 ‘초급서’라기보단 ‘입문서’로 보는 게 맞다. 또한 워낙에 고급 프레임워크다보니까 JAX/Flax 자체가 서비스(서빙)보다는 <strong>연구</strong>에 적합한 도구라는 생각이 들었다. 책 읽기 전과 비슷하게 <em>이것이 이것이 필요할까?</em> 라는 질문은 여전히 깔끔하게 해명되진 않았지만, 책을 읽고 나서 <em>언젠가 JAX를 써보고 싶다</em>는 욕심은 보다 뚜렷해졌다.</p>

<p>리뷰어로 선정하여 도서를 제공해준 출판사 제이펍에 진심으로 감사하다는 말씀을 표하며 본 리뷰를 마무리하겠다.</p>]]></content><author><name></name></author><category term="리뷰" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">📖 『컴퓨터 구조와 운영체제 핵심 노트』(길벗) 리뷰</title><link href="http://woocosmos.github.io/gilbut-ca-os/" rel="alternate" type="text/html" title="📖 『컴퓨터 구조와 운영체제 핵심 노트』(길벗) 리뷰" /><published>2024-09-16T00:00:00+00:00</published><updated>2024-09-16T00:00:00+00:00</updated><id>http://woocosmos.github.io/gilbut-ca-os</id><content type="html" xml:base="http://woocosmos.github.io/gilbut-ca-os/"><![CDATA[<p><img src="https://github.com/user-attachments/assets/61989b8a-92e7-4007-a47e-da9374e74260" alt="image" class="center-image" /></p>

<p><br />
<a href="https://blog.naver.com/gilbutzigy/223556929788">길벗 개발자 리뷰어(25차)</a>에 선정되어 책 『<a href="https://www.gilbut.co.kr/book/view?bookcode=BN004105"><strong>컴퓨터 구조와 운영체제 핵심 노트</strong></a>』를 무료로 제공 받았다.</p>

<dl>
  <dt>도서명</dt>
  <dd>컴퓨터 구조와 운영체제 핵심 노트</dd>
  <dt>지은이</dt>
  <dd>서지영</dd>
  <dt>발행사</dt>
  <dd>(주)도서출판 길벗</dd>
  <dt>초판 발행</dt>
  <dd>2024년 5월 30일</dd>
  <dt>정가</dt>
  <dd>25,000원</dd>
</dl>

<p><br />
출판사 길벗은 이전에 <a href="https://www.gilbut.co.kr/book/view?bookcode=BN004005">모두의 네트워크 기초</a>라는 책으로 접해 익숙하다. 컴퓨터 지식 관련 서적을 많이 출판하기 때문에 전공자, 비전공자를 가리지 않고 공부가 필요한 사람들이 참고하면 좋겠다.</p>

<p>서문에서 밝히듯 이 책은 개념적으로 이해하기 어려운 컴퓨터 구조와 운영체제를 그림을 통해 핵심 위주로 이해하는 것을 목표로 한다. 추천 독자는 아래와 같다.</p>
<ul>
  <li>IT 분야에 입문하려는 사람</li>
  <li>IT 분야 취업을 위해 빠르게 핵심 내용을 익혀야 하는 학생</li>
  <li>IT 분야 취업 후, 컴퓨터/운영체제 지식이 필요한 사람</li>
  <li>컴퓨터 원리를 이해하려는 개발자</li>
</ul>

<hr />

<p>책은 2부에 걸쳐 컴퓨터 구조와 운영체제를 각각 다룬다.</p>

<style>
table th {
    background-color: #f0f0f0; /* 원하는 색상 코드로 변경 */
}

table td:first-child {
    white-space: nowrap; /* 줄바꿈 없애기 */
}
</style>

<table>
  <thead>
    <tr>
      <th style="text-align: center">주제</th>
      <th style="text-align: left">키워드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>컴퓨터 구조</strong></td>
      <td style="text-align: left">데이터 처리, 명령어, CPU, 하드웨어, 캐시 메모리, 보조기억 장치, 입출력 장치, 병렬처리</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>운영체제</strong></td>
      <td style="text-align: left">프로세스, CPU 스케줄링, 교착상태, 메모리 할당, 가상 메모리, 파일 시스템</td>
    </tr>
  </tbody>
</table>

<p><br />
『컴퓨터 구조와 운영체제 핵심 노트』는 이름 그대로 핵심을 깔끔하게 정리해준다.<br />
이를 테면 컴퓨터의 기본 구조(하드웨어)에 대해 책은 아래와 같이 요약한다.</p>

<blockquote>
  <p>CPU, 기억 장치, 입출력 장치가 컴퓨터를 구성하는 기본 구조입니다. 그리고 이들 간 데이터 및 명령어 전달은 시스템 버스가 담당합니다.</p>
</blockquote>

<p><br />
<img src="https://github.com/user-attachments/assets/01e244f5-6b18-46fb-8a1f-f0d425574206" alt="IMG_3188" width="80%" /></p>

<p>중요한 내용은 이렇게 그림으로 표현해 이해에 도움을 준다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/ee294654-484c-40ad-93a5-1dcf2a2a91ba" alt="IMG_3190" width="80%" /></p>

<p>각 구성 요소를 짚은 다음 <u>실제 컴퓨터가 동작하는 원리</u>를 살펴보기 때문에 더욱 개념적으로 와닿았다.<br />
남는 공간에 스스로 이해한 내용을 다시 정리, 작성하면서 공부했다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/3b951e46-1b47-486e-946b-ea08f1b02ef0" alt="IMG_3191" width="80%" /></p>

<p>나의 경우 기본적인 내용일수록 공부하면서 충분히 이해하고 넘어가도 시간이 지나면 자꾸 까먹는 경향이 있다. 정리본을 계속 들추어보는 것도 한계가 있어서 이번 리뷰를 계기로 아예 시험 공부를 하듯 암기를 해두려 한다.<br />
각 챕터 말미에 제공되는 ‘확인 문제’는 이러한 나의 니즈에 딱 맞는다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/c791d107-37af-42e8-a698-e87f1db1f67d" alt="IMG_3192" width="80%" /></p>

<p>그뿐만 아니라 간단하게라도 예제 코드를 포함하고 있어 도움에 이해가 됐다. 그런데 어떤 예제는 C언어로, 어떤 예제는 파이썬으로 적혀 있어 일관성이 떨어지는 점은 아쉽다. 물론 본문에서는 참고용으로만 봐달라고 언급하고 있다.</p>

<hr />

<p>전반적인 개념을 핵심 위주로 정리하는 책이기 때문에 세부 주제를 깊이 있게 탐색하고자 하는 독자라면 다소 아쉬움이 남을 수 있겠다. 『컴퓨터 구조와 운영체제 핵심 노트』는 <u>컴퓨터 과학에 입문하거나 배운 내용을 복습하는 용도</u>로 <strong>적극 추천</strong>한다.</p>

<p>베타 리더 후기 중에서 심화 학습용 도서로 (마찬가지로 올해 길벗에서 출판한) 『<a href="https://www.gilbut.co.kr/book/view?bookcode=BN004024">컴퓨터 밑바닥의 비밀</a>』을 추천하고 있다. 장바구니에 넣어두어야겠다.</p>

<p>개발자 리뷰어로 선정해주시고 도서까지 제공해준 출판사 길벗에 감사의 인사를 전달하며 본 리뷰를 마무리하겠다.</p>]]></content><author><name></name></author><category term="리뷰" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">GitHub Actions 활용한 태스크 및 배포 자동화</title><link href="http://woocosmos.github.io/github-action/" rel="alternate" type="text/html" title="GitHub Actions 활용한 태스크 및 배포 자동화" /><published>2024-08-30T00:00:00+00:00</published><updated>2024-08-30T00:00:00+00:00</updated><id>http://woocosmos.github.io/github-action</id><content type="html" xml:base="http://woocosmos.github.io/github-action/"><![CDATA[<p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- CI/CD 플랫폼인 GitHub Actions의 기능과 구성 요소를 살펴봤다
- GitHub Actions를 활용하여 특정 스크립트를 작동시키거나 로컬로 빌드한 내용을 배포하는 태스크를 자동화했다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p><a href="https://docs.github.com/ko/actions">GitHub Actions</a>를 사용하여 특정 스크립트를 실행시키고 배포하는 워크플로를 자동화한다.</p>

<p>자동화가 필요한 이유는 두 가지다.</p>

<ol>
  <li>블로그 포스트가 늘어남에 따라 <a href="https://woocosmos.github.io/search-page-dev/#%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%B6%94%EC%B2%9C">추천 키워드의 점수</a>를 새롭게 집계하고 업데이트해야 한다</li>
  <li>로컬에서 사이트를 직접 빌드한 다음에 <a href="http://woocosmos.github.io/blog-history/#gh-pages-%EC%83%9D%EC%84%B1">gh-pages 브랜치</a>에 반영함으로써 배포해야 한다</li>
</ol>

<p>따라서 이번 포스트에서는 태스크의 최신화와 효율화를 위해 GitHub Actions의 워크플로를 구성해보겠다.</p>

<h1 id="github-actions">GitHub Actions</h1>

<p><strong>GitHub Actions</strong>는 빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 <strong>CI/CD 플랫폼</strong>이다.</p>

<blockquote>
  <p>CI/CD : Continuous Integration(지속적 통합) 및 Continuous Delivery/Deployment(지속적 제공/배포). 소프트웨어의 개발 라이프사이클을 효율화, 가속화 하는 DevOps 개념.</p>
</blockquote>

<p><img src="https://github.com/user-attachments/assets/b23f798b-4dc2-4415-a8ff-8eb446c6dce4" alt="image" /></p>

<p>코드 변경에 따라 블로그 콘텐츠를 업데이트한다는 점에서 CI 개념과 연결되고, Jekyll 사이트를 배포한다는 점에서 CD 개념과 연결된다. (<em>정확히 말하자면 CI는 여러 작업자가 commit한 작업을 효율적이고 빠르게 통합함을 목표로 한다</em>)</p>

<p>GitHub Actions는 PR, Push 등 <strong>이벤트</strong>가 발생할 때 <strong>워크플로</strong>를 실행시킬 수 있다. 자체 인프라에서 워크플로를 실행할 수 있지만 GitHub에서도 주요 OS의 가상 머신을 통해 <strong>서버</strong>를 제공하고 있다. 각 구성 요소를 살펴보겠다.</p>

<h2 id="구성-요소">구성 요소</h2>
<p><strong>Workflows(워크플로)</strong><br />
하나 이상의 작업으로 구성된 프로세스. YAML 파일로 정의하며 특정 조건에 따라 트리거 된다. 여러 워크플로를 생성할 수 있고, 한 워크플로 안에서 다른 워크플로를 참조할 수도 있다.</p>

<p><strong>Events(이벤트)</strong><br />
워크플로의 실행을 트리거 하는 활동이다. GitHub Actions 에서 사용할 수 있는 <a href="https://docs.github.com/ko/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows">이벤트의 리스트</a>를 참고하자.</p>

<p><strong>Jobs(작업)</strong><br />
워크플로 안에서 단계로 구성된 집합. 이 단계들은 같은 실행기(runner) 안에서 작동하기 때문에 데이터를 공유할 수 있다. 디폴트로 작업들끼리는 종속성이 없기 때문에 병렬로 실행되나, 한 작업이 다른 작업에 종속된다면 완료를 기다린다.</p>

<p><strong>runner(실행기)</strong><br />
워크플로를 실행하는 서버. 하나의 runner는 한 번에 하나의 작업(job)을 실행할 수 있다.</p>

<h1 id="시작하기">시작하기</h1>

<p>root 경로에서 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 폴더를 생성, 해당 위치에 test.yml 파일을 작성한다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Test</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">post/**'</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">my_first_job</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">step-example</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">echo Hello World!</span>
</code></pre></div></div>

<p>post로 시작하는 브랜치에 push 이벤트가 발생할 때 트리거 되는 워크플로를 정의했다. my_frist_job 이라는 작업이 실행될 텐데, ubuntu 실행기에서 Hello World 를 출력하는 step을 포함하고 있다.</p>

<p>yml 파일을 저장한 후, post/github-actions 브랜치에 push 해보았다. 그 결과는 프로젝트 레포지토리의 Actions 탭에서 확인할 수 있다</p>

<p><img src="https://github.com/user-attachments/assets/c657fa7a-03ce-41ef-85cb-3843bed9b570" alt="image" /></p>

<p>왼쪽 탭에 Test 라는 워크플로가 생성되어 있고 워크플로의 실행 내역이 표시되어 있다. post/github-actions에 push 함으로써 트리거된 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/fa4487ef-855d-4617-a003-15904ba4ed74" alt="image" width="80%" />
<img src="https://github.com/user-attachments/assets/c6b5fc64-481c-4be5-aba8-ae5d34be5d79" alt="image" width="50%" /></p>

<p>my_frist_job 작업이 성공적으로 실행되었고 그것을 눌러 step-example 단계도 실행되었음을 확인할 수 있다. 이제 본격 나의 태스크에 적용해보겠다.</p>

<h2 id="키워드-업데이트">키워드 업데이트</h2>

<p>추천 키워드를 업데이트할 조건을 정한 후, 그에 따른 트리거와 작업 내용을 YAML 파일로 작성했다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Workflow for updating keywords</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">closed</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">my-job</span><span class="pi">:</span>
    <span class="na">if</span><span class="pi">:</span> <span class="s">(github.event_name == 'pull_request' &amp;&amp;</span>
            <span class="s">github.event.pull_request.merged == </span><span class="kc">true</span><span class="s"> &amp;&amp;</span> 
            <span class="s">startsWith(github.event.pull_request.head.ref, 'post/')) ||</span>
        <span class="s">(github.event_name == 'push' &amp;&amp;</span>
            <span class="s">contains(github.event.head_commit.message, 'post'))</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Approach the Codes</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Python</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-python@v5</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">python-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
          <span class="na">cache</span><span class="pi">:</span> <span class="s1">'</span><span class="s">pip'</span>
          
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install Ubuntu Dependencies</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">sudo apt-get update</span>
          <span class="s">sudo apt-get install -y g++ openjdk-8-jdk</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install Python Dependencies</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">python -m pip install -r $/requirements.txt</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Run the Script</span>
        <span class="na">run</span><span class="pi">:</span>
          <span class="s">python $/assets/recommend.py</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure Git</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">git config --global user.name "${GITHUB_ACTOR}"</span>
          <span class="s">git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check for Differences</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">check_diff</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">git add $/keywords.json</span>
          <span class="s">if git diff --cached --quiet; then</span>
            <span class="s">echo "No changes detected"</span>
            <span class="s">echo "has_changes=false" &gt;&gt; $GITHUB_OUTPUT</span>
          <span class="s">else</span>
            <span class="s">echo "has_changes=true" &gt;&gt; $GITHUB_OUTPUT</span>
          <span class="s">fi</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Commit the Change</span>
        <span class="na">if</span><span class="pi">:</span> <span class="s">steps.check_diff.outputs.has_changes == 'true'</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">echo "pushing the file ..."</span>
          <span class="s">git commit -m "[automation] keywords updated"</span>
          <span class="s">git push</span>
</code></pre></div></div>

<p>워크플로가 트리거 되는 조건은 아래와 같다.</p>

<ul>
  <li>post로 시작하는 브랜치의 PR를 완료했을 때 (보통 post 브랜치에서 포스트를 작성한 후 완성했을 때 master로 merge시키기 때문)</li>
  <li>push 의 커밋 메세지에 ‘post’가 포함되어 있을 때 (master 브랜치에서 바로 수정하여 push할 때도 있으므로)</li>
</ul>

<p>‘my-job’ 작업은 환경을 세팅하고(1~4번) 스크립트를 실행시키고(5번) 변경 사항을 git push 하는(6~8번) 일련의 단계들을 포함하고 있다.</p>

<hr />
<ol>
  <li>Approach the Codes</li>
  <li>Set up Python
    <ul>
      <li><code class="language-plaintext highlighter-rouge">actions/setup-python@v5</code> : GitHub Actions에서 제공하는 파이썬 환경이다</li>
      <li><code class="language-plaintext highlighter-rouge">cache: 'pip'</code> : GitHub Actions는 <a href="https://docs.github.com/ko/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows"><strong>캐싱 기능</strong></a>을 제공하는데, 이 옵션을 명시해주면 pip 캐시를 복원하여 활용하고 캐시가 없을 경우 새로 설치한다</li>
    </ul>
  </li>
  <li>Install Ubuntu Dependencies</li>
  <li>Install Python Dependencies
    <ul>
      <li>프로젝트의 root 경로는 <code class="language-plaintext highlighter-rouge">${{ github.workspace }}</code>라는 변수로 접근할 수 있다</li>
    </ul>
  </li>
  <li>Run the Script</li>
  <li>Configure Git</li>
  <li>Check for Differences
    <ul>
      <li><code class="language-plaintext highlighter-rouge">keywords.json</code> 파일만 stage 에 올리고 변경사항이 있는지 확인한다. 이 부분을 추가하지 않으면 nothing to commit 에러가 발생하며 워크플로가 중단된다.</li>
      <li>이 플래그는 <code class="language-plaintext highlighter-rouge">has_changes</code>라는 변수에 저장되어 다음 step에서 사용된다</li>
    </ul>
  </li>
  <li>Commit the Change
    <ul>
      <li>앞선 단계에서 선언한 <code class="language-plaintext highlighter-rouge">has_changes</code>으로 if 조건을 명시하고, 앞서 stage에 올린 파일을 리모트에 반영한다<br />
<b></b></li>
    </ul>
  </li>
</ol>

<p>참고로 konlpy 를 사용하는 만큼 환경 구축이 까다로울 것 같아서, docker로 ubuntu 컨테이너를 하나 띄워서 시뮬레이션 했다. 나중의 활용을 위해 여기에 커맨드를 정리해둔다.<br />
volume binding 하지 않고 docker cp 명령어로 파이썬 파일을 복제해 썼다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-d</span> <span class="nt">--name</span> fake-github-actions ubuntu:latest <span class="nb">tail</span> <span class="nt">-f</span> /dev/null
docker <span class="nb">cp</span> /path/to/recommend.py fake-github-actions:/root/recommend.py
docker <span class="nb">exec </span>it fake-github-actions /bin/bash
<span class="c"># 파이썬 설치 후 Ubuntu, python 의 어떤 dependencies가 필요한지 테스트</span>
</code></pre></div></div>

<p>흥미로운 지점은 <strong><code class="language-plaintext highlighter-rouge">cache: 'pip'</code>를 사용하지 않았을 때 실행시간이 더 짧았다</strong>는 점인데, pip로 설치하는 패키지의 개수가 많지 않아 오히려 <strong>캐시를 복원해오는 데 시간이 더 소요</strong>되는 것으로 보인다. 이는 전체 시스템 디렉토리를 캐싱해야 하는 Ubuntu 패키지에 대해서도 마찬가지다. 따라서 최종 코드에서는 해당 옵션을 <u>제외</u>했다.</p>

<h2 id="배포-자동화">배포 자동화</h2>

<p>배포는 <a href="https://github.com/jeffreytse/jekyll-deploy-action">JEKYLL DEPLOY ACTION</a>이라는 액션을 사용했다. 개발 스토리를 살펴보면,</p>

<blockquote>
  <p>GitHub Pages는 <em>허용된 플러그인</em>만 <em>안전 모드</em> 상에서 실행해주기 때문에, 커스텀 플러그인을 사용하는 경우 로컬에서 직접 빌드하고 gh-pages로 배포해야 할 때가 있다.</p>
</blockquote>

<p><a href="https://woocosmos.github.io/blog-history/#gh-pages-%EC%83%9D%EC%84%B1">나의 니즈</a>에 딱 맞는 action이라 바로 사용해보기로 했다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy to Github Pages</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build_and_deploy</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>

      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/cache@v4</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">.asdf/**</span>
            <span class="s">vendor/bundle</span>
          <span class="na">key</span><span class="pi">:</span> <span class="s">${{ runner.os }}-cache-${{ hashFiles('**/cache.key') }}</span>
          <span class="na">restore-keys</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">${{ runner.os }}-cache-</span>

      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">jeffreytse/jekyll-deploy-action@v0.6.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">provider</span><span class="pi">:</span> <span class="s1">'</span><span class="s">github'</span>         
          <span class="na">token</span><span class="pi">:</span> <span class="s">${{ secrets.GITHUB_TOKEN }}</span> 
          <span class="na">branch</span><span class="pi">:</span> <span class="s1">'</span><span class="s">gh-pages'</span>         
          <span class="na">jekyll_src</span><span class="pi">:</span> <span class="s1">'</span><span class="s">./'</span>    
      
</code></pre></div></div>

<p>이미 <code class="language-plaintext highlighter-rouge">gh-pages</code> 브랜치를 만들어 배포에 사용하고 있었기 때문에 수정 없이 그대로 적용할 수 있었다. 이 워크플로를 통해 jeykll 환경을 구성, master를 기준으로 build하고 <code class="language-plaintext highlighter-rouge">gh-pages</code> 에 반영하는 과정을 자동화했다. master 브랜치로 push 이벤트가 발생할 때마다 자동으로 배포가 되는 셈이다.</p>

<p><em>+ 2024-09-16 업데이트</em></p>

<p>2주 만에 블로그를 업데이트하고 master로 push 했더니 <strong>error: RPC failed; HTTP 400 curl 92 HTTP/2 stream 7 was not closed cleanly: CANCEL (err 8)</strong> 라는 에러와 함께 배포에 실패했다. <a href="https://github.com/jeffreytse/jekyll-deploy-action/issues/81">이슈 채널에 동일한 에러를 호소하는 사람</a>이 있었다. 답변에서 안내해주는 대로 SSH 옵션을 추가했다.</p>

<blockquote>
  <p>Note: SSH approach has higher priority than HTTP approach when you provide both at the same time.</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">jeffreytse/jekyll-deploy-action@v0.6.0</span>
  <span class="na">with</span><span class="pi">:</span>
  <span class="s">...</span>
  <span class="na">ssh_private_key</span><span class="pi">:</span> <span class="s">$</span>
  <span class="s">...</span>
</code></pre></div></div>

<p>하지만 마찬가지로 에러가 발생해서 <code class="language-plaintext highlighter-rouge">jekyll-deploy-action</code>의 버전을 master로 바꾸어보았다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">jeffreytse/jekyll-deploy-action@master</span>
</code></pre></div></div>

<p>배포에 성공했다. master 브랜치에 관련 에러가 이제 막 반영된 모양이다. (심지어 지금 시간 기준 50분 전에 올라온 <a href="https://github.com/jeffreytse/jekyll-deploy-action/issues/89">동일한 이슈</a>도 있다..)</p>

<h1 id="나가며">나가며</h1>

<p>이로써 GitHub Actions를 활용하여 매우 간편하게 CI/CD를 자동화해보았다. 액션의 yaml 파일을 구성하는 과정이 docker-compose.yml 를 작성하는 것과 유사해서 금방 해낼 수 있었던 것 같다.<br />
이번 경험은 cache를 재사용하는 것이 무조건 빠르다는 선입견을 깨게 된 계기가 되기도 했다.</p>

<p>실무 환경에서 CI/CD 작업을 처리할 때 Jenkins(젠킨스)도 많이 활용하는 것으로 알고 있다. 실제로 내가 속한 조직에서 ML모델 추론과 웹 서버 호스팅을 Jenkins으로 관리하기도 했다. 기회가 된다면 다음에는 Jenkins도 써보고 싶다.</p>]]></content><author><name></name></author><category term="DevOps" /><summary type="html"><![CDATA[요약 - CI/CD 플랫폼인 GitHub Actions의 기능과 구성 요소를 살펴봤다 - GitHub Actions를 활용하여 특정 스크립트를 작동시키거나 로컬로 빌드한 내용을 배포하는 태스크를 자동화했다 개요 GitHub Actions를 사용하여 특정 스크립트를 실행시키고 배포하는 워크플로를 자동화한다. 자동화가 필요한 이유는 두 가지다. 블로그 포스트가 늘어남에 따라 추천 키워드의 점수를 새롭게 집계하고 업데이트해야 한다 로컬에서 사이트를 직접 빌드한 다음에 gh-pages 브랜치에 반영함으로써 배포해야 한다 따라서 이번 포스트에서는 태스크의 최신화와 효율화를 위해 GitHub Actions의 워크플로를 구성해보겠다. GitHub Actions GitHub Actions는 빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼이다. CI/CD : Continuous Integration(지속적 통합) 및 Continuous Delivery/Deployment(지속적 제공/배포). 소프트웨어의 개발 라이프사이클을 효율화, 가속화 하는 DevOps 개념. 코드 변경에 따라 블로그 콘텐츠를 업데이트한다는 점에서 CI 개념과 연결되고, Jekyll 사이트를 배포한다는 점에서 CD 개념과 연결된다. (정확히 말하자면 CI는 여러 작업자가 commit한 작업을 효율적이고 빠르게 통합함을 목표로 한다) GitHub Actions는 PR, Push 등 이벤트가 발생할 때 워크플로를 실행시킬 수 있다. 자체 인프라에서 워크플로를 실행할 수 있지만 GitHub에서도 주요 OS의 가상 머신을 통해 서버를 제공하고 있다. 각 구성 요소를 살펴보겠다. 구성 요소 Workflows(워크플로) 하나 이상의 작업으로 구성된 프로세스. YAML 파일로 정의하며 특정 조건에 따라 트리거 된다. 여러 워크플로를 생성할 수 있고, 한 워크플로 안에서 다른 워크플로를 참조할 수도 있다. Events(이벤트) 워크플로의 실행을 트리거 하는 활동이다. GitHub Actions 에서 사용할 수 있는 이벤트의 리스트를 참고하자. Jobs(작업) 워크플로 안에서 단계로 구성된 집합. 이 단계들은 같은 실행기(runner) 안에서 작동하기 때문에 데이터를 공유할 수 있다. 디폴트로 작업들끼리는 종속성이 없기 때문에 병렬로 실행되나, 한 작업이 다른 작업에 종속된다면 완료를 기다린다. runner(실행기) 워크플로를 실행하는 서버. 하나의 runner는 한 번에 하나의 작업(job)을 실행할 수 있다. 시작하기 root 경로에서 .github/workflows 폴더를 생성, 해당 위치에 test.yml 파일을 작성한다. name: Test on: push: branches: - 'post/**' jobs: my_first_job: runs-on: ubuntu-latest steps: - name: step-example run: echo Hello World! post로 시작하는 브랜치에 push 이벤트가 발생할 때 트리거 되는 워크플로를 정의했다. my_frist_job 이라는 작업이 실행될 텐데, ubuntu 실행기에서 Hello World 를 출력하는 step을 포함하고 있다. yml 파일을 저장한 후, post/github-actions 브랜치에 push 해보았다. 그 결과는 프로젝트 레포지토리의 Actions 탭에서 확인할 수 있다 왼쪽 탭에 Test 라는 워크플로가 생성되어 있고 워크플로의 실행 내역이 표시되어 있다. post/github-actions에 push 함으로써 트리거된 것이다. my_frist_job 작업이 성공적으로 실행되었고 그것을 눌러 step-example 단계도 실행되었음을 확인할 수 있다. 이제 본격 나의 태스크에 적용해보겠다. 키워드 업데이트 추천 키워드를 업데이트할 조건을 정한 후, 그에 따른 트리거와 작업 내용을 YAML 파일로 작성했다. name: Workflow for updating keywords on: pull_request: branches: - master types: - closed push: branches: - master jobs: my-job: if: (github.event_name == 'pull_request' &amp;&amp; github.event.pull_request.merged == true &amp;&amp; startsWith(github.event.pull_request.head.ref, 'post/')) || (github.event_name == 'push' &amp;&amp; contains(github.event.head_commit.message, 'post')) runs-on: ubuntu-latest steps: - name: Approach the Codes uses: actions/checkout@v3 - name: Set up Python uses: actions/setup-python@v5 with: python-version: '3.8' cache: 'pip' - name: Install Ubuntu Dependencies run: | sudo apt-get update sudo apt-get install -y g++ openjdk-8-jdk - name: Install Python Dependencies run: | python -m pip install -r $/requirements.txt - name: Run the Script run: python $/assets/recommend.py - name: Configure Git run: | git config --global user.name "${GITHUB_ACTOR}" git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com" - name: Check for Differences id: check_diff run: | git add $/keywords.json if git diff --cached --quiet; then echo "No changes detected" echo "has_changes=false" &gt;&gt; $GITHUB_OUTPUT else echo "has_changes=true" &gt;&gt; $GITHUB_OUTPUT fi - name: Commit the Change if: steps.check_diff.outputs.has_changes == 'true' run: | echo "pushing the file ..." git commit -m "[automation] keywords updated" git push 워크플로가 트리거 되는 조건은 아래와 같다. post로 시작하는 브랜치의 PR를 완료했을 때 (보통 post 브랜치에서 포스트를 작성한 후 완성했을 때 master로 merge시키기 때문) push 의 커밋 메세지에 ‘post’가 포함되어 있을 때 (master 브랜치에서 바로 수정하여 push할 때도 있으므로) ‘my-job’ 작업은 환경을 세팅하고(1~4번) 스크립트를 실행시키고(5번) 변경 사항을 git push 하는(6~8번) 일련의 단계들을 포함하고 있다. Approach the Codes Set up Python actions/setup-python@v5 : GitHub Actions에서 제공하는 파이썬 환경이다 cache: 'pip' : GitHub Actions는 캐싱 기능을 제공하는데, 이 옵션을 명시해주면 pip 캐시를 복원하여 활용하고 캐시가 없을 경우 새로 설치한다 Install Ubuntu Dependencies Install Python Dependencies 프로젝트의 root 경로는 ${{ github.workspace }}라는 변수로 접근할 수 있다 Run the Script Configure Git Check for Differences keywords.json 파일만 stage 에 올리고 변경사항이 있는지 확인한다. 이 부분을 추가하지 않으면 nothing to commit 에러가 발생하며 워크플로가 중단된다. 이 플래그는 has_changes라는 변수에 저장되어 다음 step에서 사용된다 Commit the Change 앞선 단계에서 선언한 has_changes으로 if 조건을 명시하고, 앞서 stage에 올린 파일을 리모트에 반영한다 참고로 konlpy 를 사용하는 만큼 환경 구축이 까다로울 것 같아서, docker로 ubuntu 컨테이너를 하나 띄워서 시뮬레이션 했다. 나중의 활용을 위해 여기에 커맨드를 정리해둔다. volume binding 하지 않고 docker cp 명령어로 파이썬 파일을 복제해 썼다. docker run --rm -d --name fake-github-actions ubuntu:latest tail -f /dev/null docker cp /path/to/recommend.py fake-github-actions:/root/recommend.py docker exec it fake-github-actions /bin/bash # 파이썬 설치 후 Ubuntu, python 의 어떤 dependencies가 필요한지 테스트 흥미로운 지점은 cache: 'pip'를 사용하지 않았을 때 실행시간이 더 짧았다는 점인데, pip로 설치하는 패키지의 개수가 많지 않아 오히려 캐시를 복원해오는 데 시간이 더 소요되는 것으로 보인다. 이는 전체 시스템 디렉토리를 캐싱해야 하는 Ubuntu 패키지에 대해서도 마찬가지다. 따라서 최종 코드에서는 해당 옵션을 제외했다. 배포 자동화 배포는 JEKYLL DEPLOY ACTION이라는 액션을 사용했다. 개발 스토리를 살펴보면, GitHub Pages는 허용된 플러그인만 안전 모드 상에서 실행해주기 때문에, 커스텀 플러그인을 사용하는 경우 로컬에서 직접 빌드하고 gh-pages로 배포해야 할 때가 있다. 나의 니즈에 딱 맞는 action이라 바로 사용해보기로 했다. name: Build and Deploy to Github Pages on: push: branches: - master jobs: build_and_deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/cache@v4 with: path: | .asdf/** vendor/bundle key: ${{ runner.os }}-cache-${{ hashFiles('**/cache.key') }} restore-keys: | ${{ runner.os }}-cache- - uses: jeffreytse/jekyll-deploy-action@v0.6.0 with: provider: 'github' token: ${{ secrets.GITHUB_TOKEN }} branch: 'gh-pages' jekyll_src: './' 이미 gh-pages 브랜치를 만들어 배포에 사용하고 있었기 때문에 수정 없이 그대로 적용할 수 있었다. 이 워크플로를 통해 jeykll 환경을 구성, master를 기준으로 build하고 gh-pages 에 반영하는 과정을 자동화했다. master 브랜치로 push 이벤트가 발생할 때마다 자동으로 배포가 되는 셈이다. + 2024-09-16 업데이트 2주 만에 블로그를 업데이트하고 master로 push 했더니 error: RPC failed; HTTP 400 curl 92 HTTP/2 stream 7 was not closed cleanly: CANCEL (err 8) 라는 에러와 함께 배포에 실패했다. 이슈 채널에 동일한 에러를 호소하는 사람이 있었다. 답변에서 안내해주는 대로 SSH 옵션을 추가했다. Note: SSH approach has higher priority than HTTP approach when you provide both at the same time. - uses: jeffreytse/jekyll-deploy-action@v0.6.0 with: ... ssh_private_key: $ ... 하지만 마찬가지로 에러가 발생해서 jekyll-deploy-action의 버전을 master로 바꾸어보았다. - uses: jeffreytse/jekyll-deploy-action@master 배포에 성공했다. master 브랜치에 관련 에러가 이제 막 반영된 모양이다. (심지어 지금 시간 기준 50분 전에 올라온 동일한 이슈도 있다..) 나가며 이로써 GitHub Actions를 활용하여 매우 간편하게 CI/CD를 자동화해보았다. 액션의 yaml 파일을 구성하는 과정이 docker-compose.yml 를 작성하는 것과 유사해서 금방 해낼 수 있었던 것 같다. 이번 경험은 cache를 재사용하는 것이 무조건 빠르다는 선입견을 깨게 된 계기가 되기도 했다. 실무 환경에서 CI/CD 작업을 처리할 때 Jenkins(젠킨스)도 많이 활용하는 것으로 알고 있다. 실제로 내가 속한 조직에서 ML모델 추론과 웹 서버 호스팅을 Jenkins으로 관리하기도 했다. 기회가 된다면 다음에는 Jenkins도 써보고 싶다.]]></summary></entry><entry><title type="html">블로그 키워드 추천 및 검색 기능 구현기</title><link href="http://woocosmos.github.io/search-page-dev/" rel="alternate" type="text/html" title="블로그 키워드 추천 및 검색 기능 구현기" /><published>2024-08-26T00:00:00+00:00</published><updated>2024-08-26T00:00:00+00:00</updated><id>http://woocosmos.github.io/search-page-dev</id><content type="html" xml:base="http://woocosmos.github.io/search-page-dev/"><![CDATA[<p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- simple-jekyll-search 라이브러리를 활용하여 검색 기능을 추가했다
- 탭에서 접근할 수 있는 검색 페이지를 구성하고 검색 결과를 적절하게 시각화했다
- TF-IDF 값을 활용하여 검색할 키워드를 추천했다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p><a href="https://github.com/aweekj/kiko-now">Kiko Now</a> Jekyll 테마에 검색 기능이 없는 관계로 <strong>직접 검색 페이지를 구성하고 JS 라이브러리로 검색 기능을 적용</strong>했다. 블로그에 포스트가 쌓일수록 검색 기능이 필수적이라고 생각했다. 태그 기반의 문서 분류 방식은 한계가 명확하고, 특정 문서를 찾을 때도 검색이 가장 간편하기 때문이다.</p>

<p>블로그 개발 과정은 <a href="https://woocosmos.github.io/blog-history/">특정 포스트</a>에 아카이빙하고 있지만, 해당 기능은 분량이 많아 별도로 기록한다.</p>

<h1 id="기본-기능">기본 기능</h1>
<p>입력 키워드로 블로그 내 모든 컨텐츠에 대해 검색하는 기본 기능부터 적용한다.</p>

<p><a href="https://github.com/christian-fei/Simple-Jekyll-Search"><strong>Simple-Jekyll-Search</strong></a> 라이브러리를 적용했다. 브라우저 단[Client-Side]에서 작동하기 때문에 별도 서버나 DB를 구축할 필요가 없다. 적용 과정 역시 간단하다.</p>

<h3 class="no_toc"> 첫째, search.json 생성 </h3>

<p>블로그의 root 위치에 아래 <code class="language-plaintext highlighter-rouge">search.json</code> 파일을 만든다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">---</span><span class="w">
</span><span class="err">layout:</span><span class="w"> </span><span class="err">none</span><span class="w">
</span><span class="err">---</span><span class="w">
</span><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">post</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">site.posts</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"title"</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.title | escape }}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"tags"</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.tags | join: ', ' }}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"date"</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.date | date: '%Y.%m.%d'}}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"url"</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ site.url }}{{ post.url }}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.content | strip_html | strip_newlines | escape }}"</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">unless</span><span class="w"> </span><span class="err">forloop.last</span><span class="w"> </span><span class="err">%</span><span class="p">},{</span><span class="err">%</span><span class="w"> </span><span class="err">endunless</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
  </span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">endfor</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>
<p>기존 코드에 <code class="language-plaintext highlighter-rouge">post.content</code> 를 추가하여 본문 텍스트도 가져오게 했다. 이때 <code class="language-plaintext highlighter-rouge">strip_html</code> 등 몇 가지 Jekyll 문법을 더했다. 이를 통해 <code class="language-plaintext highlighter-rouge">{baseurl}/search.json</code> 주소로 json 파일에 접근할 수 있다. 브라우저로부터 이 파일을 읽어와 검색 데이터로 활용할 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/e2a40f6a-eaea-465f-ab02-42408c060258" alt="image" style="border:black solid 0.5px; padding:10px; width:50%;" class="center-image" />
<br /></p>

<h3 class="no_toc"> 둘째, JavaSript 소스 추가 </h3>

<p><a href="https://github.com/christian-fei/Simple-Jekyll-Search/blob/master/example/js/simple-jekyll-search.js">simple-jekyll-search.js</a>를 다운 받아 어디든 위치시킨다. 이 스크립트는 <strong><code class="language-plaintext highlighter-rouge">search.json</code>으로부터 데이터를 읽어와 입력어에 매칭되는 내용을 찾는</strong> 함수 <code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code>를 정의하고 있다.</p>

<p>그 다음 <a href="https://github.com/woocosmos/woocosmos.github.io/blob/master/assets/search-and-return.js">search-and-return.js</a>도 다운 받아 같은 위치에 붙여넣는다. <strong><code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code> 함수를 실행시켜서 결과값을 받아와 처리하는</strong> 부분을 별도 스크립트로 작성한 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">sjs</span> <span class="o">=</span> <span class="nc">SimpleJekyllSearch</span><span class="p">({</span>
    <span class="na">searchInput</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">search-input</span><span class="dl">'</span><span class="p">),</span>
    <span class="na">resultsContainer</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">results-container</span><span class="dl">'</span><span class="p">),</span>
    <span class="na">json</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/search.json</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">searchResultTemplate</span><span class="p">:</span> <span class="p">...</span>
    <span class="na">noResultsText</span><span class="p">:</span> <span class="dl">'</span><span class="s1">😴 검색 결과가 없습니다</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">templateMiddleware</span> <span class="p">:</span> <span class="p">...</span>
<span class="p">)}</span>
</code></pre></div></div>

<p>나는 assets 라는 폴더를 만들어 이곳에 JS 소스를 모아두기로 했다. 두 스크립트는 다음 서술할 검색 페이지에서 실행시킬 것이다.</p>

<h3 class="no_toc"> 셋째, 검색 페이지 구성 </h3>

<p>root 위치에 <code class="language-plaintext highlighter-rouge">search</code> 폴더를 생성하고 그 아래 <code class="language-plaintext highlighter-rouge">index.html</code> 파일을 생성한다. 앞서 추가한 JS 스크립트가 실행되면서 검색어 입출력이 진행되는 곳이다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: page
permalink: /search
---

<span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"search"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"search-container"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"search"</span> <span class="na">id=</span><span class="s">"search-input"</span> <span class="na">placeholder=</span><span class="s">"  🤔 검색어를 입력하세요."</span><span class="nt">&gt;</span>
        <span class="nt">&lt;ul</span> <span class="na">id=</span><span class="s">"results-container"</span><span class="nt">&gt;&lt;/ul&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/ul&gt;</span>

<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ site.baseurl }}/assets/simple-jekyll-search.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ site.baseurl }}/assets/search-and-return.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>이렇게 <code class="language-plaintext highlighter-rouge">{baseurl}/search</code> 주소로 접근할 수 있는 검색 페이지를 완성하였다.</p>

<p><img src="https://github.com/user-attachments/assets/a3b2710e-95b2-43d8-b4b7-cdb3375e2625" alt="image" style="border:black solid 0.5px; padding:10px;" class="center-image" /></p>

<p>한편, 무엇을 클릭했을 때 이 검색 페이지로 연결되도록 할 것인가? 나는 상단의 탭에 <strong>돋보기 아이콘</strong>을 추가했다. 이를 위해 돋보기 아이콘 svg와 검색 페이지를  연결하여 <code class="language-plaintext highlighter-rouge">_includes/nav.html</code>에 추가했다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"search-icon"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"{{ site.baseurl }}/search"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;svg</span> 
      <span class="na">width=</span><span class="s">"24"</span> 
      <span class="na">height=</span><span class="s">"24"</span> 
      <span class="na">viewBox=</span><span class="s">"0 0 24 24"</span> 
      <span class="na">fill=</span><span class="s">"none"</span> 
      <span class="na">xmlns=</span><span class="s">"http://www.w3.org/2000/svg"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;path</span> <span class="na">d=</span><span class="s">"M10 ...생략"</span> <span class="na">fill=</span><span class="s">"currentColor"</span><span class="nt">&gt;&lt;/path&gt;</span>
    <span class="nt">&lt;/svg&gt;</span>
  <span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div></div>

<p><img src="https://github.com/user-attachments/assets/96ec0aaf-0692-4da4-b390-313138b53ad0" alt="image" style="border:black solid 0.5px; padding:10px;" class="center-image" /></p>

<p>이렇게 검색 페이지를 구성하고 검색용 라이브러리를 적용하는 과정을 마무리하였다.</p>

<h1 id="응용-기능">응용 기능</h1>
<p>기본 검색 기능에 더하여 키워드를 더 쉽게 찾고 검색 결과를 더 잘 표현하기 위해 개선한 사항이다.</p>

<h2 id="결과창-개선">결과창 개선</h2>

<p><img src="https://github.com/user-attachments/assets/2759e44c-1170-4c49-9e1a-297d646a8354" alt="image" style="border:black solid 0.5px; padding:10px;" /></p>

<p>이미지에 보듯 결과창에 추가한 내용은 다음과 같다.</p>

<ol>
  <li>검색어 하이라이트</li>
  <li>클릭시 본문 및 태그 페이지로 링크 연결</li>
  <li>본문 미리보기</li>
  <li>검색어가 언급된 횟수 표시</li>
  <li>아이콘과 함께 메타 정보 디스플레이
<br /></li>
</ol>

<p>이를 위해 <code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code> 함수의 <code class="language-plaintext highlighter-rouge">templateMiddleware</code>와 <code class="language-plaintext highlighter-rouge">searchResultTemplate</code> 인자를 활용할 것이다. 전자는 검색 결과가 있을 때 호출되는 함수이며 후자는 그 결과를 출력할 HTML 템플릿을 지정하는 인자다. 하나씩 짚어보도록 하겠다.<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">templateMiddleware</code> 인자는 다음과 같이 정의된 함수를 필요로 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">function </span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">template</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">prop</code>은 json의 key이고 <code class="language-plaintext highlighter-rouge">value</code>는 key에 대한 value를 의미한다. 이제 <code class="language-plaintext highlighter-rouge">prop</code>, 즉 ‘항목’에 따라 <code class="language-plaintext highlighter-rouge">value</code>를 처리할 것이다.</p>

<p><strong>URL</strong>과 <strong>날짜</strong> 항목은 json에 저장된 그대로 사용할 예정이기 때문에 바로 <code class="language-plaintext highlighter-rouge">value</code>를 반환하도록 했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">url</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">prop</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">date</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>나머지 <strong>제목, 태그, 본문</strong> 항목은 검색어 하이라이트를 적용하고 URL과 연결하는 작업이 필요하다.<br />
우선 검색어를 저장하고, 그것을 찾는 정규표현식 객체와 최종적으로 리턴될 변수를 선언한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">searchTerm</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">search-input</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RegExp</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">,</span> <span class="dl">"</span><span class="s2">gi</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">highlightedValue</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>제목</strong> 항목은 정규표현식 객체로 검색어(<code class="language-plaintext highlighter-rouge">$&amp;</code>)를 HTML 태그로 감싼다. 배경색깔을 바꾸고 폰트를 굵게 표시한다.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">title</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">highlightedValue</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="nx">regex</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;</span><span class="dl">'</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">highlightedValue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>태그</strong> 항목의 경우 <a href="https://woocosmos.github.io/tags/">태그 페이지</a>의 각 태그 링크와 연동했다.<br />
앞서 json을 생성하면서 쉼표로 join 했기 때문에 split하고 join하는 과정을 한번 더 거치는데, search.json을 개선해서 전처리를 간소화하는 대안도 고민해봐야겠다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">tags</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dest</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">origin</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">theTags</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="nx">tag</span> <span class="o">=&gt;</span> <span class="nx">tag</span><span class="p">.</span><span class="nf">trim</span><span class="p">());</span>
    
    <span class="nx">highlightedLinkedValue</span> <span class="o">=</span> <span class="nx">theTags</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">tag</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 하이라이트를 적용한다</span>
      <span class="kd">const</span> <span class="nx">highlightedTag</span> <span class="o">=</span> <span class="nx">tag</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="nx">regex</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;b style="background:gold"&gt;$&amp;&lt;/b&gt;</span><span class="dl">'</span><span class="p">);</span>
      <span class="c1">// 링크를 적용한다</span>
      <span class="k">return</span> <span class="s2">`&lt;a href="</span><span class="p">${</span><span class="nx">dest</span><span class="p">}</span><span class="s2">/tags/#</span><span class="p">${</span><span class="nx">tag</span><span class="p">}</span><span class="s2">"&gt;&lt;span&gt;</span><span class="p">${</span><span class="nx">highlightedTag</span><span class="p">}</span><span class="s2">&lt;/span&gt;&lt;/a&gt;`</span><span class="p">;</span>
    <span class="p">}).</span><span class="nf">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="nx">highlightedLinkedValue</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>마지막으로 <strong>본문</strong>을 보여주는 데 있어 두 가지 지점을 고려했다. 첫번째는 30개 단어까지 미리보기로 보여주는 것이고 두번째는 본문에서 match가 걸린 횟수를 명시하는 것이다.</p>

<p>첫번째 매치를 기준으로 앞뒤 15개 단어까지 슬라이스하였다. 본문에 매치가 없을 경우 처음부터 30개 단어를 가져온다. 마지막으로는 정규표현식 객체에 매치된 <code class="language-plaintext highlighter-rouge">matches</code>의 개수를 명시했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">\[</span><span class="sr">.*</span><span class="se">?\]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">matches</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="nx">regex</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">matchCnt</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">matches</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 띄어쓰기를 기준으로 토큰화한다</span>
    <span class="kd">const</span> <span class="nx">wordsArray</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">);</span>

    <span class="c1">// 검색된 단어를 기준으로 앞뒤 15개 토큰을 사용한다</span>
    <span class="kd">const</span> <span class="nx">matchIndex</span> <span class="o">=</span> <span class="nx">wordsArray</span><span class="p">.</span><span class="nf">findIndex</span><span class="p">(</span><span class="nx">word</span> <span class="o">=&gt;</span> <span class="nx">regex</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">word</span><span class="p">));</span>
    <span class="kd">const</span> <span class="nx">start</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">matchIndex</span> <span class="o">-</span> <span class="mi">15</span><span class="p">);</span> 
    <span class="kd">const</span> <span class="nx">end</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">wordsArray</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">matchIndex</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="kd">const</span> <span class="nx">truncatedValue</span> <span class="o">=</span> <span class="nx">wordsArray</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>

    <span class="c1">// 하이라이트를 적용한다</span>
    <span class="nx">highlightedValue</span> <span class="o">=</span> <span class="nx">truncatedValue</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span>
        <span class="nx">regex</span><span class="p">,</span>
        <span class="dl">'</span><span class="s1">&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;</span><span class="dl">'</span>
    <span class="p">);</span>
    <span class="nx">matchCnt</span> <span class="o">=</span> <span class="nx">matches</span><span class="p">.</span><span class="nx">length</span>

<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 본문에 검색어가 없을 경우 처음부터 30개 토큰을 가져온다</span>
    <span class="kd">const</span> <span class="nx">words</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">).</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">highlightedValue</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">words</span><span class="p">}</span><span class="s2">...`</span><span class="p">;</span>
    <span class="nx">matchCnt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="c1">// 언급수</span>
<span class="nx">highlightedValue</span> <span class="o">+=</span> <span class="s2">`&lt;div style="padding-top:5px"&gt;&lt;span id="match-counter"&gt;본문에 &lt;b&gt;</span><span class="p">${</span><span class="nx">matchCnt</span><span class="p">}</span><span class="s2">&lt;/b&gt;번 언급되었습니다&lt;/span&gt;&lt;/div&gt;`</span><span class="p">;</span>
<span class="k">return</span> <span class="nx">highlightedValue</span><span class="p">;</span>
</code></pre></div></div>
<p><br />
이렇게 처리된 결과물은 <code class="language-plaintext highlighter-rouge">searchResultTemplate</code>에 정의한 HTML 템플릿대로 디스플레이 된다. 이곳에서 Font Awesome(폰트 어썸) 태그를 정의하여 아이콘으로 영역을 시각적으로 구분했다. 그리고 제목과 본문을 클릭했을 때 본문으로 연결해주는 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 태그를 추가했다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">searchResultTemplate</span><span class="p">:</span> 
        <span class="dl">'</span><span class="s1">&lt;article&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;i class="fas fa-book fa-fw"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;{title}&lt;/a&gt;&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;i class="fas fa-clock fa-fw"&gt;&lt;/i&gt;&lt;span&gt;{date}&lt;/span&gt;&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;i class="fas fa-tag fa-fw"&gt;&lt;/i&gt;{tags}&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div style="display:inline-flex"&gt;</span><span class="dl">'</span> <span class="o">+</span> 
            <span class="dl">'</span><span class="s1">&lt;i class="fas fa-pencil-alt fa-fw" style="padding-top:5px"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;&lt;span style="color:#343a40"&gt;{content}&lt;/span&gt;&lt;/a&gt;</span><span class="dl">'</span> <span class="o">+</span> 
        <span class="dl">'</span><span class="s1">&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;/article&gt;</span><span class="dl">'</span>
</code></pre></div></div>

<p>참고로 아이콘을 불러오기 위해서는 search 폴더의 <strong><code class="language-plaintext highlighter-rouge">index.html</code>에 폰트 어썸 링크를 추가</strong>해주어야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"&gt;

</code></pre></div></div>

<h2 id="키워드-추천">키워드 추천</h2>

<p><img src="https://github.com/user-attachments/assets/5e9706e8-610d-44de-b117-90876070a57f" alt="image" style="border:black solid 0.5px; padding:10px;" /></p>

<p>유저에게 무슨 키워드를 검색할지 가이드를 제공해주는 것은 어떨까?<br />
포스트 본문을 데이터로 활용하여 <strong>키워드의 중요도를 집계하고 상위 n개 키워드를 추천</strong>하는 기능을 떠올렸다.</p>

<p>아이디어는 이렇다.</p>
<ol>
  <li>블로그 전체에서 제목과 본문 텍스트를 수집하여 전처리하고 키워드를 추출한다</li>
  <li>블로그 포스트 개수를 고려하여 키워드별 TF-IDF를 집계하고 상위 5개를 저장한다</li>
  <li>추천 키워드를 불러와 검색 페이지에서 띄워준다</li>
</ol>

<p>1~2번은 Python으로 실행하고 3번은 JavaScript로 구현하기로 했다.<br />
<br /></p>

<p><strong>데이터 수집과 처리</strong><br />
<code class="language-plaintext highlighter-rouge">{baseurl}/search.json</code> 주소로 json 파일에 접근할 수 있다는 점을 기억하고 <code class="language-plaintext highlighter-rouge">requests</code> 모듈로 불러왔다. 그리고 그 중에서 제목과 본문만 저장했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">collect_contents</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">pttrn</span><span class="p">,</span> <span class="n">noTag</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    url   : search.json
    pttrn : escape 기호 제외하기 위한 정규표현식
    noTag : 데이터 수집에서 제외할 태그
    </span><span class="sh">'''</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">cleansed_response</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="n">pttrn</span><span class="p">,</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">normalized_response</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">\s+</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">,</span> <span class="n">cleansed_response</span><span class="p">)</span>
    
    <span class="n">json_data</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">normalized_response</span><span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="p">[</span><span class="n">post</span><span class="p">[</span><span class="sh">'</span><span class="s">title</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">post</span><span class="p">[</span><span class="sh">'</span><span class="s">content</span><span class="sh">'</span><span class="p">]</span> <span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">json_data</span> <span class="k">if</span> <span class="n">noTag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">post</span><span class="p">[</span><span class="sh">'</span><span class="s">tags</span><span class="sh">'</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">contents</span>
</code></pre></div></div>

<p>수집한 데이터를 키워드 말뭉치 형태로 변환한다. 이때 영어와 한국어를 따로 추출하여 한 글자인 단어와 불용어 사전에 포함된 단어를 제외했다. 명사를 대상으로 하고 싶었기 때문에 <strong>한국어는 형태소 분석기를 사용하여 명사를 추출</strong>했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_corpus</span><span class="p">(</span><span class="n">contents</span><span class="p">):</span>
    <span class="c1"># eng_prc, kor_prc는 별도로 정의한 전처리 함수다
</span>    <span class="n">keywords_eng</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">eng_prc</span><span class="p">,</span> <span class="n">contents</span><span class="p">))</span>
    <span class="c1"># 한국어는 형태소 분석 후 명사만 사용된다
</span>    <span class="n">keywords_kor</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">kor_prc</span><span class="p">,</span> <span class="n">contents</span><span class="p">))</span>
    <span class="n">corpus</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">e</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">keywords_eng</span><span class="p">,</span> <span class="n">keywords_kor</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">corpus</span>
</code></pre></div></div>

<p>참고로 한국어 형태소 분석은 <code class="language-plaintext highlighter-rouge">konlpy</code>를 사용했다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">konlpy.tag</span> <span class="kn">import</span> <span class="n">Okt</span>

<span class="k">def</span> <span class="nf">kor_prc</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">okt</span> <span class="o">=</span> <span class="nc">Okt</span><span class="p">()</span>
    <span class="n">kor_res</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">okt</span><span class="p">.</span><span class="nf">nouns</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="nf">if </span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span><span class="p">):</span>
            <span class="n">kor_res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kor_res</span>
</code></pre></div></div>

<p>불용어 사전은 <a href="https://gist.github.com/sebleier/554280">NLTK’s list of english stopwords</a>와 <a href="https://www.public.asu.edu/~rjansen/latexdoc/ltx-2.html">Latex 문법 리스트</a>를 크롤링해서 <code class="language-plaintext highlighter-rouge">stopwords.txt</code> 파일로 구축하였다. 더불어 <em>span, div</em>와 같은 HTML 태그도 불용어 사전에 포함했다.<br />
<br /></p>

<p><strong>TF-IDF 계산</strong><br />
TF-IDF(Term Frequency-Inverse Document Frequency)는 <strong>문서 안에서의 출현 빈도수와 전체 문서 집합에서의 희귀성을 적용한 가중치</strong>이다. scikit-learn 의 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">TfidfVectorizer</a>을 사용해 계산했다. 여러 개 포스트를 올리는 블로그 특성 상 주요 키워드를 추출하는 데 TF-IDF가 적합하다고 생각하여 적용했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_keywords</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">topN</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">asset_dir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">vectorizer</span> <span class="o">=</span> <span class="nc">TfidfVectorizer</span><span class="p">()</span>
    <span class="n">tfidf_matrix</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>

    <span class="n">feature_names</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">.</span><span class="nf">get_feature_names_out</span><span class="p">()</span>
    <span class="c1"># 단어가 열, 문서가 행이므로 각 단어에 대해 문서 전반의 값을 sum
</span>    <span class="n">sum_tfidf_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">tfidf_matrix</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)).</span><span class="nf">flatten</span><span class="p">()</span>
    <span class="n">average_tfidf_score</span> <span class="o">=</span> <span class="n">sum_tfidf_scores</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">top_indices</span> <span class="o">=</span> <span class="n">sum_tfidf_scores</span><span class="p">.</span><span class="nf">argsort</span><span class="p">()[</span><span class="o">-</span><span class="n">topN</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">top_keywords</span> <span class="o">=</span> <span class="p">[[</span><span class="sh">'</span><span class="s">말뭉치 평균</span><span class="sh">'</span><span class="p">,</span> <span class="n">average_tfidf_score</span><span class="p">]]</span>
    <span class="n">top_keywords</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">feature_names</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="nf">round</span><span class="p">(</span><span class="n">sum_tfidf_scores</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">top_indices</span><span class="p">]</span>
    <span class="bp">...</span>
    <span class="c1"># 저장
</span>    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="n">json</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">top_keywords</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div></div>
<p>문서별로 단어의 TF-IDF 값이 계산되는데, 전체 블로그 관점에서 중요도를 고려해야 하므로 단어 단위로 총합 값을 계산했다. 또 추출된 키워드의 중요도를 상대적으로 비교할 수 있도록 전체 키워드의 평균 TF-IDF 값도 함께 저장했다.<br />
<br /></p>

<p><strong>추천 키워드 디스플레이</strong><br />
파이썬으로 계산한 결과는 <code class="language-plaintext highlighter-rouge">keywords.json</code> 이라는 이름으로 따로 저장했다. 첫번째 요소는 전체 말뭉치 평균이고, 그 아래부터 1위, 2위 … 5위에 해당한다. [키워드, 점수] 쌍의 리스트로 이루어져 있다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="err">'말뭉치</span><span class="w"> </span><span class="err">평균'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.05</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'클러스터'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.67</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'toc'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.42</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'포인트'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.38</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'편차'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.38</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'평균'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.33</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>이제 이것을 읽어 검색 페이지에서 보여주는 JavaScript를 작성한다. 해당 스크립트는 search 폴더의 <code class="language-plaintext highlighter-rouge">index.html</code> 에서 실행된다. 먼저 json을 읽어온 후 반복문으로 HTML 태그를 추가했다. 키워드를 클릭하면 바로 검색되도록 click 이벤트를 추가했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 미리 추출한 키워드 json 데이터를 불러온다</span>
<span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">keywords.json</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>
<span class="p">...</span>
<span class="c1">// 첫번째 요소는 전체 평균이므로 두번째 요소부터 반복문을 시행한다</span>
<span class="nx">data</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">rnk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">li</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">li</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">span</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 키워드를 읽어온다</span>
    <span class="nx">span</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="c1">// 클릭할 경우 해당 키워드를 search-input 입력창으로 전달한다</span>
    <span class="nx">span</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">const</span> <span class="nx">searchInput</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">search-input</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">searchInput</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

                    <span class="c1">// trigger</span>
                    <span class="kd">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">input</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">bubbles</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
                    <span class="nx">searchInput</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
                <span class="p">});</span>
    <span class="p">...</span>
</code></pre></div></div>
<p class="center"><img src="https://github.com/user-attachments/assets/5f04c3c4-89b7-4074-a014-4f4103eeddda" alt="image" style="border:black solid 0.5px; padding:10px;" class="center-image" />
클릭하면 검색창에 그 키워드가 입력되면서 검색 기능이 발동된다.</p>

<p>마지막으로 <em>이 키워드들이 왜 추천되는지</em> 도움말 팝업을 추가해보았다. 아이콘 위에 마우스를 호버하면 텍스트 설명이 뜨는 방식이다. 각 추천 키워드의 점수도 <code class="language-plaintext highlighter-rouge">obj[1]</code>으로 읽어올 수 있으므로 팝업 코드를 forEach문에 추가했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 도움말 아이콘 팝업</span>
<span class="kd">const</span> <span class="nx">svgIcon</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">svgIcon</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">`&lt;svg width="25" height="25" viewBox="0 0 16 16" 생략..&gt; &lt;/svg&gt;`</span><span class="p">;</span>
<span class="nx">paragraph</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">svgIcon</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">totalAvg</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">tooltip</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">tooltip</span><span class="p">.</span><span class="nx">className</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">tooltip</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">tooltip</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s2">`TF-IDF 점수를 기반으로 상위 5개 키워드를 추천합니다\n
                      현재 블로그의 전체 평균 TF-IDF는 </span><span class="p">${</span><span class="nx">totalAvg</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span><span class="s2">점입니다\n
                      추천 키워드에 마우스를 올려 점수를 비교해보세요`</span><span class="p">;</span>
<span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">whiteSpace</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">pre</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// '\n'이 적용되려면</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">tooltip</span><span class="p">);</span>

<span class="nx">svgIcon</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseenter</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">block</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageX</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageY</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">svgIcon</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageX</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageY</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">svgIcon</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseleave</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>자동화</strong><br />
끝으로 TF-IDF를 계산하는 파이썬 스크립트의 실행만 자동화하면 된다. 이 부분은 GitHub Actions로 처리했으며 <a href="https://woocosmos.github.io/github-action/">GitHub Actions 활용한 태스크 및 배포 자동화</a>에서 그 과정을 확인할 수 있다.</p>

<h1 id="기타">기타</h1>
<p>JS에서 실행할 수 있는 <a href="https://github.com/NOT2ho/notPOS_kr">한국어 토크나이저</a>도 있다. 사이트를 불러올 때마다 점수를 연산하기는 어려울 것 같아서 결국 python으로 구현했지만, 충분히 활용 가치가 있을 것 같아서 기록해둔다</p>]]></content><author><name></name></author><category term="JavaScript" /><category term="NLP" /><summary type="html"><![CDATA[요약 - simple-jekyll-search 라이브러리를 활용하여 검색 기능을 추가했다 - 탭에서 접근할 수 있는 검색 페이지를 구성하고 검색 결과를 적절하게 시각화했다 - TF-IDF 값을 활용하여 검색할 키워드를 추천했다 개요 Kiko Now Jekyll 테마에 검색 기능이 없는 관계로 직접 검색 페이지를 구성하고 JS 라이브러리로 검색 기능을 적용했다. 블로그에 포스트가 쌓일수록 검색 기능이 필수적이라고 생각했다. 태그 기반의 문서 분류 방식은 한계가 명확하고, 특정 문서를 찾을 때도 검색이 가장 간편하기 때문이다. 블로그 개발 과정은 특정 포스트에 아카이빙하고 있지만, 해당 기능은 분량이 많아 별도로 기록한다. 기본 기능 입력 키워드로 블로그 내 모든 컨텐츠에 대해 검색하는 기본 기능부터 적용한다. Simple-Jekyll-Search 라이브러리를 적용했다. 브라우저 단[Client-Side]에서 작동하기 때문에 별도 서버나 DB를 구축할 필요가 없다. 적용 과정 역시 간단하다. 첫째, search.json 생성 블로그의 root 위치에 아래 search.json 파일을 만든다. --- layout: none --- [ {% for post in site.posts %} { "title" : "{{ post.title | escape }}", "tags" : "{{ post.tags | join: ', ' }}", "date" : "{{ post.date | date: '%Y.%m.%d'}}", "url" : "{{ site.url }}{{ post.url }}", "content": "{{ post.content | strip_html | strip_newlines | escape }}" } {% unless forloop.last %},{% endunless %} {% endfor %} ] 기존 코드에 post.content 를 추가하여 본문 텍스트도 가져오게 했다. 이때 strip_html 등 몇 가지 Jekyll 문법을 더했다. 이를 통해 {baseurl}/search.json 주소로 json 파일에 접근할 수 있다. 브라우저로부터 이 파일을 읽어와 검색 데이터로 활용할 것이다. 둘째, JavaSript 소스 추가 simple-jekyll-search.js를 다운 받아 어디든 위치시킨다. 이 스크립트는 search.json으로부터 데이터를 읽어와 입력어에 매칭되는 내용을 찾는 함수 SimpleJekyllSearch를 정의하고 있다. 그 다음 search-and-return.js도 다운 받아 같은 위치에 붙여넣는다. SimpleJekyllSearch 함수를 실행시켜서 결과값을 받아와 처리하는 부분을 별도 스크립트로 작성한 것이다. var sjs = SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('results-container'), json: '/search.json', searchResultTemplate: ... noResultsText: '😴 검색 결과가 없습니다', templateMiddleware : ... )} 나는 assets 라는 폴더를 만들어 이곳에 JS 소스를 모아두기로 했다. 두 스크립트는 다음 서술할 검색 페이지에서 실행시킬 것이다. 셋째, 검색 페이지 구성 root 위치에 search 폴더를 생성하고 그 아래 index.html 파일을 생성한다. 앞서 추가한 JS 스크립트가 실행되면서 검색어 입출력이 진행되는 곳이다. --- layout: page permalink: /search --- &lt;ul class="search"&gt; &lt;div id="search-container"&gt; &lt;input type="search" id="search-input" placeholder=" 🤔 검색어를 입력하세요."&gt; &lt;ul id="results-container"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/ul&gt; &lt;script src="{{ site.baseurl }}/assets/simple-jekyll-search.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="{{ site.baseurl }}/assets/search-and-return.js" type="text/javascript"&gt;&lt;/script&gt; 이렇게 {baseurl}/search 주소로 접근할 수 있는 검색 페이지를 완성하였다. 한편, 무엇을 클릭했을 때 이 검색 페이지로 연결되도록 할 것인가? 나는 상단의 탭에 돋보기 아이콘을 추가했다. 이를 위해 돋보기 아이콘 svg와 검색 페이지를 연결하여 _includes/nav.html에 추가했다. &lt;ul class="search-icon"&gt; &lt;a href="{{ site.baseurl }}/search"&gt; &lt;svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"&gt; &lt;path d="M10 ...생략" fill="currentColor"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/a&gt; &lt;/ul&gt; 이렇게 검색 페이지를 구성하고 검색용 라이브러리를 적용하는 과정을 마무리하였다. 응용 기능 기본 검색 기능에 더하여 키워드를 더 쉽게 찾고 검색 결과를 더 잘 표현하기 위해 개선한 사항이다. 결과창 개선 이미지에 보듯 결과창에 추가한 내용은 다음과 같다. 검색어 하이라이트 클릭시 본문 및 태그 페이지로 링크 연결 본문 미리보기 검색어가 언급된 횟수 표시 아이콘과 함께 메타 정보 디스플레이 이를 위해 SimpleJekyllSearch 함수의 templateMiddleware와 searchResultTemplate 인자를 활용할 것이다. 전자는 검색 결과가 있을 때 호출되는 함수이며 후자는 그 결과를 출력할 HTML 템플릿을 지정하는 인자다. 하나씩 짚어보도록 하겠다. templateMiddleware 인자는 다음과 같이 정의된 함수를 필요로 한다. function (prop, value, template) { return value } prop은 json의 key이고 value는 key에 대한 value를 의미한다. 이제 prop, 즉 ‘항목’에 따라 value를 처리할 것이다. URL과 날짜 항목은 json에 저장된 그대로 사용할 예정이기 때문에 바로 value를 반환하도록 했다. if (prop === "url" || prop === 'date') { return value; } 나머지 제목, 태그, 본문 항목은 검색어 하이라이트를 적용하고 URL과 연결하는 작업이 필요하다. 우선 검색어를 저장하고, 그것을 찾는 정규표현식 객체와 최종적으로 리턴될 변수를 선언한다. const searchTerm = document.getElementById("search-input").value; const regex = new RegExp(searchTerm, "gi"); let highlightedValue; 제목 항목은 정규표현식 객체로 검색어($&amp;)를 HTML 태그로 감싼다. 배경색깔을 바꾸고 폰트를 굵게 표시한다. if (prop === 'title') { highlightedValue = value.replace(regex, '&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;') return highlightedValue; } 태그 항목의 경우 태그 페이지의 각 태그 링크와 연동했다. 앞서 json을 생성하면서 쉼표로 join 했기 때문에 split하고 join하는 과정을 한번 더 거치는데, search.json을 개선해서 전처리를 간소화하는 대안도 고민해봐야겠다. if (prop === 'tags') { const dest = window.location.origin; const theTags = value.split(', ').map(tag =&gt; tag.trim()); highlightedLinkedValue = theTags.map(tag =&gt; { // 하이라이트를 적용한다 const highlightedTag = tag.replace(regex, '&lt;b style="background:gold"&gt;$&amp;&lt;/b&gt;'); // 링크를 적용한다 return `&lt;a href="${dest}/tags/#${tag}"&gt;&lt;span&gt;${highlightedTag}&lt;/span&gt;&lt;/a&gt;`; }).join(', '); return highlightedLinkedValue; } 마지막으로 본문을 보여주는 데 있어 두 가지 지점을 고려했다. 첫번째는 30개 단어까지 미리보기로 보여주는 것이고 두번째는 본문에서 match가 걸린 횟수를 명시하는 것이다. 첫번째 매치를 기준으로 앞뒤 15개 단어까지 슬라이스하였다. 본문에 매치가 없을 경우 처음부터 30개 단어를 가져온다. 마지막으로는 정규표현식 객체에 매치된 matches의 개수를 명시했다. value = value.replace(/\[.*?\]/g, ''); const matches = value.match(regex); let matchCnt; if (matches) { // 띄어쓰기를 기준으로 토큰화한다 const wordsArray = value.split(/\s+/); // 검색된 단어를 기준으로 앞뒤 15개 토큰을 사용한다 const matchIndex = wordsArray.findIndex(word =&gt; regex.test(word)); const start = Math.max(0, matchIndex - 15); const end = Math.min(wordsArray.length, matchIndex + 15 + 1); const truncatedValue = wordsArray.slice(start, end).join(" "); // 하이라이트를 적용한다 highlightedValue = truncatedValue.replace( regex, '&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;' ); matchCnt = matches.length } else { // 본문에 검색어가 없을 경우 처음부터 30개 토큰을 가져온다 const words = value.split(/\s+/).slice(0, 30).join(" "); highlightedValue = `${words}...`; matchCnt = 0 } // 언급수 highlightedValue += `&lt;div style="padding-top:5px"&gt;&lt;span id="match-counter"&gt;본문에 &lt;b&gt;${matchCnt}&lt;/b&gt;번 언급되었습니다&lt;/span&gt;&lt;/div&gt;`; return highlightedValue; 이렇게 처리된 결과물은 searchResultTemplate에 정의한 HTML 템플릿대로 디스플레이 된다. 이곳에서 Font Awesome(폰트 어썸) 태그를 정의하여 아이콘으로 영역을 시각적으로 구분했다. 그리고 제목과 본문을 클릭했을 때 본문으로 연결해주는 &lt;a&gt; 태그를 추가했다 searchResultTemplate: '&lt;article&gt;'+ '&lt;div&gt;&lt;i class="fas fa-book fa-fw"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;{title}&lt;/a&gt;&lt;/div&gt;'+ '&lt;div&gt;&lt;i class="fas fa-clock fa-fw"&gt;&lt;/i&gt;&lt;span&gt;{date}&lt;/span&gt;&lt;/div&gt;'+ '&lt;div&gt;&lt;i class="fas fa-tag fa-fw"&gt;&lt;/i&gt;{tags}&lt;/div&gt;'+ '&lt;div style="display:inline-flex"&gt;' + '&lt;i class="fas fa-pencil-alt fa-fw" style="padding-top:5px"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;&lt;span style="color:#343a40"&gt;{content}&lt;/span&gt;&lt;/a&gt;' + '&lt;/div&gt;'+ '&lt;/article&gt;' 참고로 아이콘을 불러오기 위해서는 search 폴더의 index.html에 폰트 어썸 링크를 추가해주어야 한다. &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"&gt; 키워드 추천 유저에게 무슨 키워드를 검색할지 가이드를 제공해주는 것은 어떨까? 포스트 본문을 데이터로 활용하여 키워드의 중요도를 집계하고 상위 n개 키워드를 추천하는 기능을 떠올렸다. 아이디어는 이렇다. 블로그 전체에서 제목과 본문 텍스트를 수집하여 전처리하고 키워드를 추출한다 블로그 포스트 개수를 고려하여 키워드별 TF-IDF를 집계하고 상위 5개를 저장한다 추천 키워드를 불러와 검색 페이지에서 띄워준다 1~2번은 Python으로 실행하고 3번은 JavaScript로 구현하기로 했다. 데이터 수집과 처리 {baseurl}/search.json 주소로 json 파일에 접근할 수 있다는 점을 기억하고 requests 모듈로 불러왔다. 그리고 그 중에서 제목과 본문만 저장했다. def collect_contents(url, pttrn, noTag): ''' url : search.json pttrn : escape 기호 제외하기 위한 정규표현식 noTag : 데이터 수집에서 제외할 태그 ''' response = requests.get(url, verify=False) cleansed_response = re.sub(pttrn, ' ', response.text) normalized_response = re.sub(r'\s+', ' ', cleansed_response) json_data = json.loads(normalized_response) contents = [post['title'] + ' ' + post['content'] for post in json_data if noTag not in post['tags']] return contents 수집한 데이터를 키워드 말뭉치 형태로 변환한다. 이때 영어와 한국어를 따로 추출하여 한 글자인 단어와 불용어 사전에 포함된 단어를 제외했다. 명사를 대상으로 하고 싶었기 때문에 한국어는 형태소 분석기를 사용하여 명사를 추출했다. def create_corpus(contents): # eng_prc, kor_prc는 별도로 정의한 전처리 함수다 keywords_eng = list(map(eng_prc, contents)) # 한국어는 형태소 분석 후 명사만 사용된다 keywords_kor = list(map(kor_prc, contents)) corpus = [' '.join(e+k) for e, k in zip(keywords_eng, keywords_kor)] return corpus 참고로 한국어 형태소 분석은 konlpy를 사용했다. from konlpy.tag import Okt def kor_prc(c): okt = Okt() kor_res =[] for k in okt.nouns(c): if (len(k) &gt; 1) &amp; (k not in stop_words): kor_res.append(k) return kor_res 불용어 사전은 NLTK’s list of english stopwords와 Latex 문법 리스트를 크롤링해서 stopwords.txt 파일로 구축하였다. 더불어 span, div와 같은 HTML 태그도 불용어 사전에 포함했다. TF-IDF 계산 TF-IDF(Term Frequency-Inverse Document Frequency)는 문서 안에서의 출현 빈도수와 전체 문서 집합에서의 희귀성을 적용한 가중치이다. scikit-learn 의 TfidfVectorizer을 사용해 계산했다. 여러 개 포스트를 올리는 블로그 특성 상 주요 키워드를 추출하는 데 TF-IDF가 적합하다고 생각하여 적용했다. def extract_keywords(corpus, topN=5, asset_dir=None): vectorizer = TfidfVectorizer() tfidf_matrix = vectorizer.fit_transform(corpus) feature_names = vectorizer.get_feature_names_out() # 단어가 열, 문서가 행이므로 각 단어에 대해 문서 전반의 값을 sum sum_tfidf_scores = np.array(tfidf_matrix.sum(axis=0)).flatten() average_tfidf_score = sum_tfidf_scores.mean().round(2) top_indices = sum_tfidf_scores.argsort()[-topN:][::-1] top_keywords = [['말뭉치 평균', average_tfidf_score]] top_keywords += [[feature_names[idx], round(sum_tfidf_scores[idx], 2)] for idx in top_indices] ... # 저장 with open(save_path, 'w') as f: json.dump(top_keywords, f) 문서별로 단어의 TF-IDF 값이 계산되는데, 전체 블로그 관점에서 중요도를 고려해야 하므로 단어 단위로 총합 값을 계산했다. 또 추출된 키워드의 중요도를 상대적으로 비교할 수 있도록 전체 키워드의 평균 TF-IDF 값도 함께 저장했다. 추천 키워드 디스플레이 파이썬으로 계산한 결과는 keywords.json 이라는 이름으로 따로 저장했다. 첫번째 요소는 전체 말뭉치 평균이고, 그 아래부터 1위, 2위 … 5위에 해당한다. [키워드, 점수] 쌍의 리스트로 이루어져 있다. [['말뭉치 평균', 0.05], ['클러스터', 0.67], ['toc', 0.42], ['포인트', 0.38], ['편차', 0.38], ['평균', 0.33]] 이제 이것을 읽어 검색 페이지에서 보여주는 JavaScript를 작성한다. 해당 스크립트는 search 폴더의 index.html 에서 실행된다. 먼저 json을 읽어온 후 반복문으로 HTML 태그를 추가했다. 키워드를 클릭하면 바로 검색되도록 click 이벤트를 추가했다. // 미리 추출한 키워드 json 데이터를 불러온다 const response = await fetch('keywords.json'); const data = await response.json(); ... // 첫번째 요소는 전체 평균이므로 두번째 요소부터 반복문을 시행한다 data.slice(1).forEach((obj, rnk) =&gt; { const li = document.createElement('li'); const span = document.createElement('span'); // 키워드를 읽어온다 span.textContent = obj[0]; // 클릭할 경우 해당 키워드를 search-input 입력창으로 전달한다 span.addEventListener('click', function(event) { const searchInput = document.getElementById('search-input'); searchInput.value = obj[0]; // trigger const e = new Event('input', { bubbles: true }); searchInput.dispatchEvent(e); }); ... 클릭하면 검색창에 그 키워드가 입력되면서 검색 기능이 발동된다. 마지막으로 이 키워드들이 왜 추천되는지 도움말 팝업을 추가해보았다. 아이콘 위에 마우스를 호버하면 텍스트 설명이 뜨는 방식이다. 각 추천 키워드의 점수도 obj[1]으로 읽어올 수 있으므로 팝업 코드를 forEach문에 추가했다. // 도움말 아이콘 팝업 const svgIcon = document.createElement('span') svgIcon.innerHTML = `&lt;svg width="25" height="25" viewBox="0 0 16 16" 생략..&gt; &lt;/svg&gt;`; paragraph.appendChild(svgIcon); const totalAvg = data[0] const tooltip = document.createElement('div'); tooltip.className = 'tooltip'; tooltip.textContent = `TF-IDF 점수를 기반으로 상위 5개 키워드를 추천합니다\n 현재 블로그의 전체 평균 TF-IDF는 ${totalAvg[1]}점입니다\n 추천 키워드에 마우스를 올려 점수를 비교해보세요`; tooltip.style.whiteSpace = 'pre'; // '\n'이 적용되려면 document.body.appendChild(tooltip); svgIcon.addEventListener('mouseenter', (event) =&gt; { tooltip.style.display = 'block'; tooltip.style.left = `${event.pageX + 10}px`; tooltip.style.top = `${event.pageY + 10}px`; }); svgIcon.addEventListener('mousemove', (event) =&gt; { tooltip.style.left = `${event.pageX + 10}px`; tooltip.style.top = `${event.pageY + 10}px`; }); svgIcon.addEventListener('mouseleave', () =&gt; { tooltip.style.display = 'none'; }); 자동화 끝으로 TF-IDF를 계산하는 파이썬 스크립트의 실행만 자동화하면 된다. 이 부분은 GitHub Actions로 처리했으며 GitHub Actions 활용한 태스크 및 배포 자동화에서 그 과정을 확인할 수 있다. 기타 JS에서 실행할 수 있는 한국어 토크나이저도 있다. 사이트를 불러올 때마다 점수를 연산하기는 어려울 것 같아서 결국 python으로 구현했지만, 충분히 활용 가치가 있을 것 같아서 기록해둔다]]></summary></entry><entry><title type="html">수학, 통계 개념 모음집</title><link href="http://woocosmos.github.io/basic-statistics/" rel="alternate" type="text/html" title="수학, 통계 개념 모음집" /><published>2024-08-21T00:00:00+00:00</published><updated>2024-08-21T00:00:00+00:00</updated><id>http://woocosmos.github.io/basic-statistics</id><content type="html" xml:base="http://woocosmos.github.io/basic-statistics/"><![CDATA[<p>수학 및 통계 용어와 수식을 정의하고 ML 관점에서의 직관을 서술한다.</p>

<h1 id="평균-분산-표준편차">평균, 분산, 표준편차</h1>

\[\bar{x} = \frac{x_{1}+ x_{2} + \dots +x_{n}}{n}\]

<p>데이터 값을 모두 더한 다음(sum), 값의 개수(데이터 사이즈)로 나눈다 👉 <mark>평균</mark></p>
<blockquote>
  <p>데이터 포인트들의 대표값</p>
</blockquote>

<p><br /></p>

\[\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}\]

<dl>
  <dt>편차</dt>
  <dd>데이터별로 평균과의 차이를 구한다. 이때 <strong>편차의 총합은 $0$</strong>이다.</dd>
</dl>

\[\begin{aligned}
&amp; (x_{1}-m) + (x_{2}-m) + \dots + (x_{n}-m) \\
&amp; = (x_{1}+x_{2}+\dots+x_{n}) - n \times m \\
&amp; = n \times m - n \times m \\
&amp; = 0
\end{aligned}\]

<dl>
  <dt>편차제곱</dt>
  <dd>편차별로 제곱한다(squared deviations)</dd>
  <dt>편차제곱의 평균</dt>
  <dd>편차제곱을 모두 더한 다음(제곱합, sum of squares), 값의 개수로 나눈다<br />
👉 <mark>분산</mark></dd>
</dl>

<blockquote>
  <p>데이터 포인트들이 평균으로부터 얼마나 퍼져 있는지, 얼마나 벗어나 있는지 의미한다</p>
</blockquote>

<blockquote>
  <p><strong>High Variance</strong>: 분산이 큰 데이터로 학습된 모델은 입력값이 조금만 변화해도 민감하게 반응하여 출력값이 크게 바뀌기 때문에 예측의 안정성이 떨어진다</p>
</blockquote>

<p><br /></p>

\[\sqrt{\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}}\]

<p>분산의 제곱근 👉 <mark>표준편차</mark></p>
<blockquote>
  <p>제곱된 값에 루트를 씌움으로써 원래 데이터의 스케일(단위)에 맞추고 해석을 직관적으로 만든다</p>
</blockquote>

<h1 id="norm">Norm</h1>
<p><strong>벡터의 크기(길이)</strong></p>
<ul>
  <li>$p$는 Norm의 차수를 의미한다.</li>
</ul>

<h2 id="l1-norm-맨해튼-거리">L1 Norm (맨해튼 거리)</h2>
<p>내용</p>

<h2 id="l2-norm-유클리드-거리">L2 Norm (유클리드 거리)</h2>

\[\sqrt{\sum_{i=1} |x_{i}|^{2}}\]

<p>$p=2$ 인 Norm. 피타고라스 정리를 기반으로 n차원 좌표 평면(유클리드 공간)에서의 크기를 계산한다.</p>

<blockquote>
  <p>활용 : L2 정규화, KNN 알고리즘, K-means 알고리즘</p>
</blockquote>

<p><br /></p>

<h1 id="수학">수학</h1>
<h2 id="집합">집합</h2>
<p><strong>단조 감소(monotonically decreasing)</strong><br />
\(\lim_{x\to\infty} A_{n} = \cap_{n=1}^{\infty}A_{n}\)</p>

<p>집합이 갈수록 작아져서 모든 집합 $A$들의 교집합이 가장 작은 집합과 같아지는 것이다.</p>
<blockquote>
  <p>K-Means 알고리즘의 목적함수[WCSS]는 단조 감소한다</p>
</blockquote>

<h2 id="용어집">용어집</h2>
<dl>
  <dt>identity</dt>
  <dd>항등식. 언제나 성립하는 등식. 좌변과 우변의 값이 항상 같다.</dd>
</dl>]]></content><author><name></name></author><category term="수학" /><category term="통계" /><summary type="html"><![CDATA[수학 및 통계 용어와 수식을 정의하고 ML 관점에서의 직관을 서술한다. 평균, 분산, 표준편차 \[\bar{x} = \frac{x_{1}+ x_{2} + \dots +x_{n}}{n}\] 데이터 값을 모두 더한 다음(sum), 값의 개수(데이터 사이즈)로 나눈다 👉 평균 데이터 포인트들의 대표값 \[\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}\] 편차 데이터별로 평균과의 차이를 구한다. 이때 편차의 총합은 $0$이다. \[\begin{aligned} &amp; (x_{1}-m) + (x_{2}-m) + \dots + (x_{n}-m) \\ &amp; = (x_{1}+x_{2}+\dots+x_{n}) - n \times m \\ &amp; = n \times m - n \times m \\ &amp; = 0 \end{aligned}\] 편차제곱 편차별로 제곱한다(squared deviations) 편차제곱의 평균 편차제곱을 모두 더한 다음(제곱합, sum of squares), 값의 개수로 나눈다 👉 분산 데이터 포인트들이 평균으로부터 얼마나 퍼져 있는지, 얼마나 벗어나 있는지 의미한다 High Variance: 분산이 큰 데이터로 학습된 모델은 입력값이 조금만 변화해도 민감하게 반응하여 출력값이 크게 바뀌기 때문에 예측의 안정성이 떨어진다 \[\sqrt{\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}}\] 분산의 제곱근 👉 표준편차 제곱된 값에 루트를 씌움으로써 원래 데이터의 스케일(단위)에 맞추고 해석을 직관적으로 만든다 Norm 벡터의 크기(길이) $p$는 Norm의 차수를 의미한다. L1 Norm (맨해튼 거리) 내용 L2 Norm (유클리드 거리) \[\sqrt{\sum_{i=1} |x_{i}|^{2}}\] $p=2$ 인 Norm. 피타고라스 정리를 기반으로 n차원 좌표 평면(유클리드 공간)에서의 크기를 계산한다. 활용 : L2 정규화, KNN 알고리즘, K-means 알고리즘 수학 집합 단조 감소(monotonically decreasing) \(\lim_{x\to\infty} A_{n} = \cap_{n=1}^{\infty}A_{n}\) 집합이 갈수록 작아져서 모든 집합 $A$들의 교집합이 가장 작은 집합과 같아지는 것이다. K-Means 알고리즘의 목적함수[WCSS]는 단조 감소한다 용어집 identity 항등식. 언제나 성립하는 등식. 좌변과 우변의 값이 항상 같다.]]></summary></entry><entry><title type="html">K-Means Clustering 군집화 알고리즘</title><link href="http://woocosmos.github.io/kmeans-algo/" rel="alternate" type="text/html" title="K-Means Clustering 군집화 알고리즘" /><published>2024-08-20T00:00:00+00:00</published><updated>2024-08-20T00:00:00+00:00</updated><id>http://woocosmos.github.io/kmeans-algo</id><content type="html" xml:base="http://woocosmos.github.io/kmeans-algo/"><![CDATA[<p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- K-Means 클러스터링 알고리즘은 클러스터 내 분산을 최소화함으로써 가까운 데이터끼리 클러스터를 형성하는 비지도 학습 모델이다
- 분산을 전반적으로 충분히 감소시키면서 데이터 포인트를 유의미하게 그룹화하는 클러스터 개수를 찾는다
- 중심점을 세팅하는 초기화 방법론을 적용한 후, 클러스터 할당과 중심점 업데이트를 반복하며 최적화한다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p>데이터 분석 업무를 하다보면 유저 그룹별로 특징을 비교하고 싶을 때가 있다. 그렇다면 유저 그룹은 어떤 기준으로 나눠야 하고 각 유저를 어느 그룹으로 분류할 수 있을까? 이런 문제를 만났을 때 곧잘 사용한 것이 <strong>K-means 클러스터링 알고리즘</strong>이다.<br />
그런데 데이터 특성이나 하이퍼파라미터, 최적화 알고리즘 등 다양한 변수에 따라 상이한 군집화 결과가 나오기도 했고, 분석을 진행하기 앞서 군집화가 제대로 이루어지긴 한 건지 긴가민가할 때도 있었다.</p>

<p>따라서 이번 포스팅에서는 K-means 알고리즘의 정의와 원리를 수식과 함께 이해하고 코드로 그 내용을 구현한다. 용어의 통일성을 위해 앞으로 <em>군집(화)</em> 는 <em>클러스터(링)</em> 으로 표현하겠다.</p>

<h1 id="정의">정의</h1>

<p>K-means 알고리즘은 <strong>데이터를 $k$개의 클러스터로 묶는 클러스터링 알고리즘</strong>으로, 비지도 학습 방식에 속한다. 학습은 <strong>클러스터 내 분산을 최소화</strong>하는 방식으로 수행된다.</p>

<p>따라서 클러스터는 가까운 데이터들이 모인 그룹을 뜻한다.</p>

<h1 id="목적">목적</h1>

<p><strong>클러스터 내 제곱합(within-cluster sum of squares, WCSS)을 최소화하는 $k$개 집합 $S$을 찾는 것</strong>이 목적이다. 목적함수는 아래와 같다.</p>

\[\mathop{\operatorname{arg\,min}}_{\mathbf{S}} \sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\]

<dl>
  <dt>${\operatorname{arg\,min}}_{\mathbf{S}}$</dt>
  <dd>주어진 식을 최소화하는 $S$</dd>
  <dt>${\mu}_{i}$</dt>
  <dd>$S_i$에 속한 포인트들의 평균<sub>mean</sub> (또는 중앙값<sub>median</sub>)<br /></dd>
  <dt>$||…||$</dt>
  <dd>편차를 L2 Norm (유클리드 거리) 으로 계산</dd>
</dl>

<p>$k$개 클러스터별 ‘데이터 포인트들과 평균의 차이를 제곱하여 합산한 값(<em>=편차제곱합</em>)’의 합을 의미한다. 분산이 편차제곱의 평균이라는 점을 상기한다면, 이 값은 클러스터의 분산에 클러스터의 사이즈를 곱한 것과 같다는 것을 알 수 있다.</p>

\[\mathop{\operatorname{arg\,min}}_{\mathbf{S}} \sum_{i=1}^{k} |S_{i}| \operatorname{Var}(S_{i})\]

<dl>
  <dt>$|S_i|$</dt>
  <dd>$S_i$의 크기, 즉 해당 클러스터에 속한 포인트의 개수</dd>
  <dt>$\operatorname{Var}(S_{i})$</dt>
  <dd>$S_i$의 분산, 즉 해당 클러스터에 속한 포인트들의 분산</dd>
</dl>

<p>따라서 $k$개 클러스터별 ‘크기와 분산을 곱한 값(Product)’의 합으로도 표현할 수 있다. 직관적으로는 클러스터의 크기가 가중치로 작용하여 클러스터가 클수록 합산값에 기여한다고 볼 수 있으며, 클러스터들의 전반적인 분산합을 최소화해야 한다는 점에서 K-Means 알고리즘의 목적과 동일하다.</p>

<h2 id="계산-효율성">계산 효율성</h2>

<p>K-Means 알고리즘의 정의로 돌아와 <strong>클러스터 내 분산</strong>이라는 키워드를 다시 생각해보자. 앞서 목적함수에서는 ‘데이터 포인트($x$)와 중심점($\mu$) 간의 거리’로 이를 계산했다. 하지만 초점을 ‘데이터 포인트들($x, y$) 간의 거리’로 옮겨보는 건 어떨까?</p>

<p>즉 K-Means 알고리즘은 $k$개 클러스터별 ‘데이터 쌍별 편차제곱(pairwise squared deviations)의 평균’들의 합을 최소화하는 것과도 동일하다. 한 클러스터 안에서 데이터 포인트로 만들 수 있는 모든 조합에 대해 편차를 계산하고, 이 포인트들이 평균적으로 얼마나 퍼져 있는지 나타낸 식이다.</p>

\[{\operatorname{arg\,min}}_{\mathbf{S}} \sum_{i=1}^{k} \frac{1}{ |S_{i}| }\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - \mathbf{y}\right\|^{2}\]

<p>한편 아래 항등식(identity)에 따르면 ‘데이터 쌍별 편차제곱합’은 ‘데이터 포인트들과 평균 $c_{i}$의 편차를 제곱하여 합산한 값(<em>=편차제곱합</em>)에 클러스터 사이즈의 $2$배를 곱한 것’과 동일하다.</p>

\[\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - \mathbf{y}\right\|^{2}=2|S_{i}|\sum_{\mathbf{x} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2}\]

<p>이러한 계산 구조를 활용하여 <strong>클러스터의 모든 조합에 대해 연산을 수행하지 않고도 분산을 효율적이고 간단하게 계산</strong>할 수 있다. 유도 과정은 아래와 같다.</p>

<p><a href="https://woocosmos.github.io/basic-statistics/#%ED%8F%89%EA%B7%A0-%EB%B6%84%EC%82%B0-%ED%91%9C%EC%A4%80%ED%8E%B8%EC%B0%A8">편차의 총합은 $0$</a>이기 때문에 중간의 내적항은 사라진다.</p>

\[\begin{aligned}
\left\|\mathbf{x} - \mathbf{y}\right\|^{2} 
&amp; = \left\|\mathbf{x} - {c}_{i} + {c}_{i} - \mathbf{y}\right\|^2 \\
&amp; = \left\|\mathbf{x} - {c}_{i}\right\|^{2} -2 (\mathbf{x} - {c}_{i}) \cdot (\mathbf{y} - {c}_{i}) + \left\|\mathbf{y} - {c}_{i}\right\|^{2} \\
&amp; = \left\|\mathbf{x} - {c}_{i}\right\|^{2} + \left\|\mathbf{y} - {c}_{i}\right\|^{2}
\end{aligned}\]

<p>이렇게 유도된 식에 원래대로 $\sum$을 적용한다면,</p>

\[\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - \mathbf{y}\right\|^{2} 
 = \sum_{\mathbf{x,y} \in S_{i}} (\left\|\mathbf{x} - {c}_{i}\right\|^{2} + \left\|\mathbf{y} - {c}_{i}\right\|^{2})\]

<p>모든 점 $x$, $y$에 대해서 합산하기 때문에 $x$, $y$ 각각 두 겹의 $\sum$으로 표현할 수 있으며, $c$는 상수이기 때문에 $\sum$는 $|S|$의 곱셉으로 변환할 수 있다.</p>

\[\begin{aligned}
\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2}
&amp; = \sum_{\mathbf{x} \in S_{i}}\ \sum_{\mathbf{y} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2} \\
&amp; = |S_{i}| \sum_{\mathbf{x} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2} 
\end{aligned}\]

<p>마지막으로 $\sum_{\mathbf{x,y} \in S_{i}}\left|\mathbf{y} - {c}_{i}\right|^{2}$ 에 대해서도 동일하게 유도할 수 있으므로 $2$배가 된다.</p>

\[2|S_{i}|\sum_{\mathbf{x} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2}\]

<h2 id="최적화">최적화</h2>
<p>이제 이 목적함수를 <strong>최적화하는 방식</strong>을 알아볼 것이다. 처음 초기화된 식은 아래 두 동작을 반복하며 클러스터 내 제곱합(WCSS)을 감소시킨다.</p>

<ol>
  <li><strong>Assignment</strong> : 각 데이터 포인트에 가장 가까운 클러스터를 할당하기</li>
  <li><strong>Update</strong> : 각 클러스터에 할당된 데이터 포인트들의 평균값을 계산하여 새로운 클러스터의 중심을 업데이트하기</li>
</ol>

<p>이 과정을 반복할 때마다(iteration) 클러스터 내 제곱합은 <strong>항상 감소</strong>한다. 업데이트를 거듭할수록 데이터 포인트들은 점점 더 클러스터의 중심에 가까워지고 클러스터의 크기는 더 작아지기 때문이다. 이러한 <a href="https://woocosmos.github.io/basic-statistics/#%EC%A7%91%ED%95%A9">단조 감소(monotone decreasing)</a>의 성질로 인해 K-Means 알고리즘은 수렴이 가능한 식이다. 다만 ‘현재 상태에서’ 가장 가까운 클러스터를 할당하는 탐욕적(greedy) 방식으로 진행되기 때문에 지역 최적해(local optimum)에 수렴하기 쉽다.</p>

<h2 id="초기화">초기화</h2>
<p>업데이트에 앞서 <strong>중심점을 지정하는 초기화 단계</strong>를 거쳐야 한다. 적절하지 않은 중심점에서 시작할 경우 지역 최적해에 빠져버릴 수 있기 때문에 알맞은 초기화 기법을 선택하는 것이 좋다.</p>

<ul>
  <li><strong>무작위 분할(Random Partition)</strong> : 모든 데이터 포인터를 $k$개 클러스터 중 하나로 임의 할당한다</li>
  <li><strong>Forgy 알고리즘</strong> : 데이터 포인터 중 $k$개를 임의로 선택하고 이들을 중심점으로 사용한다
    <ul>
      <li>두 최적화 기법은 중심점을 임의로 설정하기 때문에 결과가 매번 달라질 수 있다는 단점이 있다</li>
    </ul>
  </li>
  <li><strong>K-means++</strong> : 기존 초기화 기법의 한계를 커버하기 위해, 거리가 가중치로 적용된 확률을 기반으로 중심점을 찾는다
    <ul>
      <li>데이터 포인트 중 $1$개를 임의로 선택하고 이를 첫번째 클러스터의 중심점 $c_{1}$으로 사용한다</li>
      <li>나머지 데이터 포인트에 대해서 첫번째 클러스터의 중심점까지의 거리 제곱합을 계산한다</li>
    </ul>

\[d(x_{i}, c_{1})^2\]

    <ul>
      <li>나머지 데이터 포인트에 대해서 ‘이 포인트가 다음 중심점으로 선택될 확률’을 계산한다. $c_{1}$로부터 거리가 멀수록 확률은 높아진다.</li>
    </ul>

\[p(x_{i}) = \frac{d(x_{i}, c_{1})^2}{\text{Sum of Squares}}\]

    <ul>
      <li>계산한 확률을 기반으로 두번째 클러스터의 중심점$c_{2}$을 추출한다.</li>
      <li>나머지 데이터 포인트에 대해서 <em>더 가까운</em> 클러스터의 중심점까지의 거리를 계산하고, 이에 따라 확률값도 조정한다</li>
    </ul>

\[\min{(d(x_{i}, c_{1}), d(x_{i}, c_{2}))}\]

    <ul>
      <li>$k$개의 중심점을 선택할 때까지 반복한다<br />
<br /></li>
    </ul>
  </li>
</ul>

<h1 id="클러스터의-수">클러스터의 수</h1>

<p>지금까지는 $k$를 특정 수로 상정한 상태에서 목적함수를 정의, 초기화, 최적화하는 과정을 살펴보았다. 그렇다면 정작 $k$는 어떻게 결정하는가? K-Means 알고리즘에서 <strong>클러스터의 개수 $k$는 사람이 직접 지정해주어야 한다</strong>. 이는 해당 알고리즘의 단점으로 항상 지적되는 지점이다.</p>

<p>최적의 클러스터 수를 정하는 것은 매우 중요하다. 만약에 $k$가 데이터 포인트 수만큼 크다면 각 데이터 포인트가 중심점이 되어버리기 때문에 목적함수는 0에 가까워지겠지만 클러스터링으로서 의미없는 작업이 된다. 반면 $k$를 $1$로 지정한다면 모든 데이터 포인트가 커다란 하나의 클러스터에 속하기 때문에 이 또한 의미가 없다.</p>

<p>즉 단지 WCSS를 최소화하는 것만이 목적이 아니며, <strong>데이터 포인트를 유의미하게 클러스터링하는 것</strong> 그리고 <strong>충분히 밀도 있는 클러스터를 찾기 위해 WCSS를 최소화하는 것</strong> - 이 둘이 적절한 밸런스를 이루는 <mark>클러스터 개수</mark>를 찾는 것이 K-Means 알고리즘의 열쇠다.</p>

<p>클러스터 수를 결정할 때 사용하는 다양한 방법론 중 세 가지를 살펴보려고 한다.</p>

<h2 id="rule-of-thumb">Rule of thumb</h2>

<p>특정 이론이라기보단 관습적으로 사용하는 경험적인 기준이다. 주어진 데이터의 사이즈가 $n$일 때,</p>

\[k \approx \sqrt{n/2}\]

<h2 id="elbow-method">Elbow Method</h2>
<p>특정 범위의 $k$를 하나씩 대입하며 클러스터 내 제곱합(WSCC)을 구한다. $k$가 커질수록 WCSS는 감소하는데 이 감소율이 급격하게 떨어지는 구간, 즉 Elbow Point의 $k$로 클러스터 개수를 결정한다.</p>

<p><img src="https://github.com/user-attachments/assets/28f30092-dc3f-4f4d-b9d1-3e4655dd57b4" alt="image" class="center-image" width="70%" /></p>

<h3 class="no_toc"> 왜 값이 급격하게 떨어진 직후를 최적의 $k$로 뽑는가? </h3>

<p>$k=1$로 시작할 경우 WCSS는 급격하게 감소하기 마련이다. 하나의 클러스터가 모든 데이터 포인트를 포함한다면 클러스터 내 분산은 매우 클 것이며, 여기에 개수가 하나씩 추가될수록 전반적인 클러스터의 분산합은 빠르게 줄어들 것이다.<br />
계속해서 클러스터가 추가된다면 WCSS는 계속 감소할 테지만 감소하는 폭은 줄어들 것이다. 데이터 포인트들이 이미 중심점에 충분히 가까워져 있기 때문이다.</p>

<p>$k$가 클수록 모델의 복잡도(Complexity)는 커지는데 그에 비해 WCSS가 크게 감소하지 않는다면, 더이상 유의미하게 클러스터가 컴팩트해지지 않고 모델 성능이 개선되지 않는다는 의미다. 결국 Elbow Point 이후로는 클러스터 개수를 늘려가면서까지 모델의 복잡도를 증가시킬 가치가 없다. 다시 말해 <strong>모델의 복잡도를 감수할 수 있을 정도로 WCSS가 ‘충분히’ 줄어드는 지점</strong>을 Elbow Point로 지정하는 것이다.</p>

<p>한번 더 강조하자면 K-Means 알고리즘의 목적은 단지 WCSS를 최소화하는 것만이 아니라, 충분히 WCSS를 감소시키면서 데이터 포인트를 유의미하게 클러스터링하는 최적의 Trade-off 지점을 찾는 것이다.</p>

<p>참고로 <code class="language-plaintext highlighter-rouge">Scikit-learn</code>과 같은 ML라이브러리에서는 Elbow Method에서 계산하는 WCSS를 <code class="language-plaintext highlighter-rouge">inertia</code>라고 표현한다.</p>

<h2 id="silhouette-score">Silhouette Score</h2>
<p>Silhouette Score(실루엣 지수)은 어떤 데이터 포인트가 자신이 속한 클러스터에 얼마나 응집되어 있는지(Cohesion), 그리고 자신이 속하지 않은 인근 클러스터로부터 얼마나 떨어져 있는지(Separation) 측정하는 지표다. 주로 K-Means 클러스터링의 결과를 평가할 때 사용하지만 $k$의 개수를 지정하는 데에도 활용할 수 있다.</p>

<p>먼저 주어진 특정 데이터 포인트 $i$에 대해서 두 개의 값을 계산한다.</p>
<ul>
  <li><strong>Cohesion(응집도)</strong> : 소속 클러스터의 다른 데이터 포인트들까지의 평균 거리, $a(i)$ 라고 표시한다.</li>
  <li><strong>Separation(분리도)</strong> : <em>가장 가까운</em> 외부 클러스터의 데이터 포인트들까지의 평균 거리, $b(i)$ 라고 표시한다.</li>
</ul>

<p>이를 활용하여 Silhouette Score를 계산한다. 지수는 $-1$과 $1$ 사이이며, $1$에 가까울수록 클러스터링 성능이 좋다고 평가한다.</p>

\[s(i) = \frac{b(i) - a(i)}{\max{(a(i), b(i))}}\]

<ul>
  <li>$1$에 가까울수록, $a(i)$가 $b(i)$에 비해 훨씬 작다는 의미이므로 알맞게 클러스터링 됐다고 평가한다</li>
  <li>$0$ 주변일수록, 해당 포인트가 두 클러스터의 경계 부분에 놓여 있다고 볼 수 있다</li>
  <li>$-1$에 가까울수록, $a(i)$가 $b(i)$에 비해 크다는 의미이므로 해당 포인트가 다른 클러스터에 더 가까울 수 있음을 시사한다 (아예 잘못 클러스터링된 경우를 고려할 수 있다)</li>
</ul>

<h3 class="no_toc"> 활용 </h3>
<p>Silhouette Score가 각 데이터 포인트에 대해 계산하는 값이기 때문에 이를 활용할 수 있는 방법은 다양하다.</p>

<ul>
  <li>모든 데이터 포인트에 대해 Silhouette Score를 각각 계산한 다음, 잘 클러스터링된/경계에 있는/잘못 클러스터링된 샘플들을 가려내기</li>
  <li>Silhouette Score의 평균값을 클러스터별로 집계하고 비교하여 잘못 응집된 클러스터를 다른 클러스터와 합치거나 더 쪼개기</li>
  <li>Silhouette Score의 전체 평균값을 집계하여 전반적인 클러스터링 성능을 평가하기
    <ul>
      <li>이때 클러스터 개수 $k$별로 평균 Silhouette Score을 비교하여 클러스터 개수를 지정할 수 있다<br />
<br /></li>
    </ul>
  </li>
</ul>

<h1 id="코드">코드</h1>

<h2 id="sklearn-라이브러리-활용">sklearn 라이브러리 활용</h2>
<p>sklearn.Cluster의 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">KMeans 모듈</a>과 sklearn.metrics <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.silhouette_score.html">silhouette_score</a>를 적용할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="n">sklearn.metrics</span> <span class="kn">import</span> <span class="n">silhouette_score</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">model</span> <span class="o">=</span> <span class="nc">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
<span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># k별로 해당 속성값을 시각화하면 elbow point를 찾을 수 있다
</span><span class="nf">print</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">inertia_</span><span class="p">)</span> 

<span class="c1"># 모든 데이터 포인트의 실루엣 스코어의 평균값을 출력한다
</span><span class="n">metric</span> <span class="o">=</span> <span class="nf">silhouette_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>입력 파라미터</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">n_clusters</code> : 클러스터 개수</li>
  <li><code class="language-plaintext highlighter-rouge">init</code> : 초기화 기법 (디폴트는 <code class="language-plaintext highlighter-rouge">k-means++</code>)</li>
</ul>

<p><strong>속성</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cluster_centers_</code> : 각 클러스터 중심점의 좌표</li>
  <li><code class="language-plaintext highlighter-rouge">inertia_</code> : 클러스터 내 제곱합(WCSS)<br />
<br /></li>
</ul>

<h2 id="python-구현-from-scratch">Python 구현 (from scratch)</h2>

<p><strong>거리 함수 (L2 Norm)</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">euclidean</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">((</span><span class="n">point</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>중심점 초기화 (Kmeans++)</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">random</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1"># 최초 클러스터 중심점 1개 추출
</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">X</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># 더 가까운 클러스터의 중심점까지 거리 계산
</span>    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">min</span><span class="p">([</span><span class="nf">euclidean</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="n">centroids</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">dists</span> <span class="o">/=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>

    <span class="c1"># 거리 기반의 확률로 추출
</span>    <span class="n">new_centroid_idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">dists</span><span class="p">)</span>
    <span class="n">centroids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">new_centroid_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</code></pre></div></div>

<p><strong>목적함수 최적화 (iteration)</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">prev_centroids</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># 중심점이 하나라도 변경되거나 max_iter 미만일 때 반복
</span><span class="k">while</span> <span class="n">np</span><span class="p">.</span><span class="nf">not_equal</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">prev_centroids</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">n_iter</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>
    <span class="n">sorted_points</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

    <span class="c1"># Assignment : 포인트마다 가장 가까운 클러스터 할당
</span>    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="nf">euclidean</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">centroids</span><span class="p">)</span>
        <span class="n">centroid_idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="n">sorted_points</span><span class="p">[</span><span class="n">centroid_idx</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
    <span class="n">prev_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>

    <span class="c1"># Update : 클러스터별로 평균값 업데이트하기
</span>    <span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorted_points</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 클러스터가 비어 있으면 업데이트 전 기존 평균값 사용
</span>            <span class="n">centroid</span> <span class="o">=</span> <span class="n">prev_centroid</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)]</span>
        <span class="n">centroids</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>

    <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p><strong>실루엣 지수 (Silhouette Score)</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># i번째 데이터 포인트에 대한 점수 계산
</span>
<span class="c1"># Cohesion (a(i))
</span><span class="n">own_cluster</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">own_cluster_points</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">own_cluster</span><span class="p">]</span>
<span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">own_cluster_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">a_i</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="nf">euclidean</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">own_cluster_points</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">a_i</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Separation (b(i))
</span><span class="n">b_i</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">centroid_idx</span><span class="p">,</span> <span class="n">centroid</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">centroids</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">centroid_idx</span> <span class="o">!=</span> <span class="n">own_cluster</span><span class="p">:</span>
        <span class="n">other_cluster_points</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">centroid_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">other_cluster_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">avg_dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="nf">euclidean</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">other_cluster_points</span><span class="p">))</span>
            <span class="n">b_i</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">b_i</span><span class="p">,</span> <span class="n">avg_dist</span><span class="p">)</span>

<span class="n">score</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_i</span> <span class="o">-</span> <span class="n">a_i</span><span class="p">)</span> <span class="o">/</span> <span class="nf">max</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="n">b_i</span><span class="p">)</span> <span class="k">if</span> <span class="nf">max</span><span class="p">(</span><span class="n">a_i</span><span class="p">,</span> <span class="n">b_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="머신러닝" /><summary type="html"><![CDATA[요약 - K-Means 클러스터링 알고리즘은 클러스터 내 분산을 최소화함으로써 가까운 데이터끼리 클러스터를 형성하는 비지도 학습 모델이다 - 분산을 전반적으로 충분히 감소시키면서 데이터 포인트를 유의미하게 그룹화하는 클러스터 개수를 찾는다 - 중심점을 세팅하는 초기화 방법론을 적용한 후, 클러스터 할당과 중심점 업데이트를 반복하며 최적화한다 개요 데이터 분석 업무를 하다보면 유저 그룹별로 특징을 비교하고 싶을 때가 있다. 그렇다면 유저 그룹은 어떤 기준으로 나눠야 하고 각 유저를 어느 그룹으로 분류할 수 있을까? 이런 문제를 만났을 때 곧잘 사용한 것이 K-means 클러스터링 알고리즘이다. 그런데 데이터 특성이나 하이퍼파라미터, 최적화 알고리즘 등 다양한 변수에 따라 상이한 군집화 결과가 나오기도 했고, 분석을 진행하기 앞서 군집화가 제대로 이루어지긴 한 건지 긴가민가할 때도 있었다. 따라서 이번 포스팅에서는 K-means 알고리즘의 정의와 원리를 수식과 함께 이해하고 코드로 그 내용을 구현한다. 용어의 통일성을 위해 앞으로 군집(화) 는 클러스터(링) 으로 표현하겠다. 정의 K-means 알고리즘은 데이터를 $k$개의 클러스터로 묶는 클러스터링 알고리즘으로, 비지도 학습 방식에 속한다. 학습은 클러스터 내 분산을 최소화하는 방식으로 수행된다. 따라서 클러스터는 가까운 데이터들이 모인 그룹을 뜻한다. 목적 클러스터 내 제곱합(within-cluster sum of squares, WCSS)을 최소화하는 $k$개 집합 $S$을 찾는 것이 목적이다. 목적함수는 아래와 같다. \[\mathop{\operatorname{arg\,min}}_{\mathbf{S}} \sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\] ${\operatorname{arg\,min}}_{\mathbf{S}}$ 주어진 식을 최소화하는 $S$ ${\mu}_{i}$ $S_i$에 속한 포인트들의 평균mean (또는 중앙값median) $||…||$ 편차를 L2 Norm (유클리드 거리) 으로 계산 $k$개 클러스터별 ‘데이터 포인트들과 평균의 차이를 제곱하여 합산한 값(=편차제곱합)’의 합을 의미한다. 분산이 편차제곱의 평균이라는 점을 상기한다면, 이 값은 클러스터의 분산에 클러스터의 사이즈를 곱한 것과 같다는 것을 알 수 있다. \[\mathop{\operatorname{arg\,min}}_{\mathbf{S}} \sum_{i=1}^{k} |S_{i}| \operatorname{Var}(S_{i})\] $|S_i|$ $S_i$의 크기, 즉 해당 클러스터에 속한 포인트의 개수 $\operatorname{Var}(S_{i})$ $S_i$의 분산, 즉 해당 클러스터에 속한 포인트들의 분산 따라서 $k$개 클러스터별 ‘크기와 분산을 곱한 값(Product)’의 합으로도 표현할 수 있다. 직관적으로는 클러스터의 크기가 가중치로 작용하여 클러스터가 클수록 합산값에 기여한다고 볼 수 있으며, 클러스터들의 전반적인 분산합을 최소화해야 한다는 점에서 K-Means 알고리즘의 목적과 동일하다. 계산 효율성 K-Means 알고리즘의 정의로 돌아와 클러스터 내 분산이라는 키워드를 다시 생각해보자. 앞서 목적함수에서는 ‘데이터 포인트($x$)와 중심점($\mu$) 간의 거리’로 이를 계산했다. 하지만 초점을 ‘데이터 포인트들($x, y$) 간의 거리’로 옮겨보는 건 어떨까? 즉 K-Means 알고리즘은 $k$개 클러스터별 ‘데이터 쌍별 편차제곱(pairwise squared deviations)의 평균’들의 합을 최소화하는 것과도 동일하다. 한 클러스터 안에서 데이터 포인트로 만들 수 있는 모든 조합에 대해 편차를 계산하고, 이 포인트들이 평균적으로 얼마나 퍼져 있는지 나타낸 식이다. \[{\operatorname{arg\,min}}_{\mathbf{S}} \sum_{i=1}^{k} \frac{1}{ |S_{i}| }\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - \mathbf{y}\right\|^{2}\] 한편 아래 항등식(identity)에 따르면 ‘데이터 쌍별 편차제곱합’은 ‘데이터 포인트들과 평균 $c_{i}$의 편차를 제곱하여 합산한 값(=편차제곱합)에 클러스터 사이즈의 $2$배를 곱한 것’과 동일하다. \[\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - \mathbf{y}\right\|^{2}=2|S_{i}|\sum_{\mathbf{x} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2}\] 이러한 계산 구조를 활용하여 클러스터의 모든 조합에 대해 연산을 수행하지 않고도 분산을 효율적이고 간단하게 계산할 수 있다. 유도 과정은 아래와 같다. 편차의 총합은 $0$이기 때문에 중간의 내적항은 사라진다. \[\begin{aligned} \left\|\mathbf{x} - \mathbf{y}\right\|^{2} &amp; = \left\|\mathbf{x} - {c}_{i} + {c}_{i} - \mathbf{y}\right\|^2 \\ &amp; = \left\|\mathbf{x} - {c}_{i}\right\|^{2} -2 (\mathbf{x} - {c}_{i}) \cdot (\mathbf{y} - {c}_{i}) + \left\|\mathbf{y} - {c}_{i}\right\|^{2} \\ &amp; = \left\|\mathbf{x} - {c}_{i}\right\|^{2} + \left\|\mathbf{y} - {c}_{i}\right\|^{2} \end{aligned}\] 이렇게 유도된 식에 원래대로 $\sum$을 적용한다면, \[\sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - \mathbf{y}\right\|^{2} = \sum_{\mathbf{x,y} \in S_{i}} (\left\|\mathbf{x} - {c}_{i}\right\|^{2} + \left\|\mathbf{y} - {c}_{i}\right\|^{2})\] 모든 점 $x$, $y$에 대해서 합산하기 때문에 $x$, $y$ 각각 두 겹의 $\sum$으로 표현할 수 있으며, $c$는 상수이기 때문에 $\sum$는 $|S|$의 곱셉으로 변환할 수 있다. \[\begin{aligned} \sum_{\mathbf{x,y} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2} &amp; = \sum_{\mathbf{x} \in S_{i}}\ \sum_{\mathbf{y} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2} \\ &amp; = |S_{i}| \sum_{\mathbf{x} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2} \end{aligned}\] 마지막으로 $\sum_{\mathbf{x,y} \in S_{i}}\left|\mathbf{y} - {c}_{i}\right|^{2}$ 에 대해서도 동일하게 유도할 수 있으므로 $2$배가 된다. \[2|S_{i}|\sum_{\mathbf{x} \in S_{i}}\left\|\mathbf{x} - {c}_{i}\right\|^{2}\] 최적화 이제 이 목적함수를 최적화하는 방식을 알아볼 것이다. 처음 초기화된 식은 아래 두 동작을 반복하며 클러스터 내 제곱합(WCSS)을 감소시킨다. Assignment : 각 데이터 포인트에 가장 가까운 클러스터를 할당하기 Update : 각 클러스터에 할당된 데이터 포인트들의 평균값을 계산하여 새로운 클러스터의 중심을 업데이트하기 이 과정을 반복할 때마다(iteration) 클러스터 내 제곱합은 항상 감소한다. 업데이트를 거듭할수록 데이터 포인트들은 점점 더 클러스터의 중심에 가까워지고 클러스터의 크기는 더 작아지기 때문이다. 이러한 단조 감소(monotone decreasing)의 성질로 인해 K-Means 알고리즘은 수렴이 가능한 식이다. 다만 ‘현재 상태에서’ 가장 가까운 클러스터를 할당하는 탐욕적(greedy) 방식으로 진행되기 때문에 지역 최적해(local optimum)에 수렴하기 쉽다. 초기화 업데이트에 앞서 중심점을 지정하는 초기화 단계를 거쳐야 한다. 적절하지 않은 중심점에서 시작할 경우 지역 최적해에 빠져버릴 수 있기 때문에 알맞은 초기화 기법을 선택하는 것이 좋다. 무작위 분할(Random Partition) : 모든 데이터 포인터를 $k$개 클러스터 중 하나로 임의 할당한다 Forgy 알고리즘 : 데이터 포인터 중 $k$개를 임의로 선택하고 이들을 중심점으로 사용한다 두 최적화 기법은 중심점을 임의로 설정하기 때문에 결과가 매번 달라질 수 있다는 단점이 있다 K-means++ : 기존 초기화 기법의 한계를 커버하기 위해, 거리가 가중치로 적용된 확률을 기반으로 중심점을 찾는다 데이터 포인트 중 $1$개를 임의로 선택하고 이를 첫번째 클러스터의 중심점 $c_{1}$으로 사용한다 나머지 데이터 포인트에 대해서 첫번째 클러스터의 중심점까지의 거리 제곱합을 계산한다 \[d(x_{i}, c_{1})^2\] 나머지 데이터 포인트에 대해서 ‘이 포인트가 다음 중심점으로 선택될 확률’을 계산한다. $c_{1}$로부터 거리가 멀수록 확률은 높아진다. \[p(x_{i}) = \frac{d(x_{i}, c_{1})^2}{\text{Sum of Squares}}\] 계산한 확률을 기반으로 두번째 클러스터의 중심점$c_{2}$을 추출한다. 나머지 데이터 포인트에 대해서 더 가까운 클러스터의 중심점까지의 거리를 계산하고, 이에 따라 확률값도 조정한다 \[\min{(d(x_{i}, c_{1}), d(x_{i}, c_{2}))}\] $k$개의 중심점을 선택할 때까지 반복한다 클러스터의 수 지금까지는 $k$를 특정 수로 상정한 상태에서 목적함수를 정의, 초기화, 최적화하는 과정을 살펴보았다. 그렇다면 정작 $k$는 어떻게 결정하는가? K-Means 알고리즘에서 클러스터의 개수 $k$는 사람이 직접 지정해주어야 한다. 이는 해당 알고리즘의 단점으로 항상 지적되는 지점이다. 최적의 클러스터 수를 정하는 것은 매우 중요하다. 만약에 $k$가 데이터 포인트 수만큼 크다면 각 데이터 포인트가 중심점이 되어버리기 때문에 목적함수는 0에 가까워지겠지만 클러스터링으로서 의미없는 작업이 된다. 반면 $k$를 $1$로 지정한다면 모든 데이터 포인트가 커다란 하나의 클러스터에 속하기 때문에 이 또한 의미가 없다. 즉 단지 WCSS를 최소화하는 것만이 목적이 아니며, 데이터 포인트를 유의미하게 클러스터링하는 것 그리고 충분히 밀도 있는 클러스터를 찾기 위해 WCSS를 최소화하는 것 - 이 둘이 적절한 밸런스를 이루는 클러스터 개수를 찾는 것이 K-Means 알고리즘의 열쇠다. 클러스터 수를 결정할 때 사용하는 다양한 방법론 중 세 가지를 살펴보려고 한다. Rule of thumb 특정 이론이라기보단 관습적으로 사용하는 경험적인 기준이다. 주어진 데이터의 사이즈가 $n$일 때, \[k \approx \sqrt{n/2}\] Elbow Method 특정 범위의 $k$를 하나씩 대입하며 클러스터 내 제곱합(WSCC)을 구한다. $k$가 커질수록 WCSS는 감소하는데 이 감소율이 급격하게 떨어지는 구간, 즉 Elbow Point의 $k$로 클러스터 개수를 결정한다. 왜 값이 급격하게 떨어진 직후를 최적의 $k$로 뽑는가? $k=1$로 시작할 경우 WCSS는 급격하게 감소하기 마련이다. 하나의 클러스터가 모든 데이터 포인트를 포함한다면 클러스터 내 분산은 매우 클 것이며, 여기에 개수가 하나씩 추가될수록 전반적인 클러스터의 분산합은 빠르게 줄어들 것이다. 계속해서 클러스터가 추가된다면 WCSS는 계속 감소할 테지만 감소하는 폭은 줄어들 것이다. 데이터 포인트들이 이미 중심점에 충분히 가까워져 있기 때문이다. $k$가 클수록 모델의 복잡도(Complexity)는 커지는데 그에 비해 WCSS가 크게 감소하지 않는다면, 더이상 유의미하게 클러스터가 컴팩트해지지 않고 모델 성능이 개선되지 않는다는 의미다. 결국 Elbow Point 이후로는 클러스터 개수를 늘려가면서까지 모델의 복잡도를 증가시킬 가치가 없다. 다시 말해 모델의 복잡도를 감수할 수 있을 정도로 WCSS가 ‘충분히’ 줄어드는 지점을 Elbow Point로 지정하는 것이다. 한번 더 강조하자면 K-Means 알고리즘의 목적은 단지 WCSS를 최소화하는 것만이 아니라, 충분히 WCSS를 감소시키면서 데이터 포인트를 유의미하게 클러스터링하는 최적의 Trade-off 지점을 찾는 것이다. 참고로 Scikit-learn과 같은 ML라이브러리에서는 Elbow Method에서 계산하는 WCSS를 inertia라고 표현한다. Silhouette Score Silhouette Score(실루엣 지수)은 어떤 데이터 포인트가 자신이 속한 클러스터에 얼마나 응집되어 있는지(Cohesion), 그리고 자신이 속하지 않은 인근 클러스터로부터 얼마나 떨어져 있는지(Separation) 측정하는 지표다. 주로 K-Means 클러스터링의 결과를 평가할 때 사용하지만 $k$의 개수를 지정하는 데에도 활용할 수 있다. 먼저 주어진 특정 데이터 포인트 $i$에 대해서 두 개의 값을 계산한다. Cohesion(응집도) : 소속 클러스터의 다른 데이터 포인트들까지의 평균 거리, $a(i)$ 라고 표시한다. Separation(분리도) : 가장 가까운 외부 클러스터의 데이터 포인트들까지의 평균 거리, $b(i)$ 라고 표시한다. 이를 활용하여 Silhouette Score를 계산한다. 지수는 $-1$과 $1$ 사이이며, $1$에 가까울수록 클러스터링 성능이 좋다고 평가한다. \[s(i) = \frac{b(i) - a(i)}{\max{(a(i), b(i))}}\] $1$에 가까울수록, $a(i)$가 $b(i)$에 비해 훨씬 작다는 의미이므로 알맞게 클러스터링 됐다고 평가한다 $0$ 주변일수록, 해당 포인트가 두 클러스터의 경계 부분에 놓여 있다고 볼 수 있다 $-1$에 가까울수록, $a(i)$가 $b(i)$에 비해 크다는 의미이므로 해당 포인트가 다른 클러스터에 더 가까울 수 있음을 시사한다 (아예 잘못 클러스터링된 경우를 고려할 수 있다) 활용 Silhouette Score가 각 데이터 포인트에 대해 계산하는 값이기 때문에 이를 활용할 수 있는 방법은 다양하다. 모든 데이터 포인트에 대해 Silhouette Score를 각각 계산한 다음, 잘 클러스터링된/경계에 있는/잘못 클러스터링된 샘플들을 가려내기 Silhouette Score의 평균값을 클러스터별로 집계하고 비교하여 잘못 응집된 클러스터를 다른 클러스터와 합치거나 더 쪼개기 Silhouette Score의 전체 평균값을 집계하여 전반적인 클러스터링 성능을 평가하기 이때 클러스터 개수 $k$별로 평균 Silhouette Score을 비교하여 클러스터 개수를 지정할 수 있다 코드 sklearn 라이브러리 활용 sklearn.Cluster의 KMeans 모듈과 sklearn.metrics silhouette_score를 적용할 수 있다. from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score k = 3 model = KMeans(n_clusters=k) pred = model.fit_predict(X) # k별로 해당 속성값을 시각화하면 elbow point를 찾을 수 있다 print(model.inertia_) # 모든 데이터 포인트의 실루엣 스코어의 평균값을 출력한다 metric = silhouette_score(X, pred) print(metric) 입력 파라미터 n_clusters : 클러스터 개수 init : 초기화 기법 (디폴트는 k-means++) 속성 cluster_centers_ : 각 클러스터 중심점의 좌표 inertia_ : 클러스터 내 제곱합(WCSS) Python 구현 (from scratch) 거리 함수 (L2 Norm) import numpy as np def euclidean(point, data): return np.sqrt(np.sum((point - data)**2, axis=1)) 중심점 초기화 (Kmeans++) import random k = 3 # 최초 클러스터 중심점 1개 추출 centroids = [random.choice(X)] for _ in range(k-1): # 더 가까운 클러스터의 중심점까지 거리 계산 dists = np.min([euclidean(centroid, X) for centroid in centroids], axis=0) dists = dists**2 dists /= np.sum(dists) # 거리 기반의 확률로 추출 new_centroid_idx = np.random.choice(range(len(X)), size=1, p=dists) centroids.append(X[new_centroid_idx[0]]) 목적함수 최적화 (iteration) max_iter = 100 n_iter = 0 prev_centroids = None # 중심점이 하나라도 변경되거나 max_iter 미만일 때 반복 while np.not_equal(centroids, prev_centroids).any() and n_iter &lt; max_iter: sorted_points = [[] for _ in range(k)] # Assignment : 포인트마다 가장 가까운 클러스터 할당 for point in X: dists = euclidean(point, centroids) centroid_idx = np.argmin(dists) sorted_points[centroid_idx].append(point) prev_centroids = np.copy(centroids) # Update : 클러스터별로 평균값 업데이트하기 centroids = [] for cluster in sorted_points: if len(cluster) &gt; 0: centroid = np.mean(cluster, axis=0) else: # 클러스터가 비어 있으면 업데이트 전 기존 평균값 사용 centroid = prev_centroid[len(centroids)] centroids.append(centroid) n_iter += 1 실루엣 지수 (Silhouette Score) # i번째 데이터 포인트에 대한 점수 계산 # Cohesion (a(i)) own_cluster = labels[i] own_cluster_points = X[labels == own_cluster] if len(own_cluster_points) &gt; 1: a_i = np.mean(euclidean(point, own_cluster_points)) else: a_i = 0 # Separation (b(i)) b_i = float('inf') for centroid_idx, centroid in enumerate(centroids): if centroid_idx != own_cluster: other_cluster_points = X[labels == centroid_idx] if len(other_cluster_points) &gt; 0: avg_dist = np.mean(euclidean(point, other_cluster_points)) b_i = min(b_i, avg_dist) score = (b_i - a_i) / max(a_i, b_i) if max(a_i, b_i) &gt; 0 else 0]]></summary></entry><entry><title type="html">작성중// Jekyll을 사용한 github.io 블로그 개발기</title><link href="http://woocosmos.github.io/blog-history/" rel="alternate" type="text/html" title="작성중// Jekyll을 사용한 github.io 블로그 개발기" /><published>2024-08-19T00:00:00+00:00</published><updated>2024-08-19T00:00:00+00:00</updated><id>http://woocosmos.github.io/blog-history</id><content type="html" xml:base="http://woocosmos.github.io/blog-history/"><![CDATA[<p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 지금 이 블로그(woocosmos.github.io)를 구축한 전반적인 내용
- Jekyll 설치를 위해 ruby 개발 환경을 세팅한다
- 목적과 취향에 맞는 Jekyll 테마를 골라 fork 한다
- HTML/CSS/JavaScript를 활용하여 다양한 기능을 추가, 수정한다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p><strong>티스토리에서 운영하던 개발 블로그를 github.io 로 이관하는 작업을 진행하고 있다.</strong><br />
그 이유는 첫째, 티스토리에서 Markdown이 불안정하게 적용되기 때문이다. 둘째, HTML 및 JavaScript를 활용하여 자유자재로 커스터마이징할 수 있다는 점이 매력적으로 느껴졌기 때문이다.</p>

<p>물론 github.io 블로그는 카테고리 설정이 까다로워 대부분 태그 기반이라는 점, 그리고 검색이나 목차와 같은 기능은 직접 구현해야 한다는 번거로움이 단점으로 작용한다. 그러나 이참에 개발 블로그를 정식으로 세팅하고 JavaScript를 직접 부딪치며 배워보는 기회로 여겨보려 한다.</p>

<p>곧 게시물을 전부 이쪽으로 옮길 예정이지만 <a href="https://woo-niverse.tistory.com/">기존 티스토리 블로그</a>도 열려 있으니 언제든 놀러오시라.</p>

<h1 id="기본-세팅">기본 세팅</h1>

<p><img src="https://github.com/user-attachments/assets/fb2c6368-b119-420e-ac38-a91483aca40f" alt="alt text" width="60%" /></p>

<p>github.io 블로그를 시작하기 위해서는 jekyll(지킬)을 세팅하는 것이 우선이다. Jekyll은 마크다운 언어로 작성한 텍스트를 정적 웹사이트로 생성해주는 변환 엔진이다. 한국어로 번역된 공식 문서를 <a href="https://jekyllrb-ko.github.io/">이곳</a>에서 확인할 수 있다.</p>

<h2 id="ruby">Ruby</h2>

<p>Jekyll은 Ruby 프로그램이기 때문에 Ruby를 먼저 설치해야 한다. 또한 Ruby의 라이브러리(즉, Gem)를 관리해주는 프레임워크인 RubyGems도 필요하다. OS에 따른 설치 방법은 <a href="https://jekyllrb-ko.github.io/docs/installation/">공식 문서</a>를 포함하여 다양한 칼럼에 소개되어 있으니 참고하면 되겠다.</p>

<p>개인적으로 Windows(회사 컴퓨터)와 Mac(개인 노트북)에 각각 Ruby를 설치하면서 다양한 트러블슈팅을 경험했는데, 대개 Ruby의 버전 관리 프레임워크인 <code class="language-plaintext highlighter-rouge">rbenv</code>로 설치를 관리하면서 많은 문제를 회피할 수 있었다.</p>

<blockquote>
  <p>특히 <strong>Ruby의 버전이 3.0.0 이상이어야 한다</strong>는 에러를 가장 많이 부딪혔는데 rbenv로 원하는 버전으로 지정함으로써 문제에서 벗어날 수 있었다. 해당 블로그 프로젝트는 <code class="language-plaintext highlighter-rouge">ruby-3.2.0</code>으로 빌드했다.</p>
</blockquote>

<p>준비물의 순서로 정리하자면 rbenv → Ruby → gem → bundler → jekyll 이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>jekyll 
</code></pre></div></div>

<p>더하여 개발의 편의성을 위해 jekyll 로컬 서버를 띄우려면 <code class="language-plaintext highlighter-rouge">github-pages</code>를 설치하는 것이 좋다. 이를 활용하여 파일의 변경사항을 save할 때마다 바로 반영된 것을 확인할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install github-pages
jekyll server --force_polling
</code></pre></div></div>
<ul>
  <li>별도 옵션을 주지 않는 한 <a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a>로 접속한다</li>
  <li><code class="language-plaintext highlighter-rouge">--force_polling</code> : 해당 플래그 옵션으로 블로그를 새로고침해서 바로 변경된 내용을 확인할 수 있다. 이를 설정하지 않으면 매번 로컬 서버를 내렸다가 다시 올려야 한다.</li>
</ul>

<h2 id="jekyll-테마">Jekyll 테마</h2>

<p>from scratch로 블로그를 구성하기보다는 특정 테마로 베이스 사이트를 세팅한 후에 기능을 추가하거나 변경하기로 했다. <a href="http://jekyllthemes.org/">Jekyll 테마 사이트</a>에서 목적과 취향에 맞는 테마를 골라보자.</p>

<p><img src="https://github.com/user-attachments/assets/3f3fda0a-0307-4f87-8a3f-6faba96ebcb1" alt="image" width="80%" /></p>

<p>결론적으로 한국어 가독성을 고려한 <a href="https://github.com/AWEEKJ/kiko-now">Kiko Now</a>를 기본으로 하되, <a href="https://chesterhow.github.io/tale/">Tale</a>이나 <a href="https://starry99.github.io/catbook/">Catbook</a> 등 다양한 테마를 레퍼런스로 삼아 기능을 추가하는 방향으로 진행했다.</p>

<p>이제 선택한 테마의 github 레포지토리로 이동하여 나의 레포지토리로 fork 해오면 된다. 이때 레포지토리 이름을 <code class="language-plaintext highlighter-rouge">{username}.github.io</code>로 설정하면 github에서 자동으로 해당 도메인으로 호스팅해준다. fork 직후에는 위 도메인으로 접속이 안 될 수도 있는데, 수 분 기다리거나 최소 하나의 변경 사항을 push 해주면 들어가진다.</p>

<p>마지막으로 작업 폴더에서 git clone하여 로컬 레포지토리를 생성한다.</p>

<h2 id="config-수정">config 수정</h2>

<p>대부분 Jekyll 테마에서 그렇듯 커스터마이징의 첫 단계는 <code class="language-plaintext highlighter-rouge">_config.yml</code> 파일을 수정하는 것이다. 블로그 이름, SNS 링크 등 기본적인 내용을 이곳에 입력하도록 되어 있다.</p>

<p>이제 기본적인 세팅은 끝이다. 바로 MD 파일을 생성해서 포스트를 업로드할 수 있다. 개인적으로는 약간 번거롭더라도 복구 가능성을 위해 항상 git branch로 작업 후 master에 merge 하는 편이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> post/blog-history
vi _posts/2024-08-19-blog-history.md
<span class="c"># 포스트 작성 후 ...</span>
git add <span class="nb">.</span>
git commit <span class="nt">-m</span> <span class="s1">'[post/init] 블로그 개발기'</span>
git push
<span class="c"># master 에 반영</span>
git checkout master
git merge post/blog-history
</code></pre></div></div>

<p>브랜치 네임이나 커밋 메시지의 컨벤션은 스스로 아래와 같이 정했다.</p>
<ul>
  <li>post/… : 블로그글 관련 브랜치</li>
  <li>feature/… : 블로그 기능 관련 브랜치</li>
  <li>[post/init] : 블로그글 최초 배포 커밋</li>
  <li>[post/modi] : 이후 블로그글 수정 커밋</li>
</ul>

<h1 id="구글-검색-연동">구글 검색 연동</h1>

<p>내용</p>

<h1 id="기능-추가">기능 추가</h1>

<p>이제부터 이어지는 내용은 기능을 추가한 히스토리를 기록한 것이다.</p>

<p>JavaScript를 잘 모르다보니 Workaround 형식으로 구현한 내용도 많다. 개선 지점은 언제든 덧글이나 연락처로 알려주시면 감사하겠다.</p>

<h2 id="disqus-덧글창-추가">disqus 덧글창 추가</h2>

<p>내용</p>

<h2 id="favicon-아이콘-추가">favicon 아이콘 추가</h2>

<p>내용</p>

<h2 id="back-to-top-버튼-구현">back-to-top 버튼 구현</h2>

<p>내용</p>

<h2 id="커서에-따른-그라데이션-색상-변화">커서에 따른 그라데이션 색상 변화</h2>

<p>내용</p>

<h2 id="페이지-레이아웃-수정">페이지 레이아웃 수정</h2>
<h3 id="tag-페이지">Tag 페이지</h3>
<p>내용</p>

<h3 id="blog-페이지">Blog 페이지</h3>
<p>내용</p>

<h2 id="검색-페이지-추가">검색 페이지 추가</h2>
<h3 id="검색-기능">검색 기능</h3>
<p>내용</p>

<h3 id="검색-결과-하이라이트">검색 결과 하이라이트</h3>
<p>내용</p>

<h2 id="아바타-기울기-애니메이션">아바타 기울기 애니메이션</h2>

<hr />
<h2 id="latex수학-수식-적용하기">LaTex(수학 수식) 적용하기</h2>

<p>LaTex를 렌더링해주는 KaTex 를 <code class="language-plaintext highlighter-rouge">_includes/head.html</code>의 head 부분에 추가한다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;script </span><span class="na">defer</span> <span class="na">src=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;script </span><span class="na">defer</span> <span class="na">src=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"</span>
          <span class="na">onload=</span><span class="s">"renderMathInElement(document.body, {
            delimiters: [
              {left: '\\[', right: '\\]', display: true},
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
            ]
          });"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<ul>
  <li>delimiter를 명시한 이유는 inline LaTex를 제대로 인식하지 못했던 문제 때문이다</li>
  <li>명시한 이후에도 display LaTex가 적용되지 않는 문제가 있었다 : $$로 감싸도 \[\] 로 출력되었다 (사실 이것이 표준 display LaTex notation이라고 한다) 그래서 delimiter 항목으로 더 추가했다</li>
</ul>

<p>이제 LaTex 문법대로 수식을 $ 기호 1개 혹은 2개 사이에 작성하면 알맞게 렌더링 된다</p>

<p><strong>display LaTex</strong></p>

\[\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\]

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$$
<span class="se">\s</span>um_{i=1}^{k} <span class="se">\s</span>um_{<span class="se">\m</span>athbf{x} <span class="se">\i</span>n S_{i}} <span class="se">\l</span>eft<span class="se">\|\m</span>athbf{x} - <span class="se">\b</span>oldsymbol{<span class="se">\m</span>u}_{i}<span class="se">\r</span>ight<span class="se">\|</span>^{2}
$$  
</code></pre></div></div>

<p><strong>inline LaTex</strong><br />
문장 중간에 이렇게 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>문장 중간에 이런 수식을 $<span class="se">\s</span>um_{<span class="se">\m</span>athbf {x} <span class="se">\i</span>n S_{i}}<span class="se">\m</span>athbf {x}$ 넣을 수 있다
</code></pre></div></div>
<hr />

<h2 id="목차toc-추가">목차(TOC) 추가</h2>
<p>블로그글 옆 사이드바 형식의 목차를 추가한다. 아래는 플러그인을 설치해서 사용할 수 있는 <a href="https://github.com/toshimaru/jekyll-toc">jekyll-toc</a>을 적용한 내용이다.</p>

<p><a href="https://github.com/allejo/jekyll-toc">동일한 이름의 플러그인</a>이 있는데, 후술할 Github Pages 이슈로부터 자유로운 것으로 보인다. 처음으로 돌아간다면 이것을 적용해볼지도…</p>

<p><strong>설치 방법</strong></p>

<p><code class="language-plaintext highlighter-rouge">Gemfile</code>에 아래 라인을 추가한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'jekyll-toc'
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">bundle</code>로 설치를 진행한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle install
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">_config.yml</code> 파일 중 플러그인 부분에 요소를 추가한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins:
  - jekyll-sitemap
    ...
  - jekyll-toc # 추가
</code></pre></div></div>

<p><strong>사용 방법</strong></p>

<p>post 헤드에 <code class="language-plaintext highlighter-rouge">toc</code> 플래그를 추가한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: post
title: "Jekyll을 사용한 github.io 블로그 개발기"
tags: [JavaScript]
comments: True
toc: true
---
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">post.html</code>에 toc을 추가한다.<br />
단순히 <code class="language-plaintext highlighter-rouge">{{ content | toc }}</code>로 수정해서 <em>본문 위에 목차가 생성</em>되도록 하는 방법도 있지만 목차의 레이아웃이나 기능을 다양하게 커스터마이징 하기 위해 별도 태그인 <code class="language-plaintext highlighter-rouge">{% toc %}</code>로 추가했다.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;section</span> <span class="na">class=</span><span class="s">"entry"</span><span class="nt">&gt;</span>
    {% if page.toc %}
    <span class="nt">&lt;aside&gt;</span>
        <span class="nt">&lt;nav</span> <span class="na">class=</span><span class="s">"nav-toc"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;h3&gt;</span> 목차 <span class="nt">&lt;/h3&gt;</span>
            {% toc %}
        <span class="nt">&lt;/nav&gt;</span>
    <span class="nt">&lt;/aside&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ site.baseurl }}/assets/scroll-spy.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
    {% endif %}
    {{ content }}
<span class="nt">&lt;/section&gt;</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">{% if page.toc %}</code> : 헤드에 toc 플래그를 명시한 경우에만 목차가 추가되게 했다.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code> : 본문 옆 사이드바 형식으로 표시하기 위해 사용했다</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;nav&gt;</code> : 목차의 제목을 클릭했을 때 해당 영역으로 이동하도록 링크를 연결하기 위해 사용했다</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;h3&gt; 목차 &lt;/h3&gt;</code> : 플러그인으로 자동 생성되는 HTML에는 제목이 없길래 따로 추가해주었다 (사실 page.toc 조건을 굳이 넣은 것도 이 제목 때문이다. toc: false으로 세팅해도 h3 태그는 남아 있었기 때문이다.)</li>
</ul>

<h3 id="목차-레이아웃">목차 레이아웃</h3>

<p>목차의 위치와 모양을 세팅하는 과정이다.</p>

<p><strong>목차를 본문 좌측에 맞추고 스크롤과 상관없이 상단에 고정시키기</strong></p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">aside</span> <span class="p">{</span>
    <span class="nl">float</span><span class="p">:</span> <span class="nb">right</span><span class="p">;</span>
    <span class="nl">position</span><span class="p">:</span> <span class="n">sticky</span><span class="p">;</span>
    <span class="nl">width</span><span class="p">:</span> <span class="n">fit-content</span><span class="p">;</span>
    <span class="nl">top</span><span class="p">:</span> <span class="m">10px</span><span class="p">;</span>
    <span class="nl">margin-right</span><span class="p">:</span> <span class="m">-300px</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">position</code>을 sticky로 설정하고 <code class="language-plaintext highlighter-rouge">top</code>값을 조금이라도 부여하면 스크롤과 상관없이 화면 한 쪽에 고정되는 효과를 구현할 수 있다</li>
  <li><code class="language-plaintext highlighter-rouge">margin-right</code>를 조정해서 본문과 너무 멀지도, 가깝지도 않게 위치시켰다</li>
</ul>

<p><strong>레이아웃을 심플하게 디자인하기</strong></p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.nav-toc</span> <span class="p">{</span>
  <span class="nl">font-size</span><span class="p">:</span> <span class="nb">smaller</span><span class="p">;</span>
  <span class="nl">border-left</span><span class="p">:</span> <span class="m">1px</span> <span class="nb">solid</span> <span class="err">$</span><span class="n">lightGray</span><span class="p">;</span>

  <span class="err">h3</span> <span class="err">{</span>
    <span class="nl">padding-left</span><span class="p">:</span> <span class="m">20px</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nt">ul</span> <span class="o">&gt;</span> <span class="nt">li</span> <span class="p">{</span>
    <span class="nl">list-style-type</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span> 
    <span class="err">&amp;:before</span> <span class="err">{</span>
      <span class="nl">content</span><span class="p">:</span> <span class="s2">''</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nt">ul</span> <span class="p">{</span>
      <span class="nl">display</span><span class="p">:</span> <span class="nb">inline</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="err">}</span>

  <span class="nt">ul</span> <span class="o">&gt;</span> <span class="nt">li</span> <span class="o">&gt;</span> <span class="nt">a</span><span class="nc">.active</span> <span class="p">{</span>
    <span class="nl">font-size</span><span class="p">:</span> <span class="nb">larger</span><span class="p">;</span>
    <span class="nl">font-weight</span><span class="p">:</span> <span class="nb">bold</span><span class="p">;</span>
  <span class="p">}</span>
<span class="err">}</span>
</code></pre></div></div>
<ul>
  <li>기본적으로 폰트 사이즈는 작게, 리스트 앞에 붙는 마커는 생략했다
    <ul>
      <li><code class="language-plaintext highlighter-rouge">list-style-type: none</code>를 주었는데도 마커가 생성되어 <code class="language-plaintext highlighter-rouge">&amp;:before {content: '';}</code>를 별도로 추가했다</li>
    </ul>
  </li>
  <li>목차와 본문 사이 가는 구분선을 추가했다 (<code class="language-plaintext highlighter-rouge">border-left</code>)</li>
  <li>일부 하위 목차들이 가로로 나열되는(?) 이상한 현상이 있어서 <code class="language-plaintext highlighter-rouge">display: inline</code>을 추가했다</li>
  <li>목차가 하이라이트 대상일 때 폰트 사이즈와 굵기를 조금 키운다</li>
</ul>

<p><strong>목차 하이라이트 기능</strong><br />
스크롤의 위치에 따라 현재 보고 있는 콘텐츠의 목차를 하이라이트하는 기능이다. 위에서 toc 태그를 추가한 HTML 코드를 보면 <code class="language-plaintext highlighter-rouge">scroll-spy.js</code>라는 스크립트를 실행시키는 것을 볼 수 있는데, 이것이 <strong>스크롤 위치에 따라 하이라이트할 목차를 지정</strong>하는 역할을 한다.<br />
전체 코드를 살펴보겠다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 브라우저가 HTML을 전부 읽고 DOM 트리를 완성했을 때 발생하는 이벤트
document.addEventListener('DOMContentLoaded', () =&gt; {

    // links : H1, H2, H3 깊이 까지만 목차를 읽어온다 (a 태그 셀렉트)
    const Hs = document.querySelectorAll('.nav-toc ul.section-nav li.toc-entry.toc-h1, .nav-toc ul.section-nav li.toc-entry.toc-h2, .nav-toc ul.section-nav li.toc-entry.toc-h3');
    const links = Array.from(Hs).map(h =&gt; { return h.querySelector('a') })
    
    // anchors : links 의 각 요소로부터 href 를 읽어온다
    const anchors = Array.from(links).map(link =&gt; {
        const href = link.getAttribute('href');
        if (href) {
            return document.querySelector(href);
        }
        return null;
    }).filter(anchor =&gt; anchor !== null);

    // 스크롤 발생시
    window.addEventListener('scroll', () =&gt; {
        if (anchors.length &gt; 0 &amp;&amp; links.length &gt; 0) {
            let scrollTop = window.scrollY;
            let activeIndex = -1;

            // 스크롤 위치와 제목의 위치가 가까울 경우 (격차가 300 이하)
            // 활성화할 제목의 인덱스를 저장한다
            anchors.forEach((anchor, i) =&gt; {
                if (scrollTop &gt;= anchor.offsetTop - 300) {
                activeIndex = i; 
                }
            });

            // 나머지 제목은 비활성화 한다
            links.forEach((link) =&gt; {
                link.classList.remove('active');
            });
            
            // 인덱스가 유효하면 제목을 활성화한다
            if (activeIndex &gt;= 0) {
                links[activeIndex].classList.add('active');
            }
        }
  });
});
</code></pre></div></div>
<p>코드의 동작 원리는 주석을 참고하면 된다.</p>

<p>개인적으로 까다로웠던 점은 특정 깊이(h3)까지만 목차를 읽어오는 것이었다. 모든 제목이 하이라이트되는 것을 원하지 않았고 h4 이상부터는 상위 제목을 하이라이트하는 게 목차로서 의미가 있다고 판단했다.</p>

<p><code class="language-plaintext highlighter-rouge">querySelectorAll</code>를 사용해서 <em>모든</em> 제목의 a 태그를 바로 긁어올 수 있지만 <em>특정 깊이까지만</em> 읽어오기 위해서 H1부터 H3까지 직접 지정해서 읽어온 다음 그 안에서 a 태그를 가져오게 했다. 그 뿐만 아니라 숫자로 시작하는 제목(<a href="https://woocosmos.github.io/swift-start/#1-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%84%A0%ED%83%9D"> 예를 들면 … </a>)은 href를 읽어올 때 에러가 발생했기 때문에 애초에 지정한 만큼만 읽고 그 안에서 파싱하는 방식이 가장 깔끔하다고 생각했다.</p>

<p>또 지속적으로 마주했던 에러는 links와 anchors 변수가 빈 배열을 반환하는 문제였는데, 이는 DOMContentLoaded 이벤트를 조건으로 추가함으로써 해결했다.</p>

<p>하여, 나만의 sticky highlighted TOC 이 완성되었다<br />
<img src="https://github.com/user-attachments/assets/257eecc6-c39b-4063-b99b-3448b8167d64" alt="image" /></p>

<h3 id="gh-pages-생성">gh-pages 생성</h3>

<p>그러나 TOC 기능을 추가한 후 Github Pages에서 빌드/배포 실패가 떴다. 분명 로컬 서버에서는 잘 돌아갔는데 말이다.</p>

<p><img src="https://github.com/user-attachments/assets/1060cd1e-0e19-45df-a006-af55b13daf18" alt="image" width="60%" /></p>

<p>에러 메시지에 ‘Unknown tag toc’이라고 적힌 것으로 보아 Jekyll-toc 플러그인 쪽 문제로 보였다.<br />
실제로 Jekyll-toc 레포지토리의 이슈 채널에서 동일한 문제를 호소하는 글들을 확인할 수 있었다.</p>

<ul>
  <li><a href="https://github.com/toshimaru/jekyll-toc/issues/151">Is Github Pages not supported? #151</a></li>
  <li><a href="https://github.com/toshimaru/jekyll-toc/issues/29">TOC on GitHub Pages #29</a></li>
  <li><a href="https://github.com/toshimaru/jekyll-toc/issues/151">Is Github Pages not supported? #151</a></li>
</ul>

<blockquote>
  <p>GitHub Pages cannot build sites using unsupported plugins. If you want to use unsupported plugins, generate your site locally and then push your site’s static files to GitHub.</p>
</blockquote>

<p>이는 Github Pages 서비스에서 내가 사용한 toc 플러그인을 지원하지 않아 발생한 문제였다.
따라서 <strong>로컬로 사이트를 직접 빌드</strong>한 후 해당 내용을 배포하도록 하는 방법으로 문제를 해결할 수 있다. 이때 <code class="language-plaintext highlighter-rouge">gh-pages</code>라는 브랜치로 밀어넣고 root 경로로 설정해야 한다. 참고한 <a href="https://dqdongg.com/blog/github/2018/12/29/Blog-Jekyll-toc-plugin.html#fn:2">칼럼</a>은 여기.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 로컬에서 빌드한다</span>
jekyll build
<span class="c"># _site 폴더를 어딘가로 대피시킨다</span>
<span class="nb">mv</span> <span class="nt">-r</span> _site /path/to/tmp
git checkout <span class="nt">--orphan</span> gh-pages 
<span class="c"># 폴더를 비우고 _site 데이터를 다시 가져온다</span>
<span class="nb">rm</span> <span class="nt">-rf</span> <span class="k">*</span> 
<span class="nb">cp</span> <span class="nt">-r</span> /path/to/tmp/_site/<span class="k">*</span> ./
git add <span class="nt">-A</span>
git commit <span class="nt">-m</span> <span class="s2">"build locally and create gh-pages"</span>
git push origin gh-pages
</code></pre></div></div>
<p>브랜치를 생성할 때 <code class="language-plaintext highlighter-rouge">--orphan</code> 옵션을 추가한 이유는 부모(master)로부터 커밋 히스토리를 이어 받지 않은 독립적인 브랜치를 새로 만들기 위함이다. 마치 레포지토리 안에 새로운 레포지토리를 시작한다고 생각할 수 있겠다.</p>

<p>마지막으로는 레포지토리에서 Settings &gt; Pages &gt; Source 그리고 Branch를 gh-pages로 수정하면 된다
<img src="https://github.com/user-attachments/assets/e19c52f7-e095-4442-b0f0-12f2c59cbf1e" alt="image" /></p>

<p>문제는 이제 앞으로 변경사항을 반영할 때마다 _site 의 내용을 매번 옮겨놨다가 다른 데이터를 삭제하는 식으로 업데이트 해야 한다는 것이다. 위 과정은 향후 <strong>Github Actions를 활용해 자동화된 workflow로 구축</strong>할 예정이다.</p>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[요약 - 지금 이 블로그(woocosmos.github.io)를 구축한 전반적인 내용 - Jekyll 설치를 위해 ruby 개발 환경을 세팅한다 - 목적과 취향에 맞는 Jekyll 테마를 골라 fork 한다 - HTML/CSS/JavaScript를 활용하여 다양한 기능을 추가, 수정한다 개요 티스토리에서 운영하던 개발 블로그를 github.io 로 이관하는 작업을 진행하고 있다. 그 이유는 첫째, 티스토리에서 Markdown이 불안정하게 적용되기 때문이다. 둘째, HTML 및 JavaScript를 활용하여 자유자재로 커스터마이징할 수 있다는 점이 매력적으로 느껴졌기 때문이다. 물론 github.io 블로그는 카테고리 설정이 까다로워 대부분 태그 기반이라는 점, 그리고 검색이나 목차와 같은 기능은 직접 구현해야 한다는 번거로움이 단점으로 작용한다. 그러나 이참에 개발 블로그를 정식으로 세팅하고 JavaScript를 직접 부딪치며 배워보는 기회로 여겨보려 한다. 곧 게시물을 전부 이쪽으로 옮길 예정이지만 기존 티스토리 블로그도 열려 있으니 언제든 놀러오시라. 기본 세팅 github.io 블로그를 시작하기 위해서는 jekyll(지킬)을 세팅하는 것이 우선이다. Jekyll은 마크다운 언어로 작성한 텍스트를 정적 웹사이트로 생성해주는 변환 엔진이다. 한국어로 번역된 공식 문서를 이곳에서 확인할 수 있다. Ruby Jekyll은 Ruby 프로그램이기 때문에 Ruby를 먼저 설치해야 한다. 또한 Ruby의 라이브러리(즉, Gem)를 관리해주는 프레임워크인 RubyGems도 필요하다. OS에 따른 설치 방법은 공식 문서를 포함하여 다양한 칼럼에 소개되어 있으니 참고하면 되겠다. 개인적으로 Windows(회사 컴퓨터)와 Mac(개인 노트북)에 각각 Ruby를 설치하면서 다양한 트러블슈팅을 경험했는데, 대개 Ruby의 버전 관리 프레임워크인 rbenv로 설치를 관리하면서 많은 문제를 회피할 수 있었다. 특히 Ruby의 버전이 3.0.0 이상이어야 한다는 에러를 가장 많이 부딪혔는데 rbenv로 원하는 버전으로 지정함으로써 문제에서 벗어날 수 있었다. 해당 블로그 프로젝트는 ruby-3.2.0으로 빌드했다. 준비물의 순서로 정리하자면 rbenv → Ruby → gem → bundler → jekyll 이다. gem install jekyll 더하여 개발의 편의성을 위해 jekyll 로컬 서버를 띄우려면 github-pages를 설치하는 것이 좋다. 이를 활용하여 파일의 변경사항을 save할 때마다 바로 반영된 것을 확인할 수 있다. gem install github-pages jekyll server --force_polling 별도 옵션을 주지 않는 한 http://127.0.0.1:4000로 접속한다 --force_polling : 해당 플래그 옵션으로 블로그를 새로고침해서 바로 변경된 내용을 확인할 수 있다. 이를 설정하지 않으면 매번 로컬 서버를 내렸다가 다시 올려야 한다. Jekyll 테마 from scratch로 블로그를 구성하기보다는 특정 테마로 베이스 사이트를 세팅한 후에 기능을 추가하거나 변경하기로 했다. Jekyll 테마 사이트에서 목적과 취향에 맞는 테마를 골라보자. 결론적으로 한국어 가독성을 고려한 Kiko Now를 기본으로 하되, Tale이나 Catbook 등 다양한 테마를 레퍼런스로 삼아 기능을 추가하는 방향으로 진행했다. 이제 선택한 테마의 github 레포지토리로 이동하여 나의 레포지토리로 fork 해오면 된다. 이때 레포지토리 이름을 {username}.github.io로 설정하면 github에서 자동으로 해당 도메인으로 호스팅해준다. fork 직후에는 위 도메인으로 접속이 안 될 수도 있는데, 수 분 기다리거나 최소 하나의 변경 사항을 push 해주면 들어가진다. 마지막으로 작업 폴더에서 git clone하여 로컬 레포지토리를 생성한다. config 수정 대부분 Jekyll 테마에서 그렇듯 커스터마이징의 첫 단계는 _config.yml 파일을 수정하는 것이다. 블로그 이름, SNS 링크 등 기본적인 내용을 이곳에 입력하도록 되어 있다. 이제 기본적인 세팅은 끝이다. 바로 MD 파일을 생성해서 포스트를 업로드할 수 있다. 개인적으로는 약간 번거롭더라도 복구 가능성을 위해 항상 git branch로 작업 후 master에 merge 하는 편이다. git checkout -b post/blog-history vi _posts/2024-08-19-blog-history.md # 포스트 작성 후 ... git add . git commit -m '[post/init] 블로그 개발기' git push # master 에 반영 git checkout master git merge post/blog-history 브랜치 네임이나 커밋 메시지의 컨벤션은 스스로 아래와 같이 정했다. post/… : 블로그글 관련 브랜치 feature/… : 블로그 기능 관련 브랜치 [post/init] : 블로그글 최초 배포 커밋 [post/modi] : 이후 블로그글 수정 커밋 구글 검색 연동 내용 기능 추가 이제부터 이어지는 내용은 기능을 추가한 히스토리를 기록한 것이다. JavaScript를 잘 모르다보니 Workaround 형식으로 구현한 내용도 많다. 개선 지점은 언제든 덧글이나 연락처로 알려주시면 감사하겠다. disqus 덧글창 추가 내용 favicon 아이콘 추가 내용 back-to-top 버튼 구현 내용 커서에 따른 그라데이션 색상 변화 내용 페이지 레이아웃 수정 Tag 페이지 내용 Blog 페이지 내용 검색 페이지 추가 검색 기능 내용 검색 결과 하이라이트 내용 아바타 기울기 애니메이션 LaTex(수학 수식) 적용하기 LaTex를 렌더링해주는 KaTex 를 _includes/head.html의 head 부분에 추가한다. &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"&gt; &lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"&gt;&lt;/script&gt; &lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, { delimiters: [ {left: '\\[', right: '\\]', display: true}, {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, ] });"&gt; &lt;/script&gt; delimiter를 명시한 이유는 inline LaTex를 제대로 인식하지 못했던 문제 때문이다 명시한 이후에도 display LaTex가 적용되지 않는 문제가 있었다 : $$로 감싸도 \[\] 로 출력되었다 (사실 이것이 표준 display LaTex notation이라고 한다) 그래서 delimiter 항목으로 더 추가했다 이제 LaTex 문법대로 수식을 $ 기호 1개 혹은 2개 사이에 작성하면 알맞게 렌더링 된다 display LaTex \[\sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2}\] $$ \sum_{i=1}^{k} \sum_{\mathbf{x} \in S_{i}} \left\|\mathbf{x} - \boldsymbol{\mu}_{i}\right\|^{2} $$ inline LaTex 문장 중간에 이렇게 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다 문장 중간에 이런 수식을 $\sum_{\mathbf {x} \in S_{i}}\mathbf {x}$ 넣을 수 있다 목차(TOC) 추가 블로그글 옆 사이드바 형식의 목차를 추가한다. 아래는 플러그인을 설치해서 사용할 수 있는 jekyll-toc을 적용한 내용이다. 동일한 이름의 플러그인이 있는데, 후술할 Github Pages 이슈로부터 자유로운 것으로 보인다. 처음으로 돌아간다면 이것을 적용해볼지도… 설치 방법 Gemfile에 아래 라인을 추가한다 gem 'jekyll-toc' bundle로 설치를 진행한다 bundle install _config.yml 파일 중 플러그인 부분에 요소를 추가한다 plugins: - jekyll-sitemap ... - jekyll-toc # 추가 사용 방법 post 헤드에 toc 플래그를 추가한다 --- layout: post title: "Jekyll을 사용한 github.io 블로그 개발기" tags: [JavaScript] comments: True toc: true --- post.html에 toc을 추가한다. 단순히 {{ content | toc }}로 수정해서 본문 위에 목차가 생성되도록 하는 방법도 있지만 목차의 레이아웃이나 기능을 다양하게 커스터마이징 하기 위해 별도 태그인 {% toc %}로 추가했다. &lt;section class="entry"&gt; {% if page.toc %} &lt;aside&gt; &lt;nav class="nav-toc"&gt; &lt;h3&gt; 목차 &lt;/h3&gt; {% toc %} &lt;/nav&gt; &lt;/aside&gt; &lt;script src="{{ site.baseurl }}/assets/scroll-spy.js" type="text/javascript"&gt;&lt;/script&gt; {% endif %} {{ content }} &lt;/section&gt; {% if page.toc %} : 헤드에 toc 플래그를 명시한 경우에만 목차가 추가되게 했다. &lt;aside&gt; : 본문 옆 사이드바 형식으로 표시하기 위해 사용했다 &lt;nav&gt; : 목차의 제목을 클릭했을 때 해당 영역으로 이동하도록 링크를 연결하기 위해 사용했다 &lt;h3&gt; 목차 &lt;/h3&gt; : 플러그인으로 자동 생성되는 HTML에는 제목이 없길래 따로 추가해주었다 (사실 page.toc 조건을 굳이 넣은 것도 이 제목 때문이다. toc: false으로 세팅해도 h3 태그는 남아 있었기 때문이다.) 목차 레이아웃 목차의 위치와 모양을 세팅하는 과정이다. 목차를 본문 좌측에 맞추고 스크롤과 상관없이 상단에 고정시키기 aside { float: right; position: sticky; width: fit-content; top: 10px; margin-right: -300px; } position을 sticky로 설정하고 top값을 조금이라도 부여하면 스크롤과 상관없이 화면 한 쪽에 고정되는 효과를 구현할 수 있다 margin-right를 조정해서 본문과 너무 멀지도, 가깝지도 않게 위치시켰다 레이아웃을 심플하게 디자인하기 .nav-toc { font-size: smaller; border-left: 1px solid $lightGray; h3 { padding-left: 20px; } ul &gt; li { list-style-type: none; &amp;:before { content: ''; } ul { display: inline; } } ul &gt; li &gt; a.active { font-size: larger; font-weight: bold; } } 기본적으로 폰트 사이즈는 작게, 리스트 앞에 붙는 마커는 생략했다 list-style-type: none를 주었는데도 마커가 생성되어 &amp;:before {content: '';}를 별도로 추가했다 목차와 본문 사이 가는 구분선을 추가했다 (border-left) 일부 하위 목차들이 가로로 나열되는(?) 이상한 현상이 있어서 display: inline을 추가했다 목차가 하이라이트 대상일 때 폰트 사이즈와 굵기를 조금 키운다 목차 하이라이트 기능 스크롤의 위치에 따라 현재 보고 있는 콘텐츠의 목차를 하이라이트하는 기능이다. 위에서 toc 태그를 추가한 HTML 코드를 보면 scroll-spy.js라는 스크립트를 실행시키는 것을 볼 수 있는데, 이것이 스크롤 위치에 따라 하이라이트할 목차를 지정하는 역할을 한다. 전체 코드를 살펴보겠다. // 브라우저가 HTML을 전부 읽고 DOM 트리를 완성했을 때 발생하는 이벤트 document.addEventListener('DOMContentLoaded', () =&gt; { // links : H1, H2, H3 깊이 까지만 목차를 읽어온다 (a 태그 셀렉트) const Hs = document.querySelectorAll('.nav-toc ul.section-nav li.toc-entry.toc-h1, .nav-toc ul.section-nav li.toc-entry.toc-h2, .nav-toc ul.section-nav li.toc-entry.toc-h3'); const links = Array.from(Hs).map(h =&gt; { return h.querySelector('a') }) // anchors : links 의 각 요소로부터 href 를 읽어온다 const anchors = Array.from(links).map(link =&gt; { const href = link.getAttribute('href'); if (href) { return document.querySelector(href); } return null; }).filter(anchor =&gt; anchor !== null); // 스크롤 발생시 window.addEventListener('scroll', () =&gt; { if (anchors.length &gt; 0 &amp;&amp; links.length &gt; 0) { let scrollTop = window.scrollY; let activeIndex = -1; // 스크롤 위치와 제목의 위치가 가까울 경우 (격차가 300 이하) // 활성화할 제목의 인덱스를 저장한다 anchors.forEach((anchor, i) =&gt; { if (scrollTop &gt;= anchor.offsetTop - 300) { activeIndex = i; } }); // 나머지 제목은 비활성화 한다 links.forEach((link) =&gt; { link.classList.remove('active'); }); // 인덱스가 유효하면 제목을 활성화한다 if (activeIndex &gt;= 0) { links[activeIndex].classList.add('active'); } } }); }); 코드의 동작 원리는 주석을 참고하면 된다. 개인적으로 까다로웠던 점은 특정 깊이(h3)까지만 목차를 읽어오는 것이었다. 모든 제목이 하이라이트되는 것을 원하지 않았고 h4 이상부터는 상위 제목을 하이라이트하는 게 목차로서 의미가 있다고 판단했다. querySelectorAll를 사용해서 모든 제목의 a 태그를 바로 긁어올 수 있지만 특정 깊이까지만 읽어오기 위해서 H1부터 H3까지 직접 지정해서 읽어온 다음 그 안에서 a 태그를 가져오게 했다. 그 뿐만 아니라 숫자로 시작하는 제목( 예를 들면 … )은 href를 읽어올 때 에러가 발생했기 때문에 애초에 지정한 만큼만 읽고 그 안에서 파싱하는 방식이 가장 깔끔하다고 생각했다. 또 지속적으로 마주했던 에러는 links와 anchors 변수가 빈 배열을 반환하는 문제였는데, 이는 DOMContentLoaded 이벤트를 조건으로 추가함으로써 해결했다. 하여, 나만의 sticky highlighted TOC 이 완성되었다 gh-pages 생성 그러나 TOC 기능을 추가한 후 Github Pages에서 빌드/배포 실패가 떴다. 분명 로컬 서버에서는 잘 돌아갔는데 말이다. 에러 메시지에 ‘Unknown tag toc’이라고 적힌 것으로 보아 Jekyll-toc 플러그인 쪽 문제로 보였다. 실제로 Jekyll-toc 레포지토리의 이슈 채널에서 동일한 문제를 호소하는 글들을 확인할 수 있었다. Is Github Pages not supported? #151 TOC on GitHub Pages #29 Is Github Pages not supported? #151 GitHub Pages cannot build sites using unsupported plugins. If you want to use unsupported plugins, generate your site locally and then push your site’s static files to GitHub. 이는 Github Pages 서비스에서 내가 사용한 toc 플러그인을 지원하지 않아 발생한 문제였다. 따라서 로컬로 사이트를 직접 빌드한 후 해당 내용을 배포하도록 하는 방법으로 문제를 해결할 수 있다. 이때 gh-pages라는 브랜치로 밀어넣고 root 경로로 설정해야 한다. 참고한 칼럼은 여기. # 로컬에서 빌드한다 jekyll build # _site 폴더를 어딘가로 대피시킨다 mv -r _site /path/to/tmp git checkout --orphan gh-pages # 폴더를 비우고 _site 데이터를 다시 가져온다 rm -rf * cp -r /path/to/tmp/_site/* ./ git add -A git commit -m "build locally and create gh-pages" git push origin gh-pages 브랜치를 생성할 때 --orphan 옵션을 추가한 이유는 부모(master)로부터 커밋 히스토리를 이어 받지 않은 독립적인 브랜치를 새로 만들기 위함이다. 마치 레포지토리 안에 새로운 레포지토리를 시작한다고 생각할 수 있겠다. 마지막으로는 레포지토리에서 Settings &gt; Pages &gt; Source 그리고 Branch를 gh-pages로 수정하면 된다 문제는 이제 앞으로 변경사항을 반영할 때마다 _site 의 내용을 매번 옮겨놨다가 다른 데이터를 삭제하는 식으로 업데이트 해야 한다는 것이다. 위 과정은 향후 Github Actions를 활용해 자동화된 workflow로 구축할 예정이다.]]></summary></entry></feed>