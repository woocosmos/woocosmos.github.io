<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://woocosmos.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://woocosmos.github.io/" rel="alternate" type="text/html" /><updated>2026-02-19T23:23:56+09:00</updated><id>https://woocosmos.github.io/feed.xml</id><title type="html">YunsooLog</title><subtitle>행간을 읽는 기계학습 이야기</subtitle><entry><title type="html">Windows 옵시디언 앱에서 git username/password 를 계속 요구하는 문제</title><link href="https://woocosmos.github.io/obsidian-git-auth/" rel="alternate" type="text/html" title="Windows 옵시디언 앱에서 git username/password 를 계속 요구하는 문제" /><published>2026-02-19T00:00:00+09:00</published><updated>2026-02-19T00:00:00+09:00</updated><id>https://woocosmos.github.io/obsidian-git-auth</id><content type="html" xml:base="https://woocosmos.github.io/obsidian-git-auth/"><![CDATA[<blockquote>
  <p>WSL이 아니라 <strong>Windows PowerShell/CMD</strong> 에서 한 번 자격 증명을 해줘야 된다!</p>
</blockquote>

<h2 id="문제-상황">문제 상황</h2>

<ul>
  <li>Windows 옵시디언 앱에서 Obsidian-git 플러그인을 활성화 했으며, 터미널 환경은 WSL 을 사용하고 있었다</li>
  <li>SSH 방식의 인증은 permisson denied 에러가 계속 발생하였다 (터미널에서는 되는데, 옵시디언 앱에서 안 되는 현상)</li>
  <li>HTTP 방식의 인증은 계속해서 username/password 를 요구하였다 (터미널에서는 <code class="language-plaintext highlighter-rouge">git config --global user.name ...  </code> 요 방식으로 해결됨)</li>
</ul>

<h2 id="해결-방법">해결 방법</h2>

<ul>
  <li>Windows PowerShell 이나 CMD 에서 Git Credential Manager 로 로그인해야 obsidian-git 이 해당 자격증명을 사용한다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 출력되는 것 확인
git config --global --get credential.helper 

# 아무것도 없거나, manager 가 아니라면 아래 실행
git config --global credential.helper manager

# obsidian 경로에서 로그인 (Github 로그인 창)
git fetch
</code></pre></div></div>]]></content><author><name></name></author><category term="생산성" /><summary type="html"><![CDATA[WSL이 아니라 Windows PowerShell/CMD 에서 한 번 자격 증명을 해줘야 된다! 문제 상황 Windows 옵시디언 앱에서 Obsidian-git 플러그인을 활성화 했으며, 터미널 환경은 WSL 을 사용하고 있었다 SSH 방식의 인증은 permisson denied 에러가 계속 발생하였다 (터미널에서는 되는데, 옵시디언 앱에서 안 되는 현상) HTTP 방식의 인증은 계속해서 username/password 를 요구하였다 (터미널에서는 git config --global user.name ... 요 방식으로 해결됨) 해결 방법 Windows PowerShell 이나 CMD 에서 Git Credential Manager 로 로그인해야 obsidian-git 이 해당 자격증명을 사용한다 # 출력되는 것 확인 git config --global --get credential.helper # 아무것도 없거나, manager 가 아니라면 아래 실행 git config --global credential.helper manager # obsidian 경로에서 로그인 (Github 로그인 창) git fetch]]></summary></entry><entry><title type="html">옵시디언(Obsidian)을 세팅해보자 - git 활용한 아이폰 동기화까지</title><link href="https://woocosmos.github.io/obsidian/" rel="alternate" type="text/html" title="옵시디언(Obsidian)을 세팅해보자 - git 활용한 아이폰 동기화까지" /><published>2026-02-16T00:00:00+09:00</published><updated>2026-02-16T00:00:00+09:00</updated><id>https://woocosmos.github.io/obsidian</id><content type="html" xml:base="https://woocosmos.github.io/obsidian/"><![CDATA[<p><strong>요약</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 옵시디언을 설치하고 vault, 노트 링크, 그래프 뷰 등 기본 기능을 살펴본다
  - Git 플러그인으로 데스크탑 동기화를 설정하고, aShell을 활용해 아이폰에서도 SSH 기반 git 동기화를 구현한다
  - iOS 단축어를 연동하여 옵시디언 앱의 열기/닫기 시 자동 pull/push가 되도록 설정한다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p>나만의 <strong>지식 데이터베이스</strong>를 구축하기 위해 옵시디언을 세팅하려 한다.</p>

<p>최근 <a href="https://help.obsidian.md/cli">공식 CLI</a>를 지원한다고 하여 다른 메모 앱보다 에이전트에 친화적이라는 생각이 들기 때문이다.</p>

<p>기존에 사용하던 어플리케이션의 불편함을 짚어보자면,</p>

<table>
  <thead>
    <tr>
      <th>앱</th>
      <th>문제점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>노션</td>
      <td>무겁고 군더더기가 너무 많음</td>
    </tr>
    <tr>
      <td>iOS 메모앱</td>
      <td>포맷팅이 불편하고 너무 가벼워 메모가 휘발적임</td>
    </tr>
  </tbody>
</table>

<p>(가만 생각해보니 이제껏 나만의 지식 데이터베이스의 역할을 해주던 건 “카카오톡 나에게 보내기” 기능이었다)</p>

<h1 id="시작">시작</h1>

<p><img src="/images/obsidian_00.png" alt="image" width="80%" /></p>

<p><a href="https://obsidian.md/">Obsidian</a> 공홈에서 MacOS 앱을 받아 설치했다. 오른편의 Graph View가 눈에 띈다.</p>

<p><code class="language-plaintext highlighter-rouge">vault</code>는 md 파일들이 저장되는 root 폴더를 가리킨다.</p>

<p><code class="language-plaintext highlighter-rouge">link</code>는 내외부 리소스와 연결해주는 방식이고, <code class="language-plaintext highlighter-rouge">importer</code>는 외부의 리소스를 마이그레이션해올 수 있는 플러그인이다.</p>

<p><img src="/images/obsidian_01.png" alt="image" width="80%" /></p>

<p>새 노트를 생성한 다음 내용을 작성해보았다.</p>

<p>이때 특정 키워드를 <code class="language-plaintext highlighter-rouge">[[이런 식]]</code>으로 감싸주면, 그 키워드를 제목으로 하는 새 노트를 작성할 수 있는 링크가 생성된다.</p>

<p>이렇게 노트끼리 서로 참조할 수 있다.</p>

<p><img src="/images/obsidian_02.png" alt="image" width="80%" /></p>

<p>그래프 뷰를 통해 노트 간 관계를 확인할 수 있다. 또 <code class="language-plaintext highlighter-rouge">#태그</code> 형식으로 태그 기능을 사용할 수 있다.</p>

<p>추가로 비교적 최근에 공식 도입된 <em>base</em> 기능은 노션의 데이터베이스와 유사하게 사용할 수 있다고 하는데 …</p>

<p>슥 둘러 봤을 땐 index 기능에 더 가까운 것 같다.</p>

<p>아직은 입문 단계니까 base 는 패스.</p>

<h1 id="git-연동">git 연동</h1>

<p>Obsidian Sync 는 유료 기능이기 때문에, git을 활용하여 무료로 데이터를 동기화할 수 있다.</p>

<ol>
  <li>
    <p>github 에 private repository 를 생성한다.</p>
  </li>
  <li>
    <p>옵시디언의 설정 &gt; Community Plugins &gt; Git 설치한다.</p>
  </li>
  <li>vault 가 위치한 경로로 가서 git init 해준다.
    <ul>
      <li>왼쪽 하단 vault 이름을 클릭하면 manage vaults 가 뜨는데, 거기서 로컬 파일 시스템 내 어디에 위치하는지 경로가 보인다.</li>
      <li>나의 경우, /Users/<code class="language-plaintext highlighter-rouge">&lt;내 이름&gt;</code>/Documents 에 있었음</li>
    </ul>

    <p><img src="/images/obsidian_03.png" alt="image" width="80%" /></p>
  </li>
  <li>git 플러그인 설정에서 자동 sync 모드를 켜준다.
    <ul>
      <li>옵시디언 화면에서 git commit/push 등 동작을 버튼으로 수행할 수 있게 된다.</li>
    </ul>
  </li>
</ol>

<p>참고로 passphrase 를 입력하라는 창이 계속 떴었는데, vault 폴더에서 .git/config 의 url 정보를 아래와 같이 변경하니 바로 push 할 수 있게 되었다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 수정 전
[remote "origin"]
	url = git@github.com:&lt;계정명&gt;/&lt;레포 이름&gt;.git

# 수정 후
[remote "origin"]
	url = https://github.com/&lt;계정명&gt;/&lt;레포 이름&gt;.git
</code></pre></div></div>

<p>처음에 ssh 인증 방식을 사용했기 때문에 키에 대한 비밀번호를 요구했던 것 같다.</p>

<h1 id="아이폰에서의-연동">아이폰에서의 연동</h1>

<p>이전에는 obsidian-git 플러그인이 iOS 를 지원하지 않아,</p>

<p><em>working copy</em> 등 다른 git 클라이언트 앱을 통해 동기화를 해야 했던 것으로 보인다.</p>

<p>2026년 2월 현재는 어떨까.</p>

<p><a href="https://github.com/Vinzent03/obsidian-git?tab=readme-ov-file#-mobile-support-%EF%B8%8F--experimental">obsidian-git 공식 리드미</a>에 따르면 모바일 환경에서는 메모리 이슈 등 동작이 불안정하다는 것을 경고하고 있다. (그냥 안 된다고 봐야 할 듯)</p>

<p>선택지는 두 개 정도로 좁혀진다.</p>
<ul>
  <li>Gitsync (repo 한 개까지 무료라는 얘길 봄) 같은 git 클라앱을 사용하거나,</li>
  <li>iSH 같은 터미널 앱을 깔아 git 명령어를 입력하는 것.</li>
</ul>

<p>일단 자동 push 기능은 아이폰의 단축어로 구현해야 할 텐데, iSH 와 단축어 기능을 연동하기 어렵다는 논의가 보인다. - <a href="https://github.com/ish-app/ish/issues/1289">Can we run Shortcuts by a command ?</a></p>

<p>반면 <a href="https://github.com/holzschu/a-shell?tab=readme-ov-file#shortcuts">aShell 은 될 것 같은 느낌</a>.</p>

<p>우선 … <strong>aShell 로 동기화 도전!</strong></p>

<p>참고한 포럼 - <a href="https://forum.obsidian.md/t/mobile-automatic-sync-with-github-on-ios-for-free-via-a-shell/46150?page=2">[Mobile] Automatic sync with GitHub on iOS (for free) via a-shell</a></p>

<h2 id="1-앱-설치">1. 앱 설치</h2>

<p>(1) 앱스토어에서 Obsidian 앱을 설치한다 - create a new vault 로 진행 (이름은 Temp)</p>

<p>(2) 앱스토에서 aShell mini 앱을 설치한다</p>

<p>(3) aShell 에서 <code class="language-plaintext highlighter-rouge">pickFolder</code> 명령어 입력 &gt; 내 아이폰에서 Obsidian 폴더를 찾아 선택해준다</p>

<div style="display:flex; gap:8px;">
  <img src="/images/obsidian_04.png" width="45%" />
  <img src="/images/obsidian_05.png" width="45%" />
</div>

<p>1번 과정에서 설정한 Temp 가 보이는 상태</p>

<h2 id="2-ssh-키-등록">2. SSH 키 등록</h2>

<p>aShell 에서 SSH 키를 생성</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen -t ed25519 -C "&lt;이메일&gt;@gmail.com"
</code></pre></div></div>

<p>~home 으로 가서 .ssh/ 위치의 id_ed25519.pub 를 출력한다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head id_ed25519.pub
</code></pre></div></div>

<p>출력된 내용을 복사해서 github 의 ssh 관리탭에 키를 추가해준다.</p>

<h2 id="3-github-동기화">3. github 동기화</h2>

<p>다시 아까의 옵시디언 폴더로 돌아간다.</p>

<p>앞서 만든 vault 폴더명을 <code class="language-plaintext highlighter-rouge">ios-vault</code> 로 이름을 변경해준다음 cd ios-vault 했다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lg2 init .
lg2 remote add origin git@github.com:USERNAME/REPO-NAME.git
lg2 pull origin
</code></pre></div></div>

<p>host/key pair 를 등록할 거냐는 애스크가 뜰 텐데 y 를 입력하면 된다.</p>

<p><img src="/images/obsidian_06.png" alt="image" width="80%" /></p>

<p><strong>git 으로부터 데이터가 불러와졌다!!</strong></p>

<p><img src="/images/obsidian_07.jpeg" alt="image" width="40%" /></p>

<p>마지막으로 세팅. 출력된 내용 중에서 <em>Consider running</em> 다음으로 나온 명령어들을 붙여 넣고 실행한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lg2 config user.name "계정명"
lg2 config user.email "이메일 주소"
</code></pre></div></div>

<p>이렇게 git 사용을 위한 user 정보 설정까지 마친다.</p>

<h2 id="4-push-테스트">4. push 테스트</h2>

<p>아이폰에서 수정한 내역을 push 하고, 맥 데스크탑앱에서 pull 하는 간단한 실험을 진행한다.</p>

<p>(브랜치명이 master 로 되어 있어서 중간에 엄청 삽질하고, 갑자기 not a valid reference ‘main’ 같은 에러가 뜨면서 push가 안 되기도 했음)</p>

<p>(1) 아이폰 obsidian 앱에서 수정</p>

<p>(2) (제발 브랜치명 확인하기)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lg2 checkout main
</code></pre></div></div>

<p>(3) lg2 status 확인 후,</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lg2 add . &amp; lg2 commit -m 'init commit from iPhone'
</code></pre></div></div>

<p>(4) push 한다</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lg2 push origin main
</code></pre></div></div>
<p>여기서 not a valid reference ‘main’ 에러가 뜨기도 했는데 <code class="language-plaintext highlighter-rouge">lg2 push origin refs/heads/main</code> 이렇게 명시했을 때 성공</p>

<p>(5) 웹에서 push 됐는지 확인하고, 데스크탑에서 pull 버튼을 눌러주면 …</p>

<p><img src="/images/obsidian_08.png" alt="image" width="80%" /></p>

<p>성공 ㅠㅠ</p>

<h2 id="5-단축어-설정">5. 단축어 설정</h2>

<p>단축어 설정을 하려면 jump 명령어로 obsidian 폴더에 접근할 수 있어야 한다.</p>

<p>showmarks 를 입력해서 출력 결과를 보면 북마크명이 obsidian 이 아니라 Documents 라는 이름으로 되어 있는데, 이걸 이렇게 바꿔준다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>renamemark Documents obsidian
</code></pre></div></div>

<p>이제 <code class="language-plaintext highlighter-rouge">jump obsidian</code> 명령어로 폴더로 이동할 수 있다. (iOS의 aShell은 bookmark 기반 접근을 이용하기 때문이라고 함)</p>

<h4 id="자동-pull">자동 pull</h4>

<p>(1) 아이폰의 단축어 앱에서 ‘자동화’ 탭으로 간다</p>

<p>(2) 새로운 개인용 자동화를 선택하여 “앱” 을 클릭한다</p>

<p><img src="/images/obsidian_09.png" alt="image" width="40%" /></p>
<ul>
  <li>Obsidian 앱이 열릴 때를 조건으로 한다</li>
</ul>

<p>(3) 동작에서 새로운 단축어를 생성, a-shell mini 를 선택해 “명령 실행” 을 선택한다</p>

<p>(4) 셸 명령어는 차례대로 아래와 같이 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jump obsidian
cd &lt;vault 이름&gt;
lg2 pull origin
</code></pre></div></div>

<p>(5) obsidian 앱을 열 때마다 단축어 실행 팝업이 뜬다</p>

<p><img src="/images/obsidian_10.png" alt="image" width="40%" /></p>

<h4 id="자동-push">자동 push</h4>

<p>(1) 똑같이 아이폰 단축어에서 자동화를 추가하여 Obsidian 이 닫힐 때를 조건으로 한다</p>

<p>(2) 동작에서 새로운 단축어를 생성, 이번에는 commit 일시를 기록하기 위해 변수를 설정해준다</p>
<ul>
  <li>스크립트 하기 &gt; 변수 설정 &gt; 현재 날짜</li>
</ul>

<p>(3) a-shell mini 를 선택해 “명령 실행” 으로 아래와 같이 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jump obsidian
cd &lt;vault 이름&gt;
lg2 add .
lg2 commit -m "commit from iPhone &lt;시간 변수&gt;"
lg2 push origin refs/heads/main
</code></pre></div></div>

<p><img src="/images/obsidian_11.png" alt="image" width="80%" /></p>

<p>실제 commit 메세지도 잘 설정된 것을 확인하였다.</p>

<h1 id="정리">정리</h1>

<p>오늘 obsidian 을 처음 입문하면서, 켠 김에 모바일 자동 동기화까지 완료했다.</p>

<p>obsidian 유료 서비스 쓰기 싫다고 돌고 돌아 온 느낌이 있지만 ㅋㅋㅋ</p>

<p>이 과정에서 상당히 많이 배울 수 있었다. 특히 폰으로 리눅스 만져보는 건 완전히 새로운 경험!</p>

<p>그 다음으로는 obsidian 데이터베이스를 RAG 으로 긁어와 LLM 개인비서가 참고할 수 있게 하는 시스템을 만들어 보고 싶은데.</p>

<p>아니면 LLM 이 자동으로 금융 뉴스 스크랩핑 해서 obsidian 에 데이터 쌓고 참조하게 만드는 것도 좋겠다.</p>

<p>하여튼, 그 프로젝트를 실행하기 전까지 obsidian과 친해지는 시간을 충분히 가져야겠다.</p>]]></content><author><name></name></author><category term="생산성" /><summary type="html"><![CDATA[요약 - 옵시디언을 설치하고 vault, 노트 링크, 그래프 뷰 등 기본 기능을 살펴본다 - Git 플러그인으로 데스크탑 동기화를 설정하고, aShell을 활용해 아이폰에서도 SSH 기반 git 동기화를 구현한다 - iOS 단축어를 연동하여 옵시디언 앱의 열기/닫기 시 자동 pull/push가 되도록 설정한다 개요 나만의 지식 데이터베이스를 구축하기 위해 옵시디언을 세팅하려 한다. 최근 공식 CLI를 지원한다고 하여 다른 메모 앱보다 에이전트에 친화적이라는 생각이 들기 때문이다. 기존에 사용하던 어플리케이션의 불편함을 짚어보자면, 앱 문제점 노션 무겁고 군더더기가 너무 많음 iOS 메모앱 포맷팅이 불편하고 너무 가벼워 메모가 휘발적임 (가만 생각해보니 이제껏 나만의 지식 데이터베이스의 역할을 해주던 건 “카카오톡 나에게 보내기” 기능이었다) 시작 Obsidian 공홈에서 MacOS 앱을 받아 설치했다. 오른편의 Graph View가 눈에 띈다. vault는 md 파일들이 저장되는 root 폴더를 가리킨다. link는 내외부 리소스와 연결해주는 방식이고, importer는 외부의 리소스를 마이그레이션해올 수 있는 플러그인이다. 새 노트를 생성한 다음 내용을 작성해보았다. 이때 특정 키워드를 [[이런 식]]으로 감싸주면, 그 키워드를 제목으로 하는 새 노트를 작성할 수 있는 링크가 생성된다. 이렇게 노트끼리 서로 참조할 수 있다. 그래프 뷰를 통해 노트 간 관계를 확인할 수 있다. 또 #태그 형식으로 태그 기능을 사용할 수 있다. 추가로 비교적 최근에 공식 도입된 base 기능은 노션의 데이터베이스와 유사하게 사용할 수 있다고 하는데 … 슥 둘러 봤을 땐 index 기능에 더 가까운 것 같다. 아직은 입문 단계니까 base 는 패스. git 연동 Obsidian Sync 는 유료 기능이기 때문에, git을 활용하여 무료로 데이터를 동기화할 수 있다. github 에 private repository 를 생성한다. 옵시디언의 설정 &gt; Community Plugins &gt; Git 설치한다. vault 가 위치한 경로로 가서 git init 해준다. 왼쪽 하단 vault 이름을 클릭하면 manage vaults 가 뜨는데, 거기서 로컬 파일 시스템 내 어디에 위치하는지 경로가 보인다. 나의 경우, /Users/&lt;내 이름&gt;/Documents 에 있었음 git 플러그인 설정에서 자동 sync 모드를 켜준다. 옵시디언 화면에서 git commit/push 등 동작을 버튼으로 수행할 수 있게 된다. 참고로 passphrase 를 입력하라는 창이 계속 떴었는데, vault 폴더에서 .git/config 의 url 정보를 아래와 같이 변경하니 바로 push 할 수 있게 되었다. # 수정 전 [remote "origin"] url = git@github.com:&lt;계정명&gt;/&lt;레포 이름&gt;.git # 수정 후 [remote "origin"] url = https://github.com/&lt;계정명&gt;/&lt;레포 이름&gt;.git 처음에 ssh 인증 방식을 사용했기 때문에 키에 대한 비밀번호를 요구했던 것 같다. 아이폰에서의 연동 이전에는 obsidian-git 플러그인이 iOS 를 지원하지 않아, working copy 등 다른 git 클라이언트 앱을 통해 동기화를 해야 했던 것으로 보인다. 2026년 2월 현재는 어떨까. obsidian-git 공식 리드미에 따르면 모바일 환경에서는 메모리 이슈 등 동작이 불안정하다는 것을 경고하고 있다. (그냥 안 된다고 봐야 할 듯) 선택지는 두 개 정도로 좁혀진다. Gitsync (repo 한 개까지 무료라는 얘길 봄) 같은 git 클라앱을 사용하거나, iSH 같은 터미널 앱을 깔아 git 명령어를 입력하는 것. 일단 자동 push 기능은 아이폰의 단축어로 구현해야 할 텐데, iSH 와 단축어 기능을 연동하기 어렵다는 논의가 보인다. - Can we run Shortcuts by a command ? 반면 aShell 은 될 것 같은 느낌. 우선 … aShell 로 동기화 도전! 참고한 포럼 - [Mobile] Automatic sync with GitHub on iOS (for free) via a-shell 1. 앱 설치 (1) 앱스토어에서 Obsidian 앱을 설치한다 - create a new vault 로 진행 (이름은 Temp) (2) 앱스토에서 aShell mini 앱을 설치한다 (3) aShell 에서 pickFolder 명령어 입력 &gt; 내 아이폰에서 Obsidian 폴더를 찾아 선택해준다 1번 과정에서 설정한 Temp 가 보이는 상태 2. SSH 키 등록 aShell 에서 SSH 키를 생성 ssh-keygen -t ed25519 -C "&lt;이메일&gt;@gmail.com" ~home 으로 가서 .ssh/ 위치의 id_ed25519.pub 를 출력한다 head id_ed25519.pub 출력된 내용을 복사해서 github 의 ssh 관리탭에 키를 추가해준다. 3. github 동기화 다시 아까의 옵시디언 폴더로 돌아간다. 앞서 만든 vault 폴더명을 ios-vault 로 이름을 변경해준다음 cd ios-vault 했다. lg2 init . lg2 remote add origin git@github.com:USERNAME/REPO-NAME.git lg2 pull origin host/key pair 를 등록할 거냐는 애스크가 뜰 텐데 y 를 입력하면 된다. git 으로부터 데이터가 불러와졌다!! 마지막으로 세팅. 출력된 내용 중에서 Consider running 다음으로 나온 명령어들을 붙여 넣고 실행한다. lg2 config user.name "계정명" lg2 config user.email "이메일 주소" 이렇게 git 사용을 위한 user 정보 설정까지 마친다. 4. push 테스트 아이폰에서 수정한 내역을 push 하고, 맥 데스크탑앱에서 pull 하는 간단한 실험을 진행한다. (브랜치명이 master 로 되어 있어서 중간에 엄청 삽질하고, 갑자기 not a valid reference ‘main’ 같은 에러가 뜨면서 push가 안 되기도 했음) (1) 아이폰 obsidian 앱에서 수정 (2) (제발 브랜치명 확인하기) lg2 checkout main (3) lg2 status 확인 후, lg2 add . &amp; lg2 commit -m 'init commit from iPhone' (4) push 한다 lg2 push origin main 여기서 not a valid reference ‘main’ 에러가 뜨기도 했는데 lg2 push origin refs/heads/main 이렇게 명시했을 때 성공 (5) 웹에서 push 됐는지 확인하고, 데스크탑에서 pull 버튼을 눌러주면 … 성공 ㅠㅠ 5. 단축어 설정 단축어 설정을 하려면 jump 명령어로 obsidian 폴더에 접근할 수 있어야 한다. showmarks 를 입력해서 출력 결과를 보면 북마크명이 obsidian 이 아니라 Documents 라는 이름으로 되어 있는데, 이걸 이렇게 바꿔준다. renamemark Documents obsidian 이제 jump obsidian 명령어로 폴더로 이동할 수 있다. (iOS의 aShell은 bookmark 기반 접근을 이용하기 때문이라고 함) 자동 pull (1) 아이폰의 단축어 앱에서 ‘자동화’ 탭으로 간다 (2) 새로운 개인용 자동화를 선택하여 “앱” 을 클릭한다 Obsidian 앱이 열릴 때를 조건으로 한다 (3) 동작에서 새로운 단축어를 생성, a-shell mini 를 선택해 “명령 실행” 을 선택한다 (4) 셸 명령어는 차례대로 아래와 같이 설정 jump obsidian cd &lt;vault 이름&gt; lg2 pull origin (5) obsidian 앱을 열 때마다 단축어 실행 팝업이 뜬다 자동 push (1) 똑같이 아이폰 단축어에서 자동화를 추가하여 Obsidian 이 닫힐 때를 조건으로 한다 (2) 동작에서 새로운 단축어를 생성, 이번에는 commit 일시를 기록하기 위해 변수를 설정해준다 스크립트 하기 &gt; 변수 설정 &gt; 현재 날짜 (3) a-shell mini 를 선택해 “명령 실행” 으로 아래와 같이 설정 jump obsidian cd &lt;vault 이름&gt; lg2 add . lg2 commit -m "commit from iPhone &lt;시간 변수&gt;" lg2 push origin refs/heads/main 실제 commit 메세지도 잘 설정된 것을 확인하였다. 정리 오늘 obsidian 을 처음 입문하면서, 켠 김에 모바일 자동 동기화까지 완료했다. obsidian 유료 서비스 쓰기 싫다고 돌고 돌아 온 느낌이 있지만 ㅋㅋㅋ 이 과정에서 상당히 많이 배울 수 있었다. 특히 폰으로 리눅스 만져보는 건 완전히 새로운 경험! 그 다음으로는 obsidian 데이터베이스를 RAG 으로 긁어와 LLM 개인비서가 참고할 수 있게 하는 시스템을 만들어 보고 싶은데. 아니면 LLM 이 자동으로 금융 뉴스 스크랩핑 해서 obsidian 에 데이터 쌓고 참조하게 만드는 것도 좋겠다. 하여튼, 그 프로젝트를 실행하기 전까지 obsidian과 친해지는 시간을 충분히 가져야겠다.]]></summary></entry><entry><title type="html">[라즈베리 파이를 활용한 홈서버 구축] 01. 킥오프</title><link href="https://woocosmos.github.io/raspberry-pi-01/" rel="alternate" type="text/html" title="[라즈베리 파이를 활용한 홈서버 구축] 01. 킥오프" /><published>2024-12-22T00:00:00+09:00</published><updated>2024-12-22T00:00:00+09:00</updated><id>https://woocosmos.github.io/raspberry-pi-01</id><content type="html" xml:base="https://woocosmos.github.io/raspberry-pi-01/"><![CDATA[<h1 id="개요">개요</h1>

<p><img src="https://github.com/user-attachments/assets/3950b7db-9f10-4797-983e-d1e389cab2c2" alt="image" width="60%" /></p>

<p>라즈베리 파이(Raspberry Pi)를 활용한 홈서버 구축 프로젝트를 시작하려 한다. 이번 포스트에서는 프로젝트의 목적과 목표를 명확히 하고, 그에 맞춰 필요한 제품 스펙을 결정하는 과정을 기록한다.</p>

<h1 id="계기">계기</h1>

<blockquote>
  <p>며칠 전, 회사 워크숍에서 버킷리스트를 작성하는 시간을 가졌다. 다들 세계여행이나 내 집 마련 같은 것을 적었는데, 나는 홈서버 구축하기를 쓰고 있었다.
그러고 보니 인생 버킷리스트까지도 아니고 <em>그냥 당장 실행하면 되지 않을까?</em> 라는 생각이 들었다.</p>
</blockquote>

<p>작은 자취방에서 가지고 놀 수 있는 <strong>작은 컴퓨터</strong>를 갖고 싶다는 생각에서 시작했다. 운영체제는 리눅스로 해서 CLI 개발 환경의 고수가 되고 싶었다. VSCode 대신에 Vim 으로 코드를 작성하는 지독한 컨셉의 개발자가 되고 싶었다. (이건 농담이다)</p>

<p>지금까지 지나온 개발 환경을 순서대로 짚어보았다.</p>

<ol>
  <li><strong>구글 코랩</strong> : 밑바닥부터 시작하는 데 이만한 도구가 있을까. 버튼 클릭 하나로 구글 데이터센터의 고성능 GPU 를 사용할 수 있었다.</li>
  <li><strong>클라우드 서버</strong> : 프로젝트가 본격화되면서 코랩의 사용량 제한이 걸림돌으로 작용했다. 이에 AWS EC2 스팟 인스턴스를 하나 구입해서 사용하기 시작했다.</li>
  <li><strong>온프레미스 서버</strong> : 국가 사업에 선정되면서 그래픽 카드를 마련할 수 있게 되었다. 사무실 한 켠에서 열과 소음을 뿜어내던 그 녀석을 SSH 로 접근해서 마음대로 다뤄볼 수 있었다.</li>
  <li>(<em>현재</em>) <strong>로컬 환경</strong> : 이직하고 보니 컴퓨터마다 좋은 그래픽 카드가 하나씩 꽂혀 있었다. (스타트업에 있다 와서 그런지 충격적이었다) 물론 서버 인스턴스만큼은 넉넉하지 않지만, 적당한 크기의 모델 학습이나 추론은 로컬 환경에서도 거뜬했다.</li>
</ol>

<p>특히 LLM 모델이 거대화되고 API 로 접근하는 방식이 널리 퍼지면서 오히려 로컬 환경에서 개발하기 편리해졌다고 느낀다. 그러나 반대 급부로 그만한 사이즈의 모델을 튜닝하거나 다루기 위해서는 <strong>서버 환경에서의 개발 역량</strong> 또한 놓칠 수 없다고 생각한다.</p>

<p>아쉽지만 현재 회사에서는 프로젝트 상 로컬 환경을 활용하는 것이 최선이므로, 개인적으로 홈서버를 구축하고 스스로 연습하려는 것이다. 먼 이야기지만 나중에 회사에서 서버 인스턴스를 할당 받았을 때 실수나 사고 없이 안정적으로 해내는 모습을 보여드리고 싶기도 하고.</p>

<p><img src="https://github.com/user-attachments/assets/843ec181-9048-4cd4-be37-9a04ecf4fee1" alt="image" /></p>

<p>무엇보다도 전자 회로 기판을 조립해서 만든 작은 컴퓨터는 나만의 작은 공간을 창조한다는 감동을 준달까. 기계와 로우레벨의 교감을 주고 받는 것이다…</p>

<h1 id="목표">목표</h1>

<p>홈서버를 구축하고 난 뒤에 구체적으로 어떤 것들을 해볼 수 있을지 목표를 정리해보았다. 목표는 제품의 스펙을 결정하는 기준이 될 것이다. (나는 보통 목표를 질문의 형식으로 작성하는데, 그 질문들에 답변할 수 있을 때 목표를 이루었다고 여기기 때문이다)</p>

<ul>
  <li>리눅스 운영체제는 어떻게 동작하는 것일까?</li>
  <li>파이썬과 운영체제는 어떻게 상호작용하는 것일까?</li>
  <li>데이터를 최대한 효율적으로 처리하는 방법은 무엇일까?</li>
  <li>머신러닝 모델을 경량화하는 방법은 무엇일까?</li>
  <li>머신러닝 모델의 추론과 운영을 어떻게 컨테이너화할까?</li>
  <li>왜 C/C++ 개발 역량을 지닌 머신러닝 엔지니어가 우대 받는 걸까?</li>
</ul>

<p><strong>로우레벨 환경에서 운영체제와 파이썬 언어의 동작을 이해하는 것</strong>과 <strong>매우 한정된 성능 안에서 데이터 처리를 최적화하는 것</strong>으로 요약할 수 있겠다.</p>

<h1 id="절대적-우선순위">절대적 우선순위</h1>

<p>제품 스펙을 살펴보기 앞서 현실적으로 고려해야 할 두 가지를 먼저 언급하려 한다. 바로 <strong>가격</strong>과 <strong>사이즈</strong>다.</p>

<p>실습, 장난감 용도이기 때문에 큰 돈을 들일 생각이 없다. 가성비 전략으로 간다. 중고 물품도 적극 고려할 예정.</p>

<p>또한 활동 공간이 3평 남짓한 자취방에서 감당할 수 있어야 하므로 사이즈는 최대한 미니미니하게 해야 한다.</p>

<h1 id="구성-요소">구성 요소</h1>

<p><img src="https://github.com/user-attachments/assets/c3f8de55-84c7-4df3-b279-d21a5168a186" alt="image" /></p>

<p>오늘날 컴퓨터는 폰 노이만 구조를 뼈대로 하여 확장된 형태이다. 이번 프로젝트에서 어떤 구성품을 마련할지 고민하면서 이 폰 노이만 컴퓨터를 참고할 수 있었다.</p>

<p>폰 노이만 구조의 구성 요소는 CPU, 메모리, 프로그램이다. 이때 프로그램은 메모리 안에 저장되고 실행되는 명령어의 집합이다.</p>

<p>그러니까 하드웨어 관점에서 필수 요소는 <strong>처리 장치(CPU)</strong>, <strong>기억 장치(메모리)</strong>, 그리고 이들을 운영하고 제어하기 위한 <strong>입출력 장치</strong>다.</p>

<h2 id="cpu-와-메모리">CPU 와 메모리</h2>

<p>싱글보드 컴퓨터는 메인보드(Motherboard)에 처리 장치인 CPU와 주기억 장치인 RAM이 탑재되어 있는 것을 말한다. 라즈베리 파이가 대표적인 싱글보드 컴퓨터 제품.</p>

<p>사실 엔비디아에도 싱글보드 컴퓨터 라인업이 있으며 GPU 활용이 필요하다면 이쪽이 더 나을 수도 있다.</p>

<p><img src="https://github.com/user-attachments/assets/f1ebca65-b9bc-4ab1-9fa4-a0a45240d6af" alt="image" /></p>

<p>야속하게도 불과 5일 전 엔비디아에서 AI용 싱글보드 컴퓨터 개발자 키트를 매우 합리적인 가격에 출시한다는 <a href="https://www.aitimes.com/news/articleView.html?idxno=166348">소식</a>을 내놨다. <code class="language-plaintext highlighter-rouge">젯슨 오린 나노(Jetson ORIN™ Nano)</code> 라는 제품이고 249달러(한화 약 36만원)다. LLM 등 딥러닝 모델 처리에 특화된 제품이라고 한다.</p>

<blockquote>
  <p>너무나도 갖고 싶다…</p>
</blockquote>

<p>하지만 나의 절대적인 기준은 가격이기 때문에 욕심을 내려놓으려 한다. 젯슨 시리즈는 나중에 더 큰 집으로 이사 가면 모셔보겠다 🥲</p>

<hr />

<p>라즈베리 파이도 여러 제품이 있다. 몇 세대를 살지, 램 사이즈는 어느 정도로 할지 결정해야 한다.</p>

<p><strong>몇 세대를 살 것인가?</strong> ➡️ 4 세대</p>

<p>주로 4세대와 5세대를 많이 비교하는 것 같다.</p>

<p>2019년 출시된 4세대는 성능과 가격 측면에서 경쟁력이 있어 독보적으로 인기 있는 제품이라고 한다. 5세대는 비교적 최근인 2023년에 출시되었는데, 이전 세대에 비해 가격도 오른 데다 발열이나 어댑터 등 이슈가 있어 차라리 미니 PC를 사는 편이 낫다고 보는 견해가 많다. 나도 5세대 제품 가격 보고 ‘그냥 젯슨을 살까 …‘라고 고민했는데, 그럴 바에 <u>4세대를 선택하겠다</u>고 판단했다.</p>

<p><strong>램 사이즈는?</strong> ➡️ 4GB</p>

<p>1, 2, 4, 8GB 옵션이 있다. 모델 올리는 것을 생각하면 4GB 이상은 되어야 할 텐데, 4GB는 7만원대이고 8GB는 11만원대로 가격 차이가 난다. 성능보다 가격이 중요한 상황이므로 전자로 결정했다.</p>

<h3 id="상세-스펙">상세 스펙</h3>

<p>구체적인 스펙은 아래와 같다. <a href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/specifications/">공식 사이트</a>를 참고했다.</p>

<p><img src="https://github.com/user-attachments/assets/15ba5b82-4c60-4571-b6b2-c3f3e19f6b91" alt="image" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>카테고리</strong></th>
      <th style="text-align: left"><strong>내용</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>프로세서</strong></td>
      <td style="text-align: left">Broadcom BCM2711, 쿼드코어 Cortex-A72 (ARM v8) 64-bit SoC @ 1.8GHz</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>메모리(RAM)</strong></td>
      <td style="text-align: left">8GB</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>무선 연결</strong></td>
      <td style="text-align: left">2.4 GHz/5.0GHz 와이파이, Bluetooth 5.0, BLE</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>유선 연결(이더넷)</strong></td>
      <td style="text-align: left">기가비트 이더넷</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>USB 포트</strong></td>
      <td style="text-align: left">USB 3.0 포트 2개, USB 2.0 포트 2개</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>GPIO</strong></td>
      <td style="text-align: left">라즈베리 파이 표준 40핀 GPIO 헤더</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>디스플레이 출력</strong></td>
      <td style="text-align: left">micro-HDMI 포트 2개 (최대 4k60 지원)</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>디스플레이 인터페이스</strong></td>
      <td style="text-align: left">2-레인 MIPI DSI 디스플레이 포트</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>그래픽</strong></td>
      <td style="text-align: left">OpenGL ES 3.1, Vulkan 1.0</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>저장 장치</strong></td>
      <td style="text-align: left">Micro SD 카드 슬롯</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>전원 공급</strong></td>
      <td style="text-align: left">USB-C 포트/GPIO 헤더를 통한 전원 공급, 5V DC, 최소 3A</td>
    </tr>
  </tbody>
</table>

<h2 id="보조-기억-장치">보조 기억 장치</h2>

<p>라즈베리 파이4는 SD카드를 지원한다. 운영체제 설치까지 고려해서 용량이 32GB 는 되어야 할 것 같다.</p>

<p>우선 가장 무난하게 Sandisk Ultra 32GB (6천원대) 사용할 예정이다. 호환 가능한 <a href="https://elinux.org/RPi_SD_cards#Working_.2F_Non-working_SD_cards">SD 카드 리스트</a>도 확인해보자.</p>

<p>라즈베리 파이 환경에서 SD카드 제품별로 성능을 비교한 훌륭한 <a href="https://makeutil.tistory.com/254">블로그글</a>이 있으니 참고하시라.</p>

<h2 id="입출력-장치">입출력 장치</h2>

<p><img src="https://github.com/user-attachments/assets/e593651c-7542-4f6b-8145-91655025b426" alt="Image" /></p>

<p>이번에 선물 받은 하기비스 미니 모니터를 연결할 예정이다. 다만 전원 등 호환이 될지 모르겠다. <a href="https://ko.aliexpress.com/item/1005006767426312.html?srcSns=sns_KakaoTalk&amp;spreadType=socialShare&amp;bizType=ProductDetail&amp;social_params=6000213862574&amp;aff_fcid=056f945532e144c7ae1b3bbe9066a2b7-1734873003608-04553-_op0QH0f&amp;tt=MG&amp;aff_fsk=_op0QH0f&amp;aff_platform=default&amp;sk=_op0QH0f&amp;aff_trace_key=056f945532e144c7ae1b3bbe9066a2b7-1734873003608-04553-_op0QH0f&amp;shareId=6000213862574&amp;businessType=ProductDetail&amp;platform=AE&amp;terminal_id=8902864ebb8a43d7ac279d621575f15c&amp;afSmartRedirect=y">알리</a>에서 5만원대에 구입했는데, 현재 7만원대로 올랐다.</p>

<p>하기비스 모니터 설명으로 미루어봐서 micro HDMI to USB-C 어댑터가 필요할 것으로 보인다.</p>
<blockquote>
  <p>One Cable Connection Mode: USB3.1 Gen2 cable connects HOST port and USB-C port of the laptop, allowing for simultaneous IPS mini screen display and interface expansion. *Note: The USB-C interface of the laptop must be Thunderbolt 3/4, USB4, or a USB-C interface that supports the DisplayPort (DP) protocol in order to use this mode</p>
</blockquote>

<p>키보드는 집에 있는 키크론 키보드를 활용할 것이다.</p>

<p>사실 입출력 장치는 큰 걱정이 없다. 어차피 맥북으로 SSH 원격 접속할 예정이기 때문이다.</p>

<h2 id="네트워크">네트워크</h2>

<p>자취방의 와이파이를 연결할 예정이다. 다만 자취방 와이파이가 <em>매우 불안정하여</em> 제멋대로 끊길 때가 많은데 - 체감상 4~5시간에 한 번(…) - 이게 얼마나 큰 문제로 작용할지는 … 일단 연결해봐야 알겠다.</p>

<h2 id="전원-공급-장치">전원 공급 장치</h2>

<p>라즈베리 파이4 부터는 전원을 USB-C 타입으로 공급 받는다. 모니터를 연결했을 때 전류가 얼마나 될지 모르겠지만, 가장 안전하게 라즈베리 파이4에 맞게 나온 5V 4A <a href="https://www.devicemart.co.kr/goods/view?no=12544959">전용 어댑터</a>면 좋을 것 같다. 가격은 7천원.</p>

<h2 id="기타-장비">기타 장비</h2>

<p>그 외 케이스, 방열판, 쿨러 등 보조 부품들이 있다. 이것은 필수 부품들을 갖추고 나서 하나씩 모을 생각이다. 이왕이면 이쁜 것들로 고심해서 고르고 싶기도 하고.</p>

<h3 id="결산">결산</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>필수 부품</strong></th>
      <th style="text-align: left"><strong>가격</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>라즈베리 파이</strong></td>
      <td style="text-align: left">78,000원 ~</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>SD 카드</strong></td>
      <td style="text-align: left">6,200원 ~</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>micro HDMI to USB-C 어댑터</strong></td>
      <td style="text-align: left">제품을 찾을 수 없음;;</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>전원 어댑터</strong></td>
      <td style="text-align: left">7,000원</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>보조 장비</strong></td>
      <td style="text-align: left">아직 모름</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>총합</strong></td>
      <td style="text-align: left">83,200원 이상</td>
    </tr>
  </tbody>
</table>

<p>대충 훑어봤지만 micro HDMI to USB-C 제품이 보이지 않는 게 약간 난감하다. micro HDMI 를 HDMI 로 변환한 후에 C타입으로 연결해야 할 것 같은 불길한 느낌. 그래도 필수 부품만 해서 10만원 이하로 맞출 수 있다면 충분히 만족스러울 것 같다.</p>

<h1 id="나가며">나가며</h1>

<p>오늘은 홈서버 프로젝트를 위해 목표와 장비의 스펙을 정리해보았다. 필수 부품을 하나씩 마련한 후에 운영체제 설치 등 세팅 과정을 블로그에 연재할 계획이다. 실습까지 갈 길이 멀지만 즐겁게, 꾸준히 해보자!</p>]]></content><author><name></name></author><category term="홈서버" /><summary type="html"><![CDATA[개요 라즈베리 파이(Raspberry Pi)를 활용한 홈서버 구축 프로젝트를 시작하려 한다. 이번 포스트에서는 프로젝트의 목적과 목표를 명확히 하고, 그에 맞춰 필요한 제품 스펙을 결정하는 과정을 기록한다. 계기 며칠 전, 회사 워크숍에서 버킷리스트를 작성하는 시간을 가졌다. 다들 세계여행이나 내 집 마련 같은 것을 적었는데, 나는 홈서버 구축하기를 쓰고 있었다. 그러고 보니 인생 버킷리스트까지도 아니고 그냥 당장 실행하면 되지 않을까? 라는 생각이 들었다. 작은 자취방에서 가지고 놀 수 있는 작은 컴퓨터를 갖고 싶다는 생각에서 시작했다. 운영체제는 리눅스로 해서 CLI 개발 환경의 고수가 되고 싶었다. VSCode 대신에 Vim 으로 코드를 작성하는 지독한 컨셉의 개발자가 되고 싶었다. (이건 농담이다) 지금까지 지나온 개발 환경을 순서대로 짚어보았다. 구글 코랩 : 밑바닥부터 시작하는 데 이만한 도구가 있을까. 버튼 클릭 하나로 구글 데이터센터의 고성능 GPU 를 사용할 수 있었다. 클라우드 서버 : 프로젝트가 본격화되면서 코랩의 사용량 제한이 걸림돌으로 작용했다. 이에 AWS EC2 스팟 인스턴스를 하나 구입해서 사용하기 시작했다. 온프레미스 서버 : 국가 사업에 선정되면서 그래픽 카드를 마련할 수 있게 되었다. 사무실 한 켠에서 열과 소음을 뿜어내던 그 녀석을 SSH 로 접근해서 마음대로 다뤄볼 수 있었다. (현재) 로컬 환경 : 이직하고 보니 컴퓨터마다 좋은 그래픽 카드가 하나씩 꽂혀 있었다. (스타트업에 있다 와서 그런지 충격적이었다) 물론 서버 인스턴스만큼은 넉넉하지 않지만, 적당한 크기의 모델 학습이나 추론은 로컬 환경에서도 거뜬했다. 특히 LLM 모델이 거대화되고 API 로 접근하는 방식이 널리 퍼지면서 오히려 로컬 환경에서 개발하기 편리해졌다고 느낀다. 그러나 반대 급부로 그만한 사이즈의 모델을 튜닝하거나 다루기 위해서는 서버 환경에서의 개발 역량 또한 놓칠 수 없다고 생각한다. 아쉽지만 현재 회사에서는 프로젝트 상 로컬 환경을 활용하는 것이 최선이므로, 개인적으로 홈서버를 구축하고 스스로 연습하려는 것이다. 먼 이야기지만 나중에 회사에서 서버 인스턴스를 할당 받았을 때 실수나 사고 없이 안정적으로 해내는 모습을 보여드리고 싶기도 하고. 무엇보다도 전자 회로 기판을 조립해서 만든 작은 컴퓨터는 나만의 작은 공간을 창조한다는 감동을 준달까. 기계와 로우레벨의 교감을 주고 받는 것이다… 목표 홈서버를 구축하고 난 뒤에 구체적으로 어떤 것들을 해볼 수 있을지 목표를 정리해보았다. 목표는 제품의 스펙을 결정하는 기준이 될 것이다. (나는 보통 목표를 질문의 형식으로 작성하는데, 그 질문들에 답변할 수 있을 때 목표를 이루었다고 여기기 때문이다) 리눅스 운영체제는 어떻게 동작하는 것일까? 파이썬과 운영체제는 어떻게 상호작용하는 것일까? 데이터를 최대한 효율적으로 처리하는 방법은 무엇일까? 머신러닝 모델을 경량화하는 방법은 무엇일까? 머신러닝 모델의 추론과 운영을 어떻게 컨테이너화할까? 왜 C/C++ 개발 역량을 지닌 머신러닝 엔지니어가 우대 받는 걸까? 로우레벨 환경에서 운영체제와 파이썬 언어의 동작을 이해하는 것과 매우 한정된 성능 안에서 데이터 처리를 최적화하는 것으로 요약할 수 있겠다. 절대적 우선순위 제품 스펙을 살펴보기 앞서 현실적으로 고려해야 할 두 가지를 먼저 언급하려 한다. 바로 가격과 사이즈다. 실습, 장난감 용도이기 때문에 큰 돈을 들일 생각이 없다. 가성비 전략으로 간다. 중고 물품도 적극 고려할 예정. 또한 활동 공간이 3평 남짓한 자취방에서 감당할 수 있어야 하므로 사이즈는 최대한 미니미니하게 해야 한다. 구성 요소 오늘날 컴퓨터는 폰 노이만 구조를 뼈대로 하여 확장된 형태이다. 이번 프로젝트에서 어떤 구성품을 마련할지 고민하면서 이 폰 노이만 컴퓨터를 참고할 수 있었다. 폰 노이만 구조의 구성 요소는 CPU, 메모리, 프로그램이다. 이때 프로그램은 메모리 안에 저장되고 실행되는 명령어의 집합이다. 그러니까 하드웨어 관점에서 필수 요소는 처리 장치(CPU), 기억 장치(메모리), 그리고 이들을 운영하고 제어하기 위한 입출력 장치다. CPU 와 메모리 싱글보드 컴퓨터는 메인보드(Motherboard)에 처리 장치인 CPU와 주기억 장치인 RAM이 탑재되어 있는 것을 말한다. 라즈베리 파이가 대표적인 싱글보드 컴퓨터 제품. 사실 엔비디아에도 싱글보드 컴퓨터 라인업이 있으며 GPU 활용이 필요하다면 이쪽이 더 나을 수도 있다. 야속하게도 불과 5일 전 엔비디아에서 AI용 싱글보드 컴퓨터 개발자 키트를 매우 합리적인 가격에 출시한다는 소식을 내놨다. 젯슨 오린 나노(Jetson ORIN™ Nano) 라는 제품이고 249달러(한화 약 36만원)다. LLM 등 딥러닝 모델 처리에 특화된 제품이라고 한다. 너무나도 갖고 싶다… 하지만 나의 절대적인 기준은 가격이기 때문에 욕심을 내려놓으려 한다. 젯슨 시리즈는 나중에 더 큰 집으로 이사 가면 모셔보겠다 🥲 라즈베리 파이도 여러 제품이 있다. 몇 세대를 살지, 램 사이즈는 어느 정도로 할지 결정해야 한다. 몇 세대를 살 것인가? ➡️ 4 세대 주로 4세대와 5세대를 많이 비교하는 것 같다. 2019년 출시된 4세대는 성능과 가격 측면에서 경쟁력이 있어 독보적으로 인기 있는 제품이라고 한다. 5세대는 비교적 최근인 2023년에 출시되었는데, 이전 세대에 비해 가격도 오른 데다 발열이나 어댑터 등 이슈가 있어 차라리 미니 PC를 사는 편이 낫다고 보는 견해가 많다. 나도 5세대 제품 가격 보고 ‘그냥 젯슨을 살까 …‘라고 고민했는데, 그럴 바에 4세대를 선택하겠다고 판단했다. 램 사이즈는? ➡️ 4GB 1, 2, 4, 8GB 옵션이 있다. 모델 올리는 것을 생각하면 4GB 이상은 되어야 할 텐데, 4GB는 7만원대이고 8GB는 11만원대로 가격 차이가 난다. 성능보다 가격이 중요한 상황이므로 전자로 결정했다. 상세 스펙 구체적인 스펙은 아래와 같다. 공식 사이트를 참고했다. 카테고리 내용 프로세서 Broadcom BCM2711, 쿼드코어 Cortex-A72 (ARM v8) 64-bit SoC @ 1.8GHz 메모리(RAM) 8GB 무선 연결 2.4 GHz/5.0GHz 와이파이, Bluetooth 5.0, BLE 유선 연결(이더넷) 기가비트 이더넷 USB 포트 USB 3.0 포트 2개, USB 2.0 포트 2개 GPIO 라즈베리 파이 표준 40핀 GPIO 헤더 디스플레이 출력 micro-HDMI 포트 2개 (최대 4k60 지원) 디스플레이 인터페이스 2-레인 MIPI DSI 디스플레이 포트 그래픽 OpenGL ES 3.1, Vulkan 1.0 저장 장치 Micro SD 카드 슬롯 전원 공급 USB-C 포트/GPIO 헤더를 통한 전원 공급, 5V DC, 최소 3A 보조 기억 장치 라즈베리 파이4는 SD카드를 지원한다. 운영체제 설치까지 고려해서 용량이 32GB 는 되어야 할 것 같다. 우선 가장 무난하게 Sandisk Ultra 32GB (6천원대) 사용할 예정이다. 호환 가능한 SD 카드 리스트도 확인해보자. 라즈베리 파이 환경에서 SD카드 제품별로 성능을 비교한 훌륭한 블로그글이 있으니 참고하시라. 입출력 장치 이번에 선물 받은 하기비스 미니 모니터를 연결할 예정이다. 다만 전원 등 호환이 될지 모르겠다. 알리에서 5만원대에 구입했는데, 현재 7만원대로 올랐다. 하기비스 모니터 설명으로 미루어봐서 micro HDMI to USB-C 어댑터가 필요할 것으로 보인다. One Cable Connection Mode: USB3.1 Gen2 cable connects HOST port and USB-C port of the laptop, allowing for simultaneous IPS mini screen display and interface expansion. *Note: The USB-C interface of the laptop must be Thunderbolt 3/4, USB4, or a USB-C interface that supports the DisplayPort (DP) protocol in order to use this mode 키보드는 집에 있는 키크론 키보드를 활용할 것이다. 사실 입출력 장치는 큰 걱정이 없다. 어차피 맥북으로 SSH 원격 접속할 예정이기 때문이다. 네트워크 자취방의 와이파이를 연결할 예정이다. 다만 자취방 와이파이가 매우 불안정하여 제멋대로 끊길 때가 많은데 - 체감상 4~5시간에 한 번(…) - 이게 얼마나 큰 문제로 작용할지는 … 일단 연결해봐야 알겠다. 전원 공급 장치 라즈베리 파이4 부터는 전원을 USB-C 타입으로 공급 받는다. 모니터를 연결했을 때 전류가 얼마나 될지 모르겠지만, 가장 안전하게 라즈베리 파이4에 맞게 나온 5V 4A 전용 어댑터면 좋을 것 같다. 가격은 7천원. 기타 장비 그 외 케이스, 방열판, 쿨러 등 보조 부품들이 있다. 이것은 필수 부품들을 갖추고 나서 하나씩 모을 생각이다. 이왕이면 이쁜 것들로 고심해서 고르고 싶기도 하고. 결산 필수 부품 가격 라즈베리 파이 78,000원 ~ SD 카드 6,200원 ~ micro HDMI to USB-C 어댑터 제품을 찾을 수 없음;; 전원 어댑터 7,000원 보조 장비 아직 모름 총합 83,200원 이상 대충 훑어봤지만 micro HDMI to USB-C 제품이 보이지 않는 게 약간 난감하다. micro HDMI 를 HDMI 로 변환한 후에 C타입으로 연결해야 할 것 같은 불길한 느낌. 그래도 필수 부품만 해서 10만원 이하로 맞출 수 있다면 충분히 만족스러울 것 같다. 나가며 오늘은 홈서버 프로젝트를 위해 목표와 장비의 스펙을 정리해보았다. 필수 부품을 하나씩 마련한 후에 운영체제 설치 등 세팅 과정을 블로그에 연재할 계획이다. 실습까지 갈 길이 멀지만 즐겁게, 꾸준히 해보자!]]></summary></entry><entry><title type="html">내가 무엇을, 왜 하고 있는지 인지하기 [수습기간 회고]</title><link href="https://woocosmos.github.io/probation/" rel="alternate" type="text/html" title="내가 무엇을, 왜 하고 있는지 인지하기 [수습기간 회고]" /><published>2024-11-21T00:00:00+09:00</published><updated>2024-11-21T00:00:00+09:00</updated><id>https://woocosmos.github.io/probation</id><content type="html" xml:base="https://woocosmos.github.io/probation/"><![CDATA[<h1 id="들어가며">들어가며</h1>

<p>2024년 9월 지금의 조직으로 이동하여 3개월의 수습 기간 종료를 앞두고 있다. 합류와 동시에 바로 현업에 투입되었기 때문에 what/why/how를 정리하지 못한 채 정신없이 시간을 보냈다. 이번 수습 회고에서는 지금까지 해온 구체적인 ACTION을 직무 관점에서 ‘무엇을 했는지’로 추상화하고, ‘왜 그렇게 했는지’ 의도를 부여하려 한다. 그리고 과정 중에서 어려움을 느꼈거나 개선의 여지가 있는 지점을 파악할 것이다.</p>

<p>물론 프로젝트의 내용은 밝히기 어려우니 기술 스택을 중점으로 다룰 예정이다. 일부 구체적인 사례가 필요한 경우에는 간단한 예시로 대체하겠다.</p>

<h1 id="직무에-대해서">직무에 대해서</h1>

<p>지금 회사에서 나의 직무는 분석가다. 여기서 분석가는 UX분석가, 데이터분석가, AI엔지니어 등을 포괄적으로 지칭하는 말이다. 그 중에서 나는 <strong>AI엔지니어</strong>라는 포지션로 입사했지만 대체로 데이터 과학자, 데이터 분석가, ML엔지니어를 오가는 다양한 업무를 접했다.</p>

<p>이전 회사에서는 하나의 프로젝트에 소속된 상태였다. 따라서 해당 서비스의 데이터 안에서 여러 방면으로 경험할 수 있었다. 당연하게도 모든 일의 목적은 근본적으로 ‘서비스를 성공시키는 것’이기 때문에 업무마다 문제와 목표가 달라지곤 했다. 간단하게는 지표의 현황을 파악하는 것, 위험을 최소화하기 위해 pain point를 탐색하는 것, 서비스의 피처가 의도대로 작동하는지 확인하는 것, ML 기반의 새로운 컨텐츠를 리서치하는 것, 내부 개발진을 대상으로 데이터 기반의 의사결정을 도모하는 것 등등.</p>

<p>이렇게 분석가로서 다양한 영역의 작업을 경험한다는 것은 뚜렷한 장단점을 지닌다.</p>

<ul>
  <li>장점
    <ul>
      <li>다양한 스킬셋을 확보할 수 있었다</li>
      <li>비즈니스와 기술적 액션의 연결고리를 이해하게 되었다</li>
      <li>협업과 커뮤니케이션 역량을 강화했다</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>나의 역할과 커리어의 방향성 불분명했다</li>
      <li>특정 영역의 전문성을 쌓기 어려웠다</li>
    </ul>
  </li>
</ul>

<p>특히 <strong>비즈니스와 기술적 액션을 연결 짓는 역량</strong>은 나에게 대단한 발전이었다. <em>어쨌든 회사는 돈을 벌어야 한다.</em> 기술적으로 깊이를 더하거나 새로운 기술을 도입, 고도화하더라도 그것이 비즈니스 임팩트를 창출하거나 의사결정에 실질적으로 기여하지 못한다면 “그래서 이걸 해서 뭐?” 라는 허무한 질문으로 끝나버릴 수 있는 것이다. 조직과 나의 성과로 연결되는 일을 해야 한다는 중요한 깨달음을 얻었다. (물론 리서치 중심의 조직이거나 학술적 목적이 주가 되는 곳이라면 상황이 다를 수 있다)</p>

<p>한편 <strong>커리어의 방향성이 불분명하다</strong>는 것은 여전히 고민 지점이다. 예를 들어 데이터 직군의 채용 공고를 아무거나 눌러 읽어본다. JD에 나열된 기술 역량을 살펴보면 <em>애매하다</em>. 채용공고만 봐도 나의 경험과 역량이 여러 포지션에 걸쳐져 있다는 것을 알 수 있다. 심지어는 특정 자격 요건에 해당 되더라도 “내가 이걸 해봤다고 말할 수 있나?” 라고 자문하게 된다. 해본 건 맞다. 그런데 그것을 전문적으로, 깊이 있게, 비즈니스 성과로 이어지도록 해냈는지는 확신을 갖기 어려운 것이다.</p>

<p>실제로 지난 면접에서 오간 대화를 통해 <strong>나의 전문성이 부족하다</strong>는 것을 깨달을 수 있었다. 최종적으로는 불합격한 포지션이었다.</p>

<dl>
  <dt>면접관</dt>
  <dd>A 모델의 학습 과정에 B 모델을 접목 시킨 이유가 무엇이었나요?</dd>
  <dt>나</dt>
  <dd>B 모델의 XX적 특성이 문제와 연결된다고 생각해서 적용했습니다.</dd>
  <dt>면접관</dt>
  <dd>실제로 그 접근 방식이 잘 워킹하는지 어떻게 검증하셨나요?</dd>
  <dt>나</dt>
  <dd>OOO 지표가 기존보다 빠르게 수렴하는 것을 확인할 수 있었습니다.</dd>
  <dt>면접관</dt>
  <dd>B 모델의 내부 요소가 A 모델에 어떤 영향을 미쳐서 성능이 향상되는지 <strong>검증</strong>해본 적 있나요?</dd>
  <dt>나</dt>
  <dd>(일단 적용하는 데만 공수를 겁나 들였고 전반적인 성능만 확인해서 할 말이 없음)</dd>
  <dt>면접관</dt>
  <dd>B 모델의 +++ 를 추출해서 시각화하는 방식은 생각해보셨나요?</dd>
  <dt>나</dt>
  <dd>그런 검증 방식은 떠올리지 못했습니다.</dd>
</dl>

<p class="center"><img src="https://github.com/user-attachments/assets/b1c0aff0-1bba-43a6-9ded-799580fe7559" alt="image" class="center-image" />
<em>창피하다…</em></p>

<p>그렇다. 나는 ‘일단 해본다’에서 그쳐온 것이다. 아니, 사실은 내가 정확히 <strong>무엇을, 어떻게, 왜</strong> 했는지조차 설명할 수준이 안 되었던 것이다. 일련의 깨달음을 끝으로 나는 <u>기본기와 전문성을 갖추는 것</u> 그리고 <u>내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것</u>에 집중하기로 결심한다.</p>

<h1 id="작업-정리">작업 정리</h1>

<p>정리한 방식은 이렇다.</p>
<ul>
  <li>업무 일지를 기반으로 구체적인 작업을 리스트로 나열한다</li>
  <li>각 항목을 추상적인 표현으로 바꾸고 큼직한 <u>키워드</u>로 분류한다</li>
  <li>각 항목의 의도를 설명한다</li>
  <li>어려웠거나 개선의 여지가 있는 지점을 짚는다</li>
</ul>

<p>예를 들어,</p>

<ul>
  <li><strong>ACTION</strong>
    <ul>
      <li>Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다</li>
    </ul>
  </li>
  <li><strong>WHAT</strong>
    <ul>
      <li>클라우드 기반의 데이터 웨어하우스의 구조를 이해하고 여러 소스로부터 데이터를 통합하는 SQL 쿼리를 작성했다 =&gt; <mark>Data Engineering</mark></li>
    </ul>
  </li>
  <li><strong>WHY</strong>
    <ul>
      <li>최신 데이터를 정확하고 효율적으로 통합함으로써 데이터 분석과 시각화의 기반을 마련하고자 했다</li>
    </ul>
  </li>
  <li><strong>HOW</strong>
    <ul>
      <li><strong>복잡한 SQL 쿼리</strong> : API로 fetch 한 JSON 배치가 통째로 한 셀에 들어가 매우 nested된 형식이었다. 더 효율적인 데이터 추출을 위해 최적화할 필요가 있다.</li>
      <li><strong>낯선 데이터베이스의 구조 파악</strong> : 구조화된 문서로 세부 사항을 기록하고, 필요한 경우 자체 데이터 사전(Data Dictionary)을 구축할 수 있다</li>
    </ul>
  </li>
</ul>

<p>실제로 수행한 업무는 <code class="language-plaintext highlighter-rouge">Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다</code> 이지만, 데이터 직무의 관점에서 무슨 일을 한 건지 객관화, 추상화할 수 있게 된다.</p>

<hr />

<p>정리 결과, 키워드는 크게 네 가지로 나눌 수 있었다. 각 키워드에 해당하는 WHAT 들을 아래 나열해본다.</p>

<style>
table {
  width: 100%;
  border-collapse: collapse;
}
th, td:first-child {
  background-color: transparent; /* Remove background for this row */
}
thead tr:first-child {
  background-color: #f2f2f2; /* Green color for header row */
}
tr:nth-child(2) {
  text-align: center;
  background-color: #f2f2f2; /* Remove background for the second row */
}
</style>

<table>
  <thead>
    <tr>
      <th><strong>협업 및 운영</strong></th>
      <th><strong>데이터 분석</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>- 데이터 분석을 위한 Ubuntu 개발 환경 구축 <br /> - CI/CD 도구와 협업 도구 통합 설정 <br /> - 데이터플랫폼 계정 및 라이센스 할당, 스펙 설정 <br /> - API 및 데이터 웨어하우스 활용 가이드 제공 <br /> - 외부 리소스 활용한 아이디어, 방향성 제시</td>
      <td>- NLP 모델 활용한 다국어 데이터 처리 리서치 <br /> - LLM 프롬프트와 호출 비용 분석 <br />- 통계 기반 가설 검증과 인사이트 도출 <br />- 비즈니스 목적에 맞춘 모델 평가 지표 설계</td>
    </tr>
    <tr>
      <td><strong>데이터 엔지니어링</strong></td>
      <td><strong>데이터 시각화</strong></td>
    </tr>
    <tr>
      <td>- 데이터 그레인 정의, API 활용 가능성 리서치 <br /> - 외부 API 기반의 데이터 수집 <br /> - 클라우드 기반 데이터 웨어하우스 연동 최적화 <br /> - 데이터베이스 메타 분석과 문서화 <br /> - SQL 쿼리 최적화 및 성능 모니터링, 검증 <br />- 데이터 정합성 문제 해결 및 관계 테이블 설계 <br /> - 대시보드용 요약 테이블 운영 <br />- 데이터 통합 플랫폼 활용한 파이프라인 구축</td>
      <td>- 데이터 기반 대시보드 설계 및 구현 <br /> - 대시보드 설계 단계의 시뮬레이션 및 피드백 수집 <br /> - BI 도구와 클라우드/정적 데이터 연동 <br /> - 인포그래픽 및 웹앱 설계, 제작</td>
    </tr>
  </tbody>
</table>

<p>지난 3개월 동안 진행한 내용 중 제일 비중이 컸던 키워드는 <strong>데이터 엔지니어링</strong>이었다. 글 서두에 합류 직후 현업에 바로 투입되었다고 언급했는데, 데이터 인프라를 셋업하기 위한 업무를 주로 진행했기 때문이다.</p>

<p>“당장 필요하니까 해본다”의 방식으로 일을 진행해왔는데, 이렇게 정리함으로써 내가 무엇을 하고 있는지 보다 명확하게 파악할 수 있었다. 특히 구체적인 업무 내용을 데이터 분야의 용어로 추상화할 수 있다는 점이 만족스럽다. 머릿속에서 명쾌하게 설명할 수 있게 되었다고 느낀 요소들을 몇 가지 나열해보면 이렇다.</p>

<p><strong>데이터(통합)플랫폼</strong><br />
데이터를 통합, 활용하기 위한 각종 시스템을 ‘데이터 통합 플랫폼’이라는 용어로 표현할 수 있었다. Snowflake, Tableau 등이 여기에 해당된다.</p>

<p><strong>데이터웨어하우스(DHW)</strong><br />
데이터베이스 이론에서 항상 보던 이 용어가 바로 여기에 쓰인다는 것을 알았다. ‘대용량 데이터를 중앙 집중식으로 관리하는 저장소’ 라는 정의로는 크게 와닿지 않았는데, 실제 업무를 해온 환경을 돌아보면 데이터 레이크, 웨어하우스, 데이터 마트 등으로 모두 설명할 수 있었다.</p>

<p><strong>데이터 그레인 (Granularity)</strong><br />
데이터를 적재, 분석하는 세부 수준을 일컫는 말이다. ‘데이터를 어떤 기준과 단위로 다뤄야 하지?’ 라는 고민이 곧 데이터 그레인에 대한 정의였음을 알았다.</p>

<p><strong>데이터베이스 메타 분석</strong><br />
쿼리를 작성하기 위해서는 데이터베이스의 구조부터 전반적으로 파악해야 했다. 이러한 일련의 작업은 메타 분석이라는 이름으로 정리할  수 있었다.</p>

<p><strong>데이터 정합성</strong><br />
샘플이 중복되거나, 일관되지 않거나, 누락되기도 했다. 또 맵핑하는 key에 따라 결과가 부정확하기도 했다. 데이터를 정확하게 추출한다는 것은 데이터의 정합성을 체크했음을 전제로 한다.</p>

<p><strong>요약 테이블</strong><br />
여러 소스로부터 데이터를 수집하고 가공, 집계한 결과를 하나의 테이블에 밀어 넣었다. 단순하게 ‘대시보드용 테이블’이라고 부르던 것을 요약 테이블이라는 말로 설명할 수 있게 되었다.</p>

<p>그 외에도 API가 무엇인지 실질적으로 이해했고, 데이터베이스의 기본 요소나 성능 최적화에 대해서도 고려할 수 있게 되었다. 면접에서 “API 가 무엇인가요?” 라고 물어보았을 때,  “Application Programming Interface의 줄임말입니다” 라고 외운 대로 읊는 수준에서 한 걸음 더 발전한 느낌이랄까.</p>

<h1 id="나가며">나가며</h1>

<p>마지막으로 나의 결심을 다시 한번 상기해보겠다.</p>

<ol>
  <li>기본기와 전문성을 갖추는 것</li>
  <li>내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것</li>
</ol>

<p>사실 1번과 2번은 아주 밀접하게 연결되어 있었다. 기본적인 지식이 있어야 내가 무슨 일을 하는지 이해할 수 있다.</p>

<p>지난 3개월은 각종 불안과 불확신으로 가득했다. 특히 실력을 키워야 한다는 강박관념이 제일 컸다. 때로는 퇴근하면서 “오늘 엄청나게 바빴지만, 실제적으로 한 일은 없는 것 같다” 라는 불안감에 떨기도 했다. 하지만 이번 회고를 통해 <strong>내가 해본 적 없는 영역의 기본기를 쌓는 과정</strong>이었음을 배웠다. 어떻게 보면 퍼즐이 맞춰지는 과정과도 같았다. ‘그래서 팀원이 그때 그렇게 했구나’ 혹은 ‘그래서 SQLD 시험에 그런 내용이 포함되어 있었구나’ 라고 깨달은 것이다.</p>

<p>어쩌면 이것은 비전공자의 숙명일지도 모른다. <em>이 모든 걸 전공 수업에서 진작에 배웠다면 좀 달랐을까?</em> 하는 상상이 스쳐 지나갔지만, 이제 그런 걱정은 소용이 없다. 앞으로 무엇을 할지가 더 중요하니까. ML엔지니어답게 베이즈 업데이트해갈 뿐이다.</p>

<p>(난데없지만 나의 성장 과정이 베이즈 확률 모델처럼 작동한다고 느껴졌다. 초보적인 이해라는 사전 확률에서 시작하여 다양한 경험과 시행착오를 통해 데이터를 쌓고 사후 확률로서 업데이트된 실력으로 나아가는 것이다 … 이런 비유가 자꾸 떠오르는 것은 인문학도의 숙명이라고 하자.)</p>

<p>여전히 내가 무엇을 하고 싶은지 딱 잘라 말하기 어렵고 나의 직무에 대해서 자신 있게 설명하지 못한다. 그럼에도 불구하고 다행인 것은 <strong>아직도 하고 싶은 게 너무나도 많다</strong>는 것이다! ML엔지니어가 아니면 안 된다는 고집과 스페셜리스트가 되는 것에 대한 로망은 잠시 내려놓고, 초심으로 돌아가려 한다. “앞으로 무엇이 되어야 한다” 라는 강박에서 벗어나기 위함이다. “지금 당장 할 수 있는 것”을 수행하고 그 경험을 잘 정리하는 것이 어제의 나보다 나아지는 길일 테다.</p>

<p>그럼, 내일도 힘 내보자.</p>]]></content><author><name></name></author><category term="회고" /><summary type="html"><![CDATA[들어가며 2024년 9월 지금의 조직으로 이동하여 3개월의 수습 기간 종료를 앞두고 있다. 합류와 동시에 바로 현업에 투입되었기 때문에 what/why/how를 정리하지 못한 채 정신없이 시간을 보냈다. 이번 수습 회고에서는 지금까지 해온 구체적인 ACTION을 직무 관점에서 ‘무엇을 했는지’로 추상화하고, ‘왜 그렇게 했는지’ 의도를 부여하려 한다. 그리고 과정 중에서 어려움을 느꼈거나 개선의 여지가 있는 지점을 파악할 것이다. 물론 프로젝트의 내용은 밝히기 어려우니 기술 스택을 중점으로 다룰 예정이다. 일부 구체적인 사례가 필요한 경우에는 간단한 예시로 대체하겠다. 직무에 대해서 지금 회사에서 나의 직무는 분석가다. 여기서 분석가는 UX분석가, 데이터분석가, AI엔지니어 등을 포괄적으로 지칭하는 말이다. 그 중에서 나는 AI엔지니어라는 포지션로 입사했지만 대체로 데이터 과학자, 데이터 분석가, ML엔지니어를 오가는 다양한 업무를 접했다. 이전 회사에서는 하나의 프로젝트에 소속된 상태였다. 따라서 해당 서비스의 데이터 안에서 여러 방면으로 경험할 수 있었다. 당연하게도 모든 일의 목적은 근본적으로 ‘서비스를 성공시키는 것’이기 때문에 업무마다 문제와 목표가 달라지곤 했다. 간단하게는 지표의 현황을 파악하는 것, 위험을 최소화하기 위해 pain point를 탐색하는 것, 서비스의 피처가 의도대로 작동하는지 확인하는 것, ML 기반의 새로운 컨텐츠를 리서치하는 것, 내부 개발진을 대상으로 데이터 기반의 의사결정을 도모하는 것 등등. 이렇게 분석가로서 다양한 영역의 작업을 경험한다는 것은 뚜렷한 장단점을 지닌다. 장점 다양한 스킬셋을 확보할 수 있었다 비즈니스와 기술적 액션의 연결고리를 이해하게 되었다 협업과 커뮤니케이션 역량을 강화했다 단점 나의 역할과 커리어의 방향성 불분명했다 특정 영역의 전문성을 쌓기 어려웠다 특히 비즈니스와 기술적 액션을 연결 짓는 역량은 나에게 대단한 발전이었다. 어쨌든 회사는 돈을 벌어야 한다. 기술적으로 깊이를 더하거나 새로운 기술을 도입, 고도화하더라도 그것이 비즈니스 임팩트를 창출하거나 의사결정에 실질적으로 기여하지 못한다면 “그래서 이걸 해서 뭐?” 라는 허무한 질문으로 끝나버릴 수 있는 것이다. 조직과 나의 성과로 연결되는 일을 해야 한다는 중요한 깨달음을 얻었다. (물론 리서치 중심의 조직이거나 학술적 목적이 주가 되는 곳이라면 상황이 다를 수 있다) 한편 커리어의 방향성이 불분명하다는 것은 여전히 고민 지점이다. 예를 들어 데이터 직군의 채용 공고를 아무거나 눌러 읽어본다. JD에 나열된 기술 역량을 살펴보면 애매하다. 채용공고만 봐도 나의 경험과 역량이 여러 포지션에 걸쳐져 있다는 것을 알 수 있다. 심지어는 특정 자격 요건에 해당 되더라도 “내가 이걸 해봤다고 말할 수 있나?” 라고 자문하게 된다. 해본 건 맞다. 그런데 그것을 전문적으로, 깊이 있게, 비즈니스 성과로 이어지도록 해냈는지는 확신을 갖기 어려운 것이다. 실제로 지난 면접에서 오간 대화를 통해 나의 전문성이 부족하다는 것을 깨달을 수 있었다. 최종적으로는 불합격한 포지션이었다. 면접관 A 모델의 학습 과정에 B 모델을 접목 시킨 이유가 무엇이었나요? 나 B 모델의 XX적 특성이 문제와 연결된다고 생각해서 적용했습니다. 면접관 실제로 그 접근 방식이 잘 워킹하는지 어떻게 검증하셨나요? 나 OOO 지표가 기존보다 빠르게 수렴하는 것을 확인할 수 있었습니다. 면접관 B 모델의 내부 요소가 A 모델에 어떤 영향을 미쳐서 성능이 향상되는지 검증해본 적 있나요? 나 (일단 적용하는 데만 공수를 겁나 들였고 전반적인 성능만 확인해서 할 말이 없음) 면접관 B 모델의 +++ 를 추출해서 시각화하는 방식은 생각해보셨나요? 나 그런 검증 방식은 떠올리지 못했습니다. 창피하다… 그렇다. 나는 ‘일단 해본다’에서 그쳐온 것이다. 아니, 사실은 내가 정확히 무엇을, 어떻게, 왜 했는지조차 설명할 수준이 안 되었던 것이다. 일련의 깨달음을 끝으로 나는 기본기와 전문성을 갖추는 것 그리고 내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것에 집중하기로 결심한다. 작업 정리 정리한 방식은 이렇다. 업무 일지를 기반으로 구체적인 작업을 리스트로 나열한다 각 항목을 추상적인 표현으로 바꾸고 큼직한 키워드로 분류한다 각 항목의 의도를 설명한다 어려웠거나 개선의 여지가 있는 지점을 짚는다 예를 들어, ACTION Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다 WHAT 클라우드 기반의 데이터 웨어하우스의 구조를 이해하고 여러 소스로부터 데이터를 통합하는 SQL 쿼리를 작성했다 =&gt; Data Engineering WHY 최신 데이터를 정확하고 효율적으로 통합함으로써 데이터 분석과 시각화의 기반을 마련하고자 했다 HOW 복잡한 SQL 쿼리 : API로 fetch 한 JSON 배치가 통째로 한 셀에 들어가 매우 nested된 형식이었다. 더 효율적인 데이터 추출을 위해 최적화할 필요가 있다. 낯선 데이터베이스의 구조 파악 : 구조화된 문서로 세부 사항을 기록하고, 필요한 경우 자체 데이터 사전(Data Dictionary)을 구축할 수 있다 실제로 수행한 업무는 Snowflake 에서 AAA 라는 스키마 아래에 있는 TABLE0, TABLE1, TABLE2를 참조하는 SQL 문을 작성했다 이지만, 데이터 직무의 관점에서 무슨 일을 한 건지 객관화, 추상화할 수 있게 된다. 정리 결과, 키워드는 크게 네 가지로 나눌 수 있었다. 각 키워드에 해당하는 WHAT 들을 아래 나열해본다. 협업 및 운영 데이터 분석 - 데이터 분석을 위한 Ubuntu 개발 환경 구축 - CI/CD 도구와 협업 도구 통합 설정 - 데이터플랫폼 계정 및 라이센스 할당, 스펙 설정 - API 및 데이터 웨어하우스 활용 가이드 제공 - 외부 리소스 활용한 아이디어, 방향성 제시 - NLP 모델 활용한 다국어 데이터 처리 리서치 - LLM 프롬프트와 호출 비용 분석 - 통계 기반 가설 검증과 인사이트 도출 - 비즈니스 목적에 맞춘 모델 평가 지표 설계 데이터 엔지니어링 데이터 시각화 - 데이터 그레인 정의, API 활용 가능성 리서치 - 외부 API 기반의 데이터 수집 - 클라우드 기반 데이터 웨어하우스 연동 최적화 - 데이터베이스 메타 분석과 문서화 - SQL 쿼리 최적화 및 성능 모니터링, 검증 - 데이터 정합성 문제 해결 및 관계 테이블 설계 - 대시보드용 요약 테이블 운영 - 데이터 통합 플랫폼 활용한 파이프라인 구축 - 데이터 기반 대시보드 설계 및 구현 - 대시보드 설계 단계의 시뮬레이션 및 피드백 수집 - BI 도구와 클라우드/정적 데이터 연동 - 인포그래픽 및 웹앱 설계, 제작 지난 3개월 동안 진행한 내용 중 제일 비중이 컸던 키워드는 데이터 엔지니어링이었다. 글 서두에 합류 직후 현업에 바로 투입되었다고 언급했는데, 데이터 인프라를 셋업하기 위한 업무를 주로 진행했기 때문이다. “당장 필요하니까 해본다”의 방식으로 일을 진행해왔는데, 이렇게 정리함으로써 내가 무엇을 하고 있는지 보다 명확하게 파악할 수 있었다. 특히 구체적인 업무 내용을 데이터 분야의 용어로 추상화할 수 있다는 점이 만족스럽다. 머릿속에서 명쾌하게 설명할 수 있게 되었다고 느낀 요소들을 몇 가지 나열해보면 이렇다. 데이터(통합)플랫폼 데이터를 통합, 활용하기 위한 각종 시스템을 ‘데이터 통합 플랫폼’이라는 용어로 표현할 수 있었다. Snowflake, Tableau 등이 여기에 해당된다. 데이터웨어하우스(DHW) 데이터베이스 이론에서 항상 보던 이 용어가 바로 여기에 쓰인다는 것을 알았다. ‘대용량 데이터를 중앙 집중식으로 관리하는 저장소’ 라는 정의로는 크게 와닿지 않았는데, 실제 업무를 해온 환경을 돌아보면 데이터 레이크, 웨어하우스, 데이터 마트 등으로 모두 설명할 수 있었다. 데이터 그레인 (Granularity) 데이터를 적재, 분석하는 세부 수준을 일컫는 말이다. ‘데이터를 어떤 기준과 단위로 다뤄야 하지?’ 라는 고민이 곧 데이터 그레인에 대한 정의였음을 알았다. 데이터베이스 메타 분석 쿼리를 작성하기 위해서는 데이터베이스의 구조부터 전반적으로 파악해야 했다. 이러한 일련의 작업은 메타 분석이라는 이름으로 정리할 수 있었다. 데이터 정합성 샘플이 중복되거나, 일관되지 않거나, 누락되기도 했다. 또 맵핑하는 key에 따라 결과가 부정확하기도 했다. 데이터를 정확하게 추출한다는 것은 데이터의 정합성을 체크했음을 전제로 한다. 요약 테이블 여러 소스로부터 데이터를 수집하고 가공, 집계한 결과를 하나의 테이블에 밀어 넣었다. 단순하게 ‘대시보드용 테이블’이라고 부르던 것을 요약 테이블이라는 말로 설명할 수 있게 되었다. 그 외에도 API가 무엇인지 실질적으로 이해했고, 데이터베이스의 기본 요소나 성능 최적화에 대해서도 고려할 수 있게 되었다. 면접에서 “API 가 무엇인가요?” 라고 물어보았을 때, “Application Programming Interface의 줄임말입니다” 라고 외운 대로 읊는 수준에서 한 걸음 더 발전한 느낌이랄까. 나가며 마지막으로 나의 결심을 다시 한번 상기해보겠다. 기본기와 전문성을 갖추는 것 내가 무슨 일을 하는지 명확하게 정리하고 인지하는 것 사실 1번과 2번은 아주 밀접하게 연결되어 있었다. 기본적인 지식이 있어야 내가 무슨 일을 하는지 이해할 수 있다. 지난 3개월은 각종 불안과 불확신으로 가득했다. 특히 실력을 키워야 한다는 강박관념이 제일 컸다. 때로는 퇴근하면서 “오늘 엄청나게 바빴지만, 실제적으로 한 일은 없는 것 같다” 라는 불안감에 떨기도 했다. 하지만 이번 회고를 통해 내가 해본 적 없는 영역의 기본기를 쌓는 과정이었음을 배웠다. 어떻게 보면 퍼즐이 맞춰지는 과정과도 같았다. ‘그래서 팀원이 그때 그렇게 했구나’ 혹은 ‘그래서 SQLD 시험에 그런 내용이 포함되어 있었구나’ 라고 깨달은 것이다. 어쩌면 이것은 비전공자의 숙명일지도 모른다. 이 모든 걸 전공 수업에서 진작에 배웠다면 좀 달랐을까? 하는 상상이 스쳐 지나갔지만, 이제 그런 걱정은 소용이 없다. 앞으로 무엇을 할지가 더 중요하니까. ML엔지니어답게 베이즈 업데이트해갈 뿐이다. (난데없지만 나의 성장 과정이 베이즈 확률 모델처럼 작동한다고 느껴졌다. 초보적인 이해라는 사전 확률에서 시작하여 다양한 경험과 시행착오를 통해 데이터를 쌓고 사후 확률로서 업데이트된 실력으로 나아가는 것이다 … 이런 비유가 자꾸 떠오르는 것은 인문학도의 숙명이라고 하자.) 여전히 내가 무엇을 하고 싶은지 딱 잘라 말하기 어렵고 나의 직무에 대해서 자신 있게 설명하지 못한다. 그럼에도 불구하고 다행인 것은 아직도 하고 싶은 게 너무나도 많다는 것이다! ML엔지니어가 아니면 안 된다는 고집과 스페셜리스트가 되는 것에 대한 로망은 잠시 내려놓고, 초심으로 돌아가려 한다. “앞으로 무엇이 되어야 한다” 라는 강박에서 벗어나기 위함이다. “지금 당장 할 수 있는 것”을 수행하고 그 경험을 잘 정리하는 것이 어제의 나보다 나아지는 길일 테다. 그럼, 내일도 힘 내보자.]]></summary></entry><entry><title type="html">결정트리 모델(Decision Tree)이 나의 문제를 해결해줄 수 있을까?</title><link href="https://woocosmos.github.io/decision-tree/" rel="alternate" type="text/html" title="결정트리 모델(Decision Tree)이 나의 문제를 해결해줄 수 있을까?" /><published>2024-10-23T00:00:00+09:00</published><updated>2024-10-23T00:00:00+09:00</updated><id>https://woocosmos.github.io/decision-tree</id><content type="html" xml:base="https://woocosmos.github.io/decision-tree/"><![CDATA[<h1 id="들어가며">들어가며</h1>

<p>아래와 같은 설문조사가 있다. 응답자들은 0 ~ 10점 선지 중 하나를 선택한다.</p>

<p><img src="https://github.com/user-attachments/assets/c7d0a9d9-b6cb-4888-93ec-d53b07c7a496" alt="image" /></p>

<p><br />
이러한 응답 데이터를 활용해서 특정 값을 예측하려 한다. 어떤 모델을 쓰면 좋을까? 이 문제 상황에서 가장 먼저 떠올린 것은 <strong>결정트리 모델</strong>이었다. 최소 0부터 최대 10으로 스케일이 한정된 정수 데이터가 주어졌으며, 결정트리 모델은 조건 (예를 들면, $x &gt; 4$ ?)에 따라 샘플을 나누며 가지를 뻗어나가기 때문이다. 문제를 해결하는 데 결정트리가 적절한 모델이라는 <em>직관적인</em> 느낌을 받았다.</p>

<p>그러나 내가 설명할 수 있는 최선은 여기까지였다. “내가 모델의 개념과 원리를 근본적으로 이해하고 있나?” 반성하게 되었고, 이 글을 쓰게 된 계기가 되었다.</p>

<blockquote>
  <p>제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가?</p>
</blockquote>

<p>즉, 이 질문에 답변하기 위해 해당 모델을 공부한 글이다.</p>

<h1 id="개념">개념</h1>

<p><strong>결정트리 Decision Tree</strong>, 의사결정 나무라고도 부른다.</p>

<p>데이터를 기준에 따라 반복 분할함으로써 계층적인 구조로 하위 집합을 형성하는 방법론</p>

<h2 id="역사로-이해하기">역사로 이해하기</h2>

<p>결정트리 모델의 시초는 1960년대 사회과학에서 찾아볼 수 있다. 이후 1980년대 데이터 과학 분야의 발전과 함께 결정트리 방법론이 소개되고 다양한 모델이 개발, 활용되기 시작했다.</p>

<p>우선 1963년에 발간된 사회과학서 <a href="https://www.jstor.org/stable/2283276">Problems in the Analysis of Survey Data, and a Proposal</a>에 초기 개념이 소개되었다. 고차원의 다중공선성을 띠는 설문조사 데이터를 다루기 위한 방법론으로, 오차제곱합(SSE)를 최소화하도록 하위 그룹으로 분할한다.</p>

<p>사회과학 분야에서 다룰 법한 간단한 예제를 상상해봤다. 응답자의 나이, 성별, 연봉 수준을 수집했으며 이에 따른 직업 만족도를 비교하려 한다. 그런데 나이가 많을수록 연봉 수준이 높아지기도 하고, 분포 상 응답자가 여자일수록 나이대가 낮아진다. 이러한 변수 간 상호작용을 고려하면서 종속변수(직업 만족도)의 차이를 설명하기 위해 응답자를 <mark>그룹</mark>으로 나눠볼 수 있다. 30대 미만/이상으로 나눠도 좋고, 성별에 따라 나눠도 좋다. 중요한 건 나눠진 <strong>그룹끼리 직업 만족도를 비교했을 때 차이가 커지도록</strong> 하는 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/ae6dc78a-b9d4-488a-9045-762f49075f6d" alt="image" />
그룹끼리 차이가 커지도록 그룹을 나누는 이유는, 그룹 안의 <strong>동질성이 높다</strong>는 것과 같은 의미이기 때문이다. 한 그룹의 평균을 예측값으로 삼는다고 치자. 그룹의 동질성이 높을수록 그룹 내 샘플들은 평균에 가까이 몰려 있을 테니 <u>실제값과 예측값 간의 오차</u>가 전반적으로 줄어든다.</p>

<p>이렇듯 직업 만족도가 가장 크게 차이나는 두 그룹으로 나눠 <em>첫번째</em> 분할을 마쳤다. 그 다음에 오차가 더 큰 그룹을 선택한 다음 그 안에서 또 분할한다. 마찬가지로 그룹 간 차이가 크게 발생하는, 다시 말해 오차를 최소화하는 분할 기준을 결정한다. 분할을 반복한다.</p>

<p><img src="https://github.com/user-attachments/assets/8f40122d-dd94-4ca5-b1ce-b09108ae2e31" alt="image" />
<em>Problems in the Analysis of Survey Data, and a Proposal(1963), 17페이지. 오늘날 결정트리 모델을 시각화한 모습과 같다.</em></p>

<p>사회과학 분야에서 분할의 결과는 이렇게 활용할 수 있다. ‘30세 미만 남성 노동직 그룹과 여성 고졸 그룹의 직업 만족도가 75점 수준으로 비슷하다’ - 한편 머신러닝 분야라면? 입력 데이터에 대해 예측값을 출력하는 모델을 생성하는 데 활용할 수 있겠다! 30세 미만 남성 노동직이 입력으로 들어오면 75점 가량으로 예측하는 것이다.</p>

<p>이어 1984년 <a href="https://books.google.co.kr/books/about/Classification_and_Regression_Trees.html?id=JwQx-WOmSyQC&amp;redir_esc=y">Classification and Regression Trees</a>에서 결정트리 방법론을 기반으로 한 알고리즘 CART가 발표됐다. Classification And Regression Tree의 줄임말이다. 이어 CART의 업그레이드 버전인 ID3(Iterative Dichotomiser 3), C4.5, C5.0 등이 발표되면서 결정트리 모델이 더욱 발전해나갔다. 오늘날 많이 사용하는 Random Forest, XGBoost도 결정트리 방법론을 기반으로 개발된 알고리즘들이다.</p>

<h1 id="분할의-기준">분할의 기준</h1>

<p>CART, ID3, C4.5, C5.0 알고리즘은 모두 결정트리 방법론을 기반으로 한다. 하지만 분할 기준을 무엇으로 설정하는지에 따라 다른 알고리즘으로 발전한 결과다. 앞서 언급한 예제에서는 간단하게 그룹별 직업 만족도의 평균값 차이를 기준으로 분할했지만, 실제 알고리즘에서는 더 효율적이거나 정교한 지표를 분할의 기준으로 삼는다.</p>

<p>분할 기준의 본질은 <strong>불순도(impurity)</strong>를 낮추는 것이다. 앞서 그룹 내 동질성을 높이는 것이 중요하다고 언급했다. 이는 <strong>불순도를 낮춘다</strong>는 말과 의미가 동일하다.</p>

<p><img src="https://github.com/user-attachments/assets/fbdefbc1-ead0-43b6-9e94-5c5de12ab235" alt="image" /></p>

<p><em>다른 데이터가 많이 섞여 있을수록 동질성이 떨어지며 이는 곧 불순도가 높은 상태다</em></p>

<p>분할의 결과로 얼마나 동질성이 높아지거나 낮아졌는지, 불순도를 수치화하는 방식은 크게 두 가지. 지니 계수와 엔트로피(정보 이득)다.
소개한 알고리즘 중 CART는 지니 계수를 사용하며, ID3, C4.5, C5.0은 엔트로피 및 정보 이득을 사용한다.</p>

<h2 id="지니-계수gini-coefficient">지니 계수(Gini coefficient)</h2>

<p>지니 계수가 높을수록 불순도가 높다고 판단한다.</p>

\[\text{Gini} = \sum_{j=1}^{J} p_{j}(1-p_{j}) = 1 - \sum_{j=1}^{J} p_{j}^{2}\]

<dl>
  <dt>$J$</dt>
  <dd>각 클래스</dd>
  <dt>$p_{j}$</dt>
  <dd>샘플이 클래스 $j$에 속할 확률</dd>
  <dt>$p_{j}(1-p_{j})$</dt>
  <dd>같은 클래스의 샘플을 뽑을 확률과 이어 다른 클래스의 샘플을 뽑을 확률을 곱하여 한 노드 안이 얼마나 섞여 있는지 나타내준다</dd>
</dl>

<p>지니 계수는 경제학에서 소득이 얼마나 불평등하게 분포되었는지 나타내는 데 쓴다. 결정트리 모델의 맥락에서는 분할된 노드에 얼마나 다른 클래스 샘플이 섞여 있는지 표현해준다. <br />
$p_{j}^{2}$은 그 클래스의 샘플이 두 번 연속 추출될 확률이기 때문에 값이 높을수록 동질성이 높다는 의미다. 지니 계수는 이를 전체에서 뺌으로써 불순도를 계산한 결과다.</p>

<p>위에서 첨부한 이미지를 통해 분할 결과를 지니 계수로 평가해보겠다.</p>

<p><img src="https://github.com/user-attachments/assets/ddaea2b9-6167-4293-ad45-550316e7b1e0" alt="image" /></p>

<p>각 클래스에 대해 $p(1-p)$를 구한 후 합친다.</p>

<p><strong>좌측 노드</strong></p>

<ul>
  <li>노랑 클래스 : 4개 중 2개이므로, $p_{\text{노랑}} = 0.5$. 즉, $0.5 * (1 - 0.5)$.</li>
  <li>초록 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$.</li>
  <li>검정 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$.</li>
</ul>

<p>$\text{Gini}_{\text{좌측}} = 0.25 + 0.1875 + 0.1875 = 0.625$</p>

<p><strong>우측 노드</strong></p>

<ul>
  <li>노랑 클래스 : 3개 중 1개이므로, $p_{\text{노랑}} \approx 0.333$. 즉, $0.333 * (1 - 0.3335)$.</li>
  <li>초록 클래스 : 3개 중 2개이므로, $p_{\text{초록}} \approx 0.667$. 즉, $0.667 * (1 - 0.667)$.</li>
</ul>

<p>$\text{Gini}_{\text{좌측}} = 0.222 + 0.111 = 0.445$</p>

<p>그 다음 분할된 개수를 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다.</p>

\[\text{Gini}_{\text{예시1}} = \frac{4}{7} \times 0.625 + \frac{3}{7} \times 0.445 \approx 0.548\]

<p><br /></p>

<p><img src="https://github.com/user-attachments/assets/2915e5fb-c00a-43ca-85ef-838f220f5032" alt="image" /></p>

<p>해당 분할 결과에 대해서도 동일하게 구한다.</p>

\[\text{Gini}_{\text{예시2}} = \frac{3}{7} \times 0 + \frac{4}{7} \times 0.375 = 0.214\]

<p><em>좌측 노드에서 다른 클래스가 추출될 확률($1-p$)는 $0$이므로 계산 결과도 $0$이 된다.</em></p>

<p><img src="https://github.com/user-attachments/assets/39f7029e-ff17-48d9-a4cf-2520dc142d50" alt="image" /></p>

<p>분할 전 지니 계수가 $0.612$ 라는 점을 고려하면, 두 분할 방식 모두 지니 계수가 줄어들어 불순도가 낮아진 상태이다. 둘 중에서는 <em>이렇게!</em> 의 지니 계수 $0.214$ 가 <em>이렇게?</em> 의 $0.548$ 보다 더 낮으므로 더 적합한 분할이라고 판단할 수 있다.</p>

<h2 id="엔트로피entropy">엔트로피(Entropy)</h2>

<p>엔트로피는 <em>정보량의 기대값</em>을 의미한다.</p>

\[\text{Entropy} = -\sum_{j=1}^{J} p_{j} \log{(p_{j})}\]

<dl>
  <dt>$J$</dt>
  <dd>각 클래스</dd>
  <dt>$p_{j}$</dt>
  <dd>샘플이 클래스 $j$에 속할 확률</dd>
  <dt>$-\log{(p_{j})}$</dt>
  <dd>클래스 $j$에 대한 정보량</dd>
</dl>

<p>정보 이론에서는 <u>의외</u>인 사건이 발생할 때 <strong>정보량(Information Content)</strong>이 더 많다고 본다. 여기서 ‘의외인 사건’은 곧 사건의 확률이 낮다는 것을 의미한다. (11월은 강우 확률이 낮으니까 11월에 눈이 오는 것은 의외인 사건이며 정보량이 많은 것이기도 하다. 1월에 눈이 오는 사건에 비해서 말이다.)</p>

<p><img src="https://github.com/user-attachments/assets/acb1c007-51cd-46f1-b27d-f7bc0d18fd31" alt="image" /></p>

<p>이처럼 확률이 낮을수록 정보량이 많고 높을수록 정보량이 낮아지는 것은 확률에 로그를 취하고 음수화한 값으로 표현할 수 있다. 그리고 이 정보량에 확률을 곱함으로써 구한 <u>기댓값</u>을 엔트로피라고 부른다.</p>

\[-p_{j} \times \log{(p_{j})}\]

<blockquote>
  <p>확률이 낮다 =&gt; 정보량이 많다 =&gt; 엔트로피가 높다 &lt;=&gt; 사건을 예측하기 어렵다</p>
</blockquote>

<p>노드에 다양한 클래스가 혼재되어 있을수록 어떤 클래스가 추출될지 예측하기 어렵다. 따라서 불순도를 측정하는 방식으로 엔트로피를 쓸 수 있다.</p>

<h3 id="정보획득량-information-gain">정보획득량 (Information Gain)</h3>

<p>결정트리 알고리즘 ID3 에서는 ‘정보획득량’을 불순도 지표로 사용하는데, 이는 분할 전후의 엔트로피 차이를 계산한 값이다.</p>

\[IG(S, A) = H(S) - \sum_{t \in T} p(t) H(t) = H(S) - H(S|A)\]

<dl>
  <dt>$IG(S, A)$</dt>
  <dd>$A$ 속성을 기준으로 $S$를 분할했을 때의 정보 획득량</dd>
  <dt>$H(S)$</dt>
  <dd>$S$의 엔트로피</dd>
  <dt>$T$</dt>
  <dd>$S$를 분할함으로써 생성된 노드들</dd>
  <dt>$p(t)$</dt>
  <dd>$S$ 대비 노드 $t$의 비율(크기)</dd>
  <dt>$H(t)$</dt>
  <dd>노드 $t$의 엔트로피</dd>
  <dt>$H(S|A)$</dt>
  <dd>$A$ 속성을 기준으로 $S$를 분할하여 생성된 노드들의 $H(t)$를 가중 평균한 값</dd>
</dl>

<p>‘<em>이렇게!</em>’ 분할 방식을 정보 획득량에 따라 평가해보자. 나이 30살을 기준으로 샘플을 분할했다고 가정했다.</p>

<p><img src="https://github.com/user-attachments/assets/020adc3f-9cb1-4a3c-8d6f-e9fc7b754d58" alt="image" /></p>

<p>먼저 분할 전 엔트로피 $H(S)$를 구한다. 엔트로피 식 $-\sum_{j=1}^{J} p_{j} \log{(p_{j})}$ 을 적용하면 된다.</p>

<ul>
  <li>노랑 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$</li>
  <li>초록 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$</li>
  <li>검정 클래스 : 7개 중 1개이므로, $- \frac{1}{7} \log \frac{1}{7}$</li>
</ul>

<p>$H(S) \approx 0.523 + 0.523 + 0.402 = 1.448$</p>

<p>다음으로 분할 후 엔트로피 $H(S|A)$를 구한다. 이는 각 노드의 엔트로피를 가중 평균하여 계산한다.</p>

<p><strong>True 노드</strong></p>

<ul>
  <li>초록 클래스 : 3개 중 3개이므로, $- \frac{3}{3} \log \frac{3}{3} = 0$</li>
</ul>

<p>$H(\text{True}) = 0$</p>

<p><strong>False 노드</strong></p>

<ul>
  <li>노랑 클래스 : 4개 중 3개이므로, $- \frac{3}{4} \log \frac{3}{4} = 0$</li>
  <li>검정 클래스 : 4개 중 1개이므로, $- \frac{1}{4} \log \frac{1}{4} = 0$</li>
</ul>

<p>$H(\text{True}) \approx 0.311 + 0.5 = 0.811$</p>

<p>그 다음 분할된 비율을 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다.</p>

<p>$H(S|A) = \frac{3}{7} \cdot H(\text{True}) + \frac{4}{7} \cdot H(\text{False}) \approx 0.463$</p>

<p>최종적으로 분할 전에 비해 정보량을 비교한다.</p>

\[IG(S, A) = H(S) - H(S|A) \approx 1.448 - 0.463 = 0.985\]

<p><img src="https://github.com/user-attachments/assets/46c1934c-769d-4d09-b71f-b52ba8edb1bc" alt="image" /></p>

<p>분할 전후의 엔트로피를 비교한 결과 정보 이득은 약 $0.985$이다. 반면 <em>이렇게?</em> 분할 방식의 정보 이득을 계산하면 $0.198$로 비교적 정보 이득이 적은 것을 알 수 있다.</p>

<p>이처럼 불순도를 낮추는 방향으로 데이터를 분할하는 것을 반복함으로써 계층적인 트리 구조를 형성하는 것이 결정트리 방법론이다. 여기서 ‘불순도’를 어떤 지표로 평가할지, 언제까지 분할을 반복할지, 어떤 노드를 주로 참고할지 등 구체적인 활용 방식에 따라 다른 알고리즘이 될 수 있다.</p>

<h1 id="직관-설명하기">직관 설명하기</h1>

<blockquote>
  <p>제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가?</p>
</blockquote>

<p>지금까지 결정트리 방법론의 등장 맥락, 분할의 기준을 살펴보았다. 이제 처음의 질문으로 돌아가보자.</p>

<p><strong>“제한된 범위”</strong></p>

<p>결정트리 모델은 값이 좁은 범위로 제한된 데이터에 대해 유리할 수 있다. 결정트리가 <u>비모수적 모델(non-parametric models)</u>이기 때문이다.<br />
결정트리 모델은 주어진 데이터를 거듭된 조건에 따라 쪼개 나간다. 특정 분포를 가정하지 않고 <strong>주어진 데이터에 따라 비선형적인 구조를 형성</strong>한다는 의미다. 반면 선형회귀와 같은 모수적 모델은 <strong>모든 범위의 데이터에 대해서 유효한 분포(함수)</strong>가 있다고 가정하고 이에 맞춰 파라미터를 학습(fit)한다. 실제 데이터에 비해 함수 가정이 과도할 수 있다. 우리는 0 ~ 10 의 범위에서 벗어나는 입력은 전혀 고려하지 않고 있단 말이다.</p>

<p><strong>“정수”</strong></p>

<p>결정트리 모델은 특정 임계값을 기준으로 데이터를 분할하는데, 정수형 데이터는 이산적(discrete) 성격을 띠므로 <u>분할 자체가 직관적이고 간단해진다</u>. 예를 들어 ‘5번 질문에 대한 응답이 3점 이상’이라는 분할 조건을 세우는 건 간단하고 직관적이다. 하지만 데이터가 연속형이었으면 ‘A 속성이 0.3728 이상’과 같이 정밀한 임계값을 정해야 했을 것이다. 당연히 더 많은 경우의 수를 고려해야 하기 때문에 난이도가 높아진다.</p>

<p><strong>“응답 데이터”</strong></p>

<p>설문 참여자들은 비슷한 질문에 대해 비슷하게 응답하는 경향이 있을 것이다. 예를 들어 ‘인생이 행복합니까?’ 라는 질문에 그렇다고 응답할수록, ‘생활이 만족스럽습니까?’ 라는 질문에도 그렇다고 응답할 것이다. 이처럼 변수 간 상관관계가 존재하는 다중공선성의 문제에 결정트리 모델이 유리하다. 애초에 결정트리는 사회과학 연구에서 일종의 교차분석과 유사한 방법론으로 제시되지 않았는가?<br />
결정트리는 불순도가 (지니 계수든 엔트로피든) 가장 크게 감소하는 조건을 선택하여 분할을 실시하기 때문에 <u>가장 중요한 변수가 우선적으로 선택되는 효과</u>가 있다. 그 결과 비슷한 패턴의 변수들은 자연스럽게 제외되기 때문에 변수 간 상관관계는 결정트리 모델에 큰 해가 되지 않는다.</p>

<h1 id="나가며">나가며</h1>

<p>결정트리의 작동 맥락과 주요 지표를 살펴봄으로써 나의 직관을 설명할 수 있었다. 이 과정에서 ‘비모수형 모델’의 개념을 명확하게 이해할 수 있게 되었고, 머신러닝 분야에서 ‘엔트로피’가 가지는 의미를 다시 상기할 수 있었다. 이번 공부를 통해 나의 직관이 어느 정도 의미 있었다는 결론을 내렸으므로, 이제 실제 적용하는 일만 남았다.</p>

<p>분량이 너무 길어져서 가지치기나 정지규칙, 코드 등 더 깊은 내용은 다루지 못했지만 모델의 본질과 연결되는 직관을 이해했다는 점에서 만족스러운 공부였다. 이어서 결정트리 방법론을 기반으로 하는 다양한 머신러닝 모델에 대해서 하나씩 공부하는 시간을 가져보겠다.</p>]]></content><author><name></name></author><category term="머신러닝" /><summary type="html"><![CDATA[들어가며 아래와 같은 설문조사가 있다. 응답자들은 0 ~ 10점 선지 중 하나를 선택한다. 이러한 응답 데이터를 활용해서 특정 값을 예측하려 한다. 어떤 모델을 쓰면 좋을까? 이 문제 상황에서 가장 먼저 떠올린 것은 결정트리 모델이었다. 최소 0부터 최대 10으로 스케일이 한정된 정수 데이터가 주어졌으며, 결정트리 모델은 조건 (예를 들면, $x &gt; 4$ ?)에 따라 샘플을 나누며 가지를 뻗어나가기 때문이다. 문제를 해결하는 데 결정트리가 적절한 모델이라는 직관적인 느낌을 받았다. 그러나 내가 설명할 수 있는 최선은 여기까지였다. “내가 모델의 개념과 원리를 근본적으로 이해하고 있나?” 반성하게 되었고, 이 글을 쓰게 된 계기가 되었다. 제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가? 즉, 이 질문에 답변하기 위해 해당 모델을 공부한 글이다. 개념 결정트리 Decision Tree, 의사결정 나무라고도 부른다. 데이터를 기준에 따라 반복 분할함으로써 계층적인 구조로 하위 집합을 형성하는 방법론 역사로 이해하기 결정트리 모델의 시초는 1960년대 사회과학에서 찾아볼 수 있다. 이후 1980년대 데이터 과학 분야의 발전과 함께 결정트리 방법론이 소개되고 다양한 모델이 개발, 활용되기 시작했다. 우선 1963년에 발간된 사회과학서 Problems in the Analysis of Survey Data, and a Proposal에 초기 개념이 소개되었다. 고차원의 다중공선성을 띠는 설문조사 데이터를 다루기 위한 방법론으로, 오차제곱합(SSE)를 최소화하도록 하위 그룹으로 분할한다. 사회과학 분야에서 다룰 법한 간단한 예제를 상상해봤다. 응답자의 나이, 성별, 연봉 수준을 수집했으며 이에 따른 직업 만족도를 비교하려 한다. 그런데 나이가 많을수록 연봉 수준이 높아지기도 하고, 분포 상 응답자가 여자일수록 나이대가 낮아진다. 이러한 변수 간 상호작용을 고려하면서 종속변수(직업 만족도)의 차이를 설명하기 위해 응답자를 그룹으로 나눠볼 수 있다. 30대 미만/이상으로 나눠도 좋고, 성별에 따라 나눠도 좋다. 중요한 건 나눠진 그룹끼리 직업 만족도를 비교했을 때 차이가 커지도록 하는 것이다. 그룹끼리 차이가 커지도록 그룹을 나누는 이유는, 그룹 안의 동질성이 높다는 것과 같은 의미이기 때문이다. 한 그룹의 평균을 예측값으로 삼는다고 치자. 그룹의 동질성이 높을수록 그룹 내 샘플들은 평균에 가까이 몰려 있을 테니 실제값과 예측값 간의 오차가 전반적으로 줄어든다. 이렇듯 직업 만족도가 가장 크게 차이나는 두 그룹으로 나눠 첫번째 분할을 마쳤다. 그 다음에 오차가 더 큰 그룹을 선택한 다음 그 안에서 또 분할한다. 마찬가지로 그룹 간 차이가 크게 발생하는, 다시 말해 오차를 최소화하는 분할 기준을 결정한다. 분할을 반복한다. Problems in the Analysis of Survey Data, and a Proposal(1963), 17페이지. 오늘날 결정트리 모델을 시각화한 모습과 같다. 사회과학 분야에서 분할의 결과는 이렇게 활용할 수 있다. ‘30세 미만 남성 노동직 그룹과 여성 고졸 그룹의 직업 만족도가 75점 수준으로 비슷하다’ - 한편 머신러닝 분야라면? 입력 데이터에 대해 예측값을 출력하는 모델을 생성하는 데 활용할 수 있겠다! 30세 미만 남성 노동직이 입력으로 들어오면 75점 가량으로 예측하는 것이다. 이어 1984년 Classification and Regression Trees에서 결정트리 방법론을 기반으로 한 알고리즘 CART가 발표됐다. Classification And Regression Tree의 줄임말이다. 이어 CART의 업그레이드 버전인 ID3(Iterative Dichotomiser 3), C4.5, C5.0 등이 발표되면서 결정트리 모델이 더욱 발전해나갔다. 오늘날 많이 사용하는 Random Forest, XGBoost도 결정트리 방법론을 기반으로 개발된 알고리즘들이다. 분할의 기준 CART, ID3, C4.5, C5.0 알고리즘은 모두 결정트리 방법론을 기반으로 한다. 하지만 분할 기준을 무엇으로 설정하는지에 따라 다른 알고리즘으로 발전한 결과다. 앞서 언급한 예제에서는 간단하게 그룹별 직업 만족도의 평균값 차이를 기준으로 분할했지만, 실제 알고리즘에서는 더 효율적이거나 정교한 지표를 분할의 기준으로 삼는다. 분할 기준의 본질은 불순도(impurity)를 낮추는 것이다. 앞서 그룹 내 동질성을 높이는 것이 중요하다고 언급했다. 이는 불순도를 낮춘다는 말과 의미가 동일하다. 다른 데이터가 많이 섞여 있을수록 동질성이 떨어지며 이는 곧 불순도가 높은 상태다 분할의 결과로 얼마나 동질성이 높아지거나 낮아졌는지, 불순도를 수치화하는 방식은 크게 두 가지. 지니 계수와 엔트로피(정보 이득)다. 소개한 알고리즘 중 CART는 지니 계수를 사용하며, ID3, C4.5, C5.0은 엔트로피 및 정보 이득을 사용한다. 지니 계수(Gini coefficient) 지니 계수가 높을수록 불순도가 높다고 판단한다. \[\text{Gini} = \sum_{j=1}^{J} p_{j}(1-p_{j}) = 1 - \sum_{j=1}^{J} p_{j}^{2}\] $J$ 각 클래스 $p_{j}$ 샘플이 클래스 $j$에 속할 확률 $p_{j}(1-p_{j})$ 같은 클래스의 샘플을 뽑을 확률과 이어 다른 클래스의 샘플을 뽑을 확률을 곱하여 한 노드 안이 얼마나 섞여 있는지 나타내준다 지니 계수는 경제학에서 소득이 얼마나 불평등하게 분포되었는지 나타내는 데 쓴다. 결정트리 모델의 맥락에서는 분할된 노드에 얼마나 다른 클래스 샘플이 섞여 있는지 표현해준다. $p_{j}^{2}$은 그 클래스의 샘플이 두 번 연속 추출될 확률이기 때문에 값이 높을수록 동질성이 높다는 의미다. 지니 계수는 이를 전체에서 뺌으로써 불순도를 계산한 결과다. 위에서 첨부한 이미지를 통해 분할 결과를 지니 계수로 평가해보겠다. 각 클래스에 대해 $p(1-p)$를 구한 후 합친다. 좌측 노드 노랑 클래스 : 4개 중 2개이므로, $p_{\text{노랑}} = 0.5$. 즉, $0.5 * (1 - 0.5)$. 초록 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$. 검정 클래스 : 4개 중 1개이므로, $p_{\text{초록}} = 0.25$. 즉, $0.25 * (1 - 0.25)$. $\text{Gini}_{\text{좌측}} = 0.25 + 0.1875 + 0.1875 = 0.625$ 우측 노드 노랑 클래스 : 3개 중 1개이므로, $p_{\text{노랑}} \approx 0.333$. 즉, $0.333 * (1 - 0.3335)$. 초록 클래스 : 3개 중 2개이므로, $p_{\text{초록}} \approx 0.667$. 즉, $0.667 * (1 - 0.667)$. $\text{Gini}_{\text{좌측}} = 0.222 + 0.111 = 0.445$ 그 다음 분할된 개수를 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다. \[\text{Gini}_{\text{예시1}} = \frac{4}{7} \times 0.625 + \frac{3}{7} \times 0.445 \approx 0.548\] 해당 분할 결과에 대해서도 동일하게 구한다. \[\text{Gini}_{\text{예시2}} = \frac{3}{7} \times 0 + \frac{4}{7} \times 0.375 = 0.214\] 좌측 노드에서 다른 클래스가 추출될 확률($1-p$)는 $0$이므로 계산 결과도 $0$이 된다. 분할 전 지니 계수가 $0.612$ 라는 점을 고려하면, 두 분할 방식 모두 지니 계수가 줄어들어 불순도가 낮아진 상태이다. 둘 중에서는 이렇게! 의 지니 계수 $0.214$ 가 이렇게? 의 $0.548$ 보다 더 낮으므로 더 적합한 분할이라고 판단할 수 있다. 엔트로피(Entropy) 엔트로피는 정보량의 기대값을 의미한다. \[\text{Entropy} = -\sum_{j=1}^{J} p_{j} \log{(p_{j})}\] $J$ 각 클래스 $p_{j}$ 샘플이 클래스 $j$에 속할 확률 $-\log{(p_{j})}$ 클래스 $j$에 대한 정보량 정보 이론에서는 의외인 사건이 발생할 때 정보량(Information Content)이 더 많다고 본다. 여기서 ‘의외인 사건’은 곧 사건의 확률이 낮다는 것을 의미한다. (11월은 강우 확률이 낮으니까 11월에 눈이 오는 것은 의외인 사건이며 정보량이 많은 것이기도 하다. 1월에 눈이 오는 사건에 비해서 말이다.) 이처럼 확률이 낮을수록 정보량이 많고 높을수록 정보량이 낮아지는 것은 확률에 로그를 취하고 음수화한 값으로 표현할 수 있다. 그리고 이 정보량에 확률을 곱함으로써 구한 기댓값을 엔트로피라고 부른다. \[-p_{j} \times \log{(p_{j})}\] 확률이 낮다 =&gt; 정보량이 많다 =&gt; 엔트로피가 높다 &lt;=&gt; 사건을 예측하기 어렵다 노드에 다양한 클래스가 혼재되어 있을수록 어떤 클래스가 추출될지 예측하기 어렵다. 따라서 불순도를 측정하는 방식으로 엔트로피를 쓸 수 있다. 정보획득량 (Information Gain) 결정트리 알고리즘 ID3 에서는 ‘정보획득량’을 불순도 지표로 사용하는데, 이는 분할 전후의 엔트로피 차이를 계산한 값이다. \[IG(S, A) = H(S) - \sum_{t \in T} p(t) H(t) = H(S) - H(S|A)\] $IG(S, A)$ $A$ 속성을 기준으로 $S$를 분할했을 때의 정보 획득량 $H(S)$ $S$의 엔트로피 $T$ $S$를 분할함으로써 생성된 노드들 $p(t)$ $S$ 대비 노드 $t$의 비율(크기) $H(t)$ 노드 $t$의 엔트로피 $H(S|A)$ $A$ 속성을 기준으로 $S$를 분할하여 생성된 노드들의 $H(t)$를 가중 평균한 값 ‘이렇게!’ 분할 방식을 정보 획득량에 따라 평가해보자. 나이 30살을 기준으로 샘플을 분할했다고 가정했다. 먼저 분할 전 엔트로피 $H(S)$를 구한다. 엔트로피 식 $-\sum_{j=1}^{J} p_{j} \log{(p_{j})}$ 을 적용하면 된다. 노랑 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$ 초록 클래스 : 7개 중 3개이므로, $- \frac{3}{7} \log \frac{3}{7}$ 검정 클래스 : 7개 중 1개이므로, $- \frac{1}{7} \log \frac{1}{7}$ $H(S) \approx 0.523 + 0.523 + 0.402 = 1.448$ 다음으로 분할 후 엔트로피 $H(S|A)$를 구한다. 이는 각 노드의 엔트로피를 가중 평균하여 계산한다. True 노드 초록 클래스 : 3개 중 3개이므로, $- \frac{3}{3} \log \frac{3}{3} = 0$ $H(\text{True}) = 0$ False 노드 노랑 클래스 : 4개 중 3개이므로, $- \frac{3}{4} \log \frac{3}{4} = 0$ 검정 클래스 : 4개 중 1개이므로, $- \frac{1}{4} \log \frac{1}{4} = 0$ $H(\text{True}) \approx 0.311 + 0.5 = 0.811$ 그 다음 분할된 비율을 기준으로 가중평균을 구한다. 좌측 노드는 네 개, 우측 노드는 세 개 샘플을 가져갔다. $H(S|A) = \frac{3}{7} \cdot H(\text{True}) + \frac{4}{7} \cdot H(\text{False}) \approx 0.463$ 최종적으로 분할 전에 비해 정보량을 비교한다. \[IG(S, A) = H(S) - H(S|A) \approx 1.448 - 0.463 = 0.985\] 분할 전후의 엔트로피를 비교한 결과 정보 이득은 약 $0.985$이다. 반면 이렇게? 분할 방식의 정보 이득을 계산하면 $0.198$로 비교적 정보 이득이 적은 것을 알 수 있다. 이처럼 불순도를 낮추는 방향으로 데이터를 분할하는 것을 반복함으로써 계층적인 트리 구조를 형성하는 것이 결정트리 방법론이다. 여기서 ‘불순도’를 어떤 지표로 평가할지, 언제까지 분할을 반복할지, 어떤 노드를 주로 참고할지 등 구체적인 활용 방식에 따라 다른 알고리즘이 될 수 있다. 직관 설명하기 제한된 범위의 정수로 이루어진 응답 데이터를 처리하는 데 있어서 결정트리 모델이 적절한가? 지금까지 결정트리 방법론의 등장 맥락, 분할의 기준을 살펴보았다. 이제 처음의 질문으로 돌아가보자. “제한된 범위” 결정트리 모델은 값이 좁은 범위로 제한된 데이터에 대해 유리할 수 있다. 결정트리가 비모수적 모델(non-parametric models)이기 때문이다. 결정트리 모델은 주어진 데이터를 거듭된 조건에 따라 쪼개 나간다. 특정 분포를 가정하지 않고 주어진 데이터에 따라 비선형적인 구조를 형성한다는 의미다. 반면 선형회귀와 같은 모수적 모델은 모든 범위의 데이터에 대해서 유효한 분포(함수)가 있다고 가정하고 이에 맞춰 파라미터를 학습(fit)한다. 실제 데이터에 비해 함수 가정이 과도할 수 있다. 우리는 0 ~ 10 의 범위에서 벗어나는 입력은 전혀 고려하지 않고 있단 말이다. “정수” 결정트리 모델은 특정 임계값을 기준으로 데이터를 분할하는데, 정수형 데이터는 이산적(discrete) 성격을 띠므로 분할 자체가 직관적이고 간단해진다. 예를 들어 ‘5번 질문에 대한 응답이 3점 이상’이라는 분할 조건을 세우는 건 간단하고 직관적이다. 하지만 데이터가 연속형이었으면 ‘A 속성이 0.3728 이상’과 같이 정밀한 임계값을 정해야 했을 것이다. 당연히 더 많은 경우의 수를 고려해야 하기 때문에 난이도가 높아진다. “응답 데이터” 설문 참여자들은 비슷한 질문에 대해 비슷하게 응답하는 경향이 있을 것이다. 예를 들어 ‘인생이 행복합니까?’ 라는 질문에 그렇다고 응답할수록, ‘생활이 만족스럽습니까?’ 라는 질문에도 그렇다고 응답할 것이다. 이처럼 변수 간 상관관계가 존재하는 다중공선성의 문제에 결정트리 모델이 유리하다. 애초에 결정트리는 사회과학 연구에서 일종의 교차분석과 유사한 방법론으로 제시되지 않았는가? 결정트리는 불순도가 (지니 계수든 엔트로피든) 가장 크게 감소하는 조건을 선택하여 분할을 실시하기 때문에 가장 중요한 변수가 우선적으로 선택되는 효과가 있다. 그 결과 비슷한 패턴의 변수들은 자연스럽게 제외되기 때문에 변수 간 상관관계는 결정트리 모델에 큰 해가 되지 않는다. 나가며 결정트리의 작동 맥락과 주요 지표를 살펴봄으로써 나의 직관을 설명할 수 있었다. 이 과정에서 ‘비모수형 모델’의 개념을 명확하게 이해할 수 있게 되었고, 머신러닝 분야에서 ‘엔트로피’가 가지는 의미를 다시 상기할 수 있었다. 이번 공부를 통해 나의 직관이 어느 정도 의미 있었다는 결론을 내렸으므로, 이제 실제 적용하는 일만 남았다. 분량이 너무 길어져서 가지치기나 정지규칙, 코드 등 더 깊은 내용은 다루지 못했지만 모델의 본질과 연결되는 직관을 이해했다는 점에서 만족스러운 공부였다. 이어서 결정트리 방법론을 기반으로 하는 다양한 머신러닝 모델에 대해서 하나씩 공부하는 시간을 가져보겠다.]]></summary></entry><entry><title type="html">📖 『JAX/Flax로 딥러닝 레벨업』(제이펍) 리뷰</title><link href="https://woocosmos.github.io/jax-lev-up-review/" rel="alternate" type="text/html" title="📖 『JAX/Flax로 딥러닝 레벨업』(제이펍) 리뷰" /><published>2024-10-13T00:00:00+09:00</published><updated>2024-10-13T00:00:00+09:00</updated><id>https://woocosmos.github.io/jax-lev-up-review</id><content type="html" xml:base="https://woocosmos.github.io/jax-lev-up-review/"><![CDATA[<p><img src="https://github.com/user-attachments/assets/76f397ea-6ed8-404c-99bc-e8c43ca4c04d" alt="IMG_4524" class="center-image" /></p>

<p><br />
IT 실용서 전문 출판사 제이펍으로부터 책 『<a href="https://product.kyobobook.co.kr/detail/S000214172972"><strong>JAX/Flax로 딥러닝 레벨업</strong></a>』를 무료로 제공 받았다.</p>

<h1 id="개요">개요</h1>

<dl>
  <dt>도서명</dt>
  <dd>JAX/Flax로 딥러닝 레벨업</dd>
  <dt>지은이</dt>
  <dd>이영빈 , 유현아 , 김한빈 , 조영빈 , 이태호 , 장진우 , 박정현 , 김형섭 , 이승현</dd>
  <dt>발행사</dt>
  <dd>제이펍</dd>
  <dt>초판 발행</dt>
  <dd>2024년 9월 23일</dd>
  <dt>정가</dt>
  <dd>24,000원</dd>
</dl>

<hr />

<p>베타리더 후기에 따르면 『JAX/Flax로 딥러닝 레벨업』은 무려 국내 최초 JAX 입문서라고 한다. 최근 성장하고 있는 JAX 생태계의 활성화에 기여하는 의미가 있겠다.</p>

<p>개인적으로 JAX는 ‘고성능 딥러닝 연산이 가능한 numpy’ 정도로 알고 있는 상태였고 직접 활용해본 적은 없었다. 이번 책 리뷰를 계기로 Numpy와의 차이점과 JAX/Flax의 주요 특징을 이해하고 실제 튜토리얼을 따라가는 경험을 쌓으려 한다.</p>

<p>책은 크게 JAX/Flax를 소개하는 부분과 JAX/Flax를 활용하여 딥러닝 모델을 구현하는 부분으로 이뤄져 있다. 파이썬 프로그래밍과 기본적인 머신러닝 개념은 책을 읽기 위한 선수 지식으로 요구된다.</p>

<h1 id="jax란">Jax란?</h1>

<blockquote>
  <p>한마디로 표현하면 자동 미분과 XLA를 결합해서 사용하는 고성능 머신러닝 프레임워크입니다 … JAX의 가장 큰 강점은 XLA를 적용해서 사용할 수 있다는 점입니다.</p>
</blockquote>

<p>PyTorch, Tensorflow 등 다른 딥러닝 프레임워크도 자동 미분을 지원하지만, JAX는 이에 더해 <strong>XLA(Accelerated Linear Algebra)</strong>이 가능하다는 것이 핵심이다. XLA는 GPU/TPU 위에서 numpy를 컴파일하고 실행하는 컴파일러다. JAX는 JIT(Just-In-Time) 컴파일을 통해 파이썬 코드를 XLA에 최적화된 기계어로 변환하기 때문에 <a href="https://woocosmos.github.io/pytorch-basic/#autograd-%EC%9E%90%EB%8F%99%EB%AF%B8%EB%B6%84">PyTorch의 동적 그래프</a>보다도 빠르고 효율적으로 연산할 수 있다는 것이다.</p>

<p>파이썬은 기본적으로 인터프리터 방식으로 실행되기 때문에 코드를 한 줄씩 읽고 해석하는 데 시간이 소요된다. 여기서 JIT 컴파일을 사용한다면 <strong>코드를 실행하는 시점</strong>에 성능과 연관되는 일부분을 미리 기계어로 컴파일하여 속도가 빨라진다고 이해했다.</p>

<h2 id="flax">Flax</h2>

<blockquote>
  <p>JAX + Flexibility를 합쳐져서 만들었으며 엔지니어들이 JAX를 조금 더 쉽게 사용할 수 있는 프레임워크이며, 다른 딥러닝 프레임워크들처럼 레이어(층) 개념을 지원합니다.</p>
</blockquote>

<p>여기까지 읽었을 때 Tensorflow &amp; Keras 와 유사한 개념(관계)이 아닌가 싶었는데, JAX/Flax는 Low-level의 섬세한 컨트롤이 가능하다는 점에 방점이 찍혀 있는 것 같다. 그와 달리 Keras는 높은 수준의 추상화가 이루어져 있고 사용자 친화적이다. 똑같이 구글에서 개발한 프레임워크지만 지향하는 철학이 다르다는 점이 재밌다.</p>

<p>책에 따르면 구글에서 개발한 모델들은 대부분 JAX로 작성되어 있고, 심지어 Hugging Face의 기존 모델들도 JAX로 변환하고 있다고 한다.</p>

<h2 id="함수형-프로그래밍">함수형 프로그래밍</h2>

<p>JAX/Flax의 활용 방식을 더 잘 파악할 수 있도록 책은 <strong>함수형 프로그래밍</strong>에 대해서 별도 챕터로 설명한다. 명령어의 흐름(순서)대로 상태를 변경하고 결과를 전달하는 것이 핵심인 절차적 프로그래밍과 다르게, 함수형 프로그래밍은 외부 상태와 상관없이 주어진 입력에 동일한 출력값을 내놓는 <em>순수 함수</em>를 사용한다. 따라서 <em>부수 효과</em>가 제거되며 상태가 변화하지 않는 불변성을 강조한다. 여기서 절차적 프로그래밍과 함수형 프로그래밍을 설명할 때 간단한 파이썬 예제가 첨부되어 있어서 이해가 편했다.</p>

<p>JAX, 나아가 딥러닝 연산에 있어서 이 개념을 이해하는 것이 중요한 이유를 세 가지로 제시하고 있다.</p>

<ol>
  <li>XLA 컴파일에 최적화된 처리가 가능해진다</li>
  <li>병렬처리와 분산처리에 유용하다</li>
  <li>코드를 모듈화함으로써 재사용성이 높아진다</li>
</ol>

<h1 id="jax-기본">JAX 기본</h1>

<p>백문이 불여일견, 직접 JAX 를 활용해보며 책의 내용을 따라가보겠다.</p>

<h2 id="설치">설치</h2>

<p>다행히도 JAX가 Mac M1을 공식 지원한다고 하여 <code class="language-plaintext highlighter-rouge">conda</code>로 쉽게 설치할 수 있었다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create <span class="nt">-n</span> jax-env <span class="nv">python</span><span class="o">=</span>3.9
conda activate jax-env
pip <span class="nb">install </span>jax jaxlib
</code></pre></div></div>

<p>import 하기</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">jax</span>
<span class="kn">import</span> <span class="n">jax.numpy</span> <span class="k">as</span> <span class="n">jnp</span>
</code></pre></div></div>

<h2 id="numpy와-비교">numpy와 비교</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x1</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span>
<span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>        <span class="c1"># [5. 7. 9.]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>  <span class="c1"># &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;
</span></code></pre></div></div>

<p>위 예제에서 보듯 jax.numpy는 기존 numpy 와 거의 똑같은 API를 제공하고 있다.</p>

<h2 id="grad-함수">grad 함수</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">grad</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grad</span><span class="p">(</span><span class="mf">3.</span><span class="p">))</span>    <span class="c1"># Array(6., dtype=float32, weak_type=True)
</span></code></pre></div></div>

<p>JAX에서 미분, 즉 gradient를 계산해주는 <code class="language-plaintext highlighter-rouge">grad</code>를 사용한 예제다.</p>

<h2 id="부수-효과의-방지">부수 효과의 방지</h2>

<p>JAX는 부수 효과를 제거하는 함수형 프로그래밍의 제약을 따르고 있다. 책에서 제공해준 아래 예제를 참고해보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">x_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span>      <span class="c1"># [999   2   3]
</span></code></pre></div></div>

<p>numpy로 생성한 배열은 직접 접근해서 요소를 변경할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_2</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">x_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
<span class="c1"># TypeError: '&lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;' object does not support item assignment. JAX arrays are immutable.
</span></code></pre></div></div>

<p>반면 jax.numpy로 생성한 배열은 직접적인 수정을 허용하지 않는다. 이는 ‘외부 데이터’인 배열의 상태가 변형되면서 부수 효과가 발생하는 것을 방지하기 위함이다.<br />
만약 배열의 일부를 수정하는 작업을 진행하고 싶다면 부수 효과가 없는 순수 함수를 사용해야 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_2</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nf">modify</span><span class="p">(</span><span class="n">x_2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>    <span class="c1"># Array([999,   2,   3], dtype=int32)
</span></code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">modify(x)</code>는 부수 효과가 없는 순수 함수라고 볼 수 있는 것이며, 책은 <code class="language-plaintext highlighter-rouge">jax.grad</code>와 <code class="language-plaintext highlighter-rouge">jax.jit</code> 같은 함수는 순수 함수로 작성되어야 한다고 설명하고 있다.</p>

<h2 id="jit-컴파일">JIT 컴파일</h2>

<dl>
  <dt>변환</dt>
  <dd>주어진 함수를 변경하거나 수정하는 방식. 성능 최적화나 자동 미분을 가능하게 함.</dd>
</dl>

<p>책은 JAX에서 <mark>변환</mark>(transformation)이라는 키워드가 중요하다고 말한다. JAX에서 변환은 <code class="language-plaintext highlighter-rouge">jaxpr</code>, 즉 JAX 표현식이라는 중간 언어(intermediate language)를 통해 이루어진다. <code class="language-plaintext highlighter-rouge">jax.jit</code>가 대표적인 jax 변환이라고 소개된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.67</span><span class="p">,</span> <span class="n">lamdba_</span><span class="o">=</span><span class="mf">1.05</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lamdba_</span> <span class="o">*</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>

<span class="c1"># 일반
</span><span class="nf">selu</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">block_until_ready</span><span class="p">()</span>

<span class="c1"># XLA
</span><span class="n">selu_jit</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">jit</span><span class="p">(</span><span class="n">selu</span><span class="p">)</span>
<span class="nf">selu_jit</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">block_until_ready</span><span class="p">()</span> <span class="c1"># 비동기 실행
</span></code></pre></div></div>

<p>위 내용은 활성화 함수 SELU(Scaled Exponential Linear Unit)를 구현하고 호출한 내용이다.</p>

<p><img src="https://github.com/user-attachments/assets/859541e3-c76b-4791-a1f4-b624e2570fa8" alt="image" /></p>

<p><code class="language-plaintext highlighter-rouge">selu(x)</code> 대신에 jit 변환을 적용한 <code class="language-plaintext highlighter-rouge">selu_jit(x)</code>가 7배 빠르다고 설명하고 있다. (구글 Colab T4 기준)</p>

<p>책을 읽으면서 흥미로웠던 부분은 <code class="language-plaintext highlighter-rouge">jax.jit</code>은 컴파일된 계산 그래프를 캐싱하여 재사용한다는 점이었다. 다만 <code class="language-plaintext highlighter-rouge">jax.jit</code>을 반복문 내부에서 호출할 경우 컴파일 과정이 불필요하게 반복될 수 있으니 지양하라고 안내하고 있다.</p>

<h1 id="flax-1">Flax</h1>

<p>마지막으로 Flax 를 활용한 예제를 살펴보겠다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">flax.linen</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="n">jax</span> <span class="kn">import</span> <span class="n">random</span>

<span class="n">key</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nc">PRNGKey</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="n">out_dims</span><span class="p">:</span> <span class="nb">int</span>
    
    <span class="nd">@nn.compact</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">reshape</span><span class="p">((</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nf">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">out_dims</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">out_dims</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p><em>책에 import 하는 부분은 없어서 추가했다</em><br />
<code class="language-plaintext highlighter-rouge">nn.Module</code> 에서 상속받아 모델을 생성한다는 점에서 PyTorch 와 유사한 방식의 API 라고 느껴졌고 금방 적응할 수 있겠다는 생각이 든다.</p>

<hr />

<h1 id="나가며">나가며</h1>

<p>『JAX/Flax로 딥러닝 레벨업』에서 JAX 핵심 개념을 위주로 살펴보며 책을 리뷰해보았다. <em>요즘 시점에서 왜 굳이 새로운 딥러닝 프레임워크가 필요할까?</em> 라고 막연히 궁금해 하며 리뷰어 신청을 했는데, 좋은 기회로 책도 제공 받고 JAX와 Flax에 대해 가볍게 배워볼 수 있는 시간이었다.</p>

<p>JAX가 지향하는 철학과 함께 그것이 녹아든 핵심 기능을 세세하게 설명해주기 때문에 JAX 입문서로 아주 알맞은 도서라는 생각이 들었다. 특히 함수형 프로그래밍 개념만을 설명하기 위해 별도 지면을 할애했다는 점에서는 JAX의 의미를 제대로 전달하겠다는 강한 의지도 보였다.</p>

<p>아마 JAX로 입문하기까지 가장 큰 장벽은 앞서 내가 떠올린 것과 같이 “왜 꼭 이것이어야 하는가?” 라는 의문일 텐데, 이 책을 읽는다면 그 장벽 정도는 충분히 넘을 수 있겠다. numpy 하나로 모델을 구현하는 정도로 low-level에서 모델링과 학습 과정 등을 유연하게 통제할 수 있다는 점이 JAX/Flax의 가장 강력한 정체성이라고 느꼈다. 구글 TPU를 사용하는 ML엔지니어라면 시간을 들여서라도 JAX를 적용할 가치가 있을 듯하다.</p>

<p>그 외에 CLIP, GPT 같은 최신 모델의 fine-tuning 을 예제로 다룬 점도 인상적이었다. ML 분야에 입문한 이후로 출판서를 활용해서 공부를 하는 건 정말 오랜만인데, 역시 최신 책이니 최신 모델도 다루는구나 - 싶었다.</p>

<p>다만 책 서문에서 이미 밝혔다시피 딥러닝 개념과 프레임워크에 대한 기본적인 지식이 있어야 책의 내용을 제대로 이해할 수 있다는 점은 염두에 둘 필요가 있겠다. 확실히 ‘초급서’라기보단 ‘입문서’로 보는 게 맞다. 또한 워낙에 고급 프레임워크다보니까 JAX/Flax 자체가 서비스(서빙)보다는 <strong>연구</strong>에 적합한 도구라는 생각이 들었다. 책 읽기 전과 비슷하게 <em>이것이 이것이 필요할까?</em> 라는 질문은 여전히 깔끔하게 해명되진 않았지만, 책을 읽고 나서 <em>언젠가 JAX를 써보고 싶다</em>는 욕심은 보다 뚜렷해졌다.</p>

<p>리뷰어로 선정하여 도서를 제공해준 출판사 제이펍에 진심으로 감사하다는 말씀을 표하며 본 리뷰를 마무리하겠다.</p>]]></content><author><name></name></author><category term="리뷰" /><summary type="html"><![CDATA[IT 실용서 전문 출판사 제이펍으로부터 책 『JAX/Flax로 딥러닝 레벨업』를 무료로 제공 받았다. 개요 도서명 JAX/Flax로 딥러닝 레벨업 지은이 이영빈 , 유현아 , 김한빈 , 조영빈 , 이태호 , 장진우 , 박정현 , 김형섭 , 이승현 발행사 제이펍 초판 발행 2024년 9월 23일 정가 24,000원 베타리더 후기에 따르면 『JAX/Flax로 딥러닝 레벨업』은 무려 국내 최초 JAX 입문서라고 한다. 최근 성장하고 있는 JAX 생태계의 활성화에 기여하는 의미가 있겠다. 개인적으로 JAX는 ‘고성능 딥러닝 연산이 가능한 numpy’ 정도로 알고 있는 상태였고 직접 활용해본 적은 없었다. 이번 책 리뷰를 계기로 Numpy와의 차이점과 JAX/Flax의 주요 특징을 이해하고 실제 튜토리얼을 따라가는 경험을 쌓으려 한다. 책은 크게 JAX/Flax를 소개하는 부분과 JAX/Flax를 활용하여 딥러닝 모델을 구현하는 부분으로 이뤄져 있다. 파이썬 프로그래밍과 기본적인 머신러닝 개념은 책을 읽기 위한 선수 지식으로 요구된다. Jax란? 한마디로 표현하면 자동 미분과 XLA를 결합해서 사용하는 고성능 머신러닝 프레임워크입니다 … JAX의 가장 큰 강점은 XLA를 적용해서 사용할 수 있다는 점입니다. PyTorch, Tensorflow 등 다른 딥러닝 프레임워크도 자동 미분을 지원하지만, JAX는 이에 더해 XLA(Accelerated Linear Algebra)이 가능하다는 것이 핵심이다. XLA는 GPU/TPU 위에서 numpy를 컴파일하고 실행하는 컴파일러다. JAX는 JIT(Just-In-Time) 컴파일을 통해 파이썬 코드를 XLA에 최적화된 기계어로 변환하기 때문에 PyTorch의 동적 그래프보다도 빠르고 효율적으로 연산할 수 있다는 것이다. 파이썬은 기본적으로 인터프리터 방식으로 실행되기 때문에 코드를 한 줄씩 읽고 해석하는 데 시간이 소요된다. 여기서 JIT 컴파일을 사용한다면 코드를 실행하는 시점에 성능과 연관되는 일부분을 미리 기계어로 컴파일하여 속도가 빨라진다고 이해했다. Flax JAX + Flexibility를 합쳐져서 만들었으며 엔지니어들이 JAX를 조금 더 쉽게 사용할 수 있는 프레임워크이며, 다른 딥러닝 프레임워크들처럼 레이어(층) 개념을 지원합니다. 여기까지 읽었을 때 Tensorflow &amp; Keras 와 유사한 개념(관계)이 아닌가 싶었는데, JAX/Flax는 Low-level의 섬세한 컨트롤이 가능하다는 점에 방점이 찍혀 있는 것 같다. 그와 달리 Keras는 높은 수준의 추상화가 이루어져 있고 사용자 친화적이다. 똑같이 구글에서 개발한 프레임워크지만 지향하는 철학이 다르다는 점이 재밌다. 책에 따르면 구글에서 개발한 모델들은 대부분 JAX로 작성되어 있고, 심지어 Hugging Face의 기존 모델들도 JAX로 변환하고 있다고 한다. 함수형 프로그래밍 JAX/Flax의 활용 방식을 더 잘 파악할 수 있도록 책은 함수형 프로그래밍에 대해서 별도 챕터로 설명한다. 명령어의 흐름(순서)대로 상태를 변경하고 결과를 전달하는 것이 핵심인 절차적 프로그래밍과 다르게, 함수형 프로그래밍은 외부 상태와 상관없이 주어진 입력에 동일한 출력값을 내놓는 순수 함수를 사용한다. 따라서 부수 효과가 제거되며 상태가 변화하지 않는 불변성을 강조한다. 여기서 절차적 프로그래밍과 함수형 프로그래밍을 설명할 때 간단한 파이썬 예제가 첨부되어 있어서 이해가 편했다. JAX, 나아가 딥러닝 연산에 있어서 이 개념을 이해하는 것이 중요한 이유를 세 가지로 제시하고 있다. XLA 컴파일에 최적화된 처리가 가능해진다 병렬처리와 분산처리에 유용하다 코드를 모듈화함으로써 재사용성이 높아진다 JAX 기본 백문이 불여일견, 직접 JAX 를 활용해보며 책의 내용을 따라가보겠다. 설치 다행히도 JAX가 Mac M1을 공식 지원한다고 하여 conda로 쉽게 설치할 수 있었다. conda create -n jax-env python=3.9 conda activate jax-env pip install jax jaxlib import 하기 import jax import jax.numpy as jnp numpy와 비교 x1 = jnp.array([1.0, 2.0, 3.0]) x2 = jnp.array([4.0, 5.0, 6.0]) y = x1 + x2 print(y) # [5. 7. 9.] print(type(y)) # &lt;class 'jaxlib.xla_extension.ArrayImpl'&gt; 위 예제에서 보듯 jax.numpy는 기존 numpy 와 거의 똑같은 API를 제공하고 있다. grad 함수 def func(x): return x**2 grad = jax.grad(func) print(grad(3.)) # Array(6., dtype=float32, weak_type=True) JAX에서 미분, 즉 gradient를 계산해주는 grad를 사용한 예제다. 부수 효과의 방지 JAX는 부수 효과를 제거하는 함수형 프로그래밍의 제약을 따르고 있다. 책에서 제공해준 아래 예제를 참고해보자. x_1 = np.array([1, 2, 3]) x_1[0] = 999 print(x_1) # [999 2 3] numpy로 생성한 배열은 직접 접근해서 요소를 변경할 수 있다. x_2 = jnp.array([1, 2, 3]) x_2[0] = 999 # TypeError: '&lt;class 'jaxlib.xla_extension.ArrayImpl'&gt;' object does not support item assignment. JAX arrays are immutable. 반면 jax.numpy로 생성한 배열은 직접적인 수정을 허용하지 않는다. 이는 ‘외부 데이터’인 배열의 상태가 변형되면서 부수 효과가 발생하는 것을 방지하기 위함이다. 만약 배열의 일부를 수정하는 작업을 진행하고 싶다면 부수 효과가 없는 순수 함수를 사용해야 한다. x_2 = jnp.array([1, 2, 3]) def modify(x): return x.at[0].set(999) y = modify(x_2) print(y) # Array([999, 2, 3], dtype=int32) 여기서 modify(x)는 부수 효과가 없는 순수 함수라고 볼 수 있는 것이며, 책은 jax.grad와 jax.jit 같은 함수는 순수 함수로 작성되어야 한다고 설명하고 있다. JIT 컴파일 변환 주어진 함수를 변경하거나 수정하는 방식. 성능 최적화나 자동 미분을 가능하게 함. 책은 JAX에서 변환(transformation)이라는 키워드가 중요하다고 말한다. JAX에서 변환은 jaxpr, 즉 JAX 표현식이라는 중간 언어(intermediate language)를 통해 이루어진다. jax.jit가 대표적인 jax 변환이라고 소개된다. def selu(x, alpha=1.67, lamdba_=1.05): return lamdba_ * jnp.where(x &gt; 0, x, alpha * jnp.exp(x) - alpha) x = jnp.arange(1000000) # 일반 selu(x).block_until_ready() # XLA selu_jit = jax.jit(selu) selu_jit(x).block_until_ready() # 비동기 실행 위 내용은 활성화 함수 SELU(Scaled Exponential Linear Unit)를 구현하고 호출한 내용이다. selu(x) 대신에 jit 변환을 적용한 selu_jit(x)가 7배 빠르다고 설명하고 있다. (구글 Colab T4 기준) 책을 읽으면서 흥미로웠던 부분은 jax.jit은 컴파일된 계산 그래프를 캐싱하여 재사용한다는 점이었다. 다만 jax.jit을 반복문 내부에서 호출할 경우 컴파일 과정이 불필요하게 반복될 수 있으니 지양하라고 안내하고 있다. Flax 마지막으로 Flax 를 활용한 예제를 살펴보겠다. import flax.linen as nn from jax import random key = random.PRNGKey(42) class MLP(nn.Module): out_dims: int @nn.compact def __call__(self, x): x = x.reshape((x.shape[0], -1)) x = nn.Dense(128)(x) x = nn.relu(x) x = nn.Dense(self.out_dims)(x) return x model = MLP(out_dims=10) x = jnp.empty((4, 28, 28, 1)) weights = model.init(key, x) y = model.apply(weights, x) 책에 import 하는 부분은 없어서 추가했다 nn.Module 에서 상속받아 모델을 생성한다는 점에서 PyTorch 와 유사한 방식의 API 라고 느껴졌고 금방 적응할 수 있겠다는 생각이 든다. 나가며 『JAX/Flax로 딥러닝 레벨업』에서 JAX 핵심 개념을 위주로 살펴보며 책을 리뷰해보았다. 요즘 시점에서 왜 굳이 새로운 딥러닝 프레임워크가 필요할까? 라고 막연히 궁금해 하며 리뷰어 신청을 했는데, 좋은 기회로 책도 제공 받고 JAX와 Flax에 대해 가볍게 배워볼 수 있는 시간이었다. JAX가 지향하는 철학과 함께 그것이 녹아든 핵심 기능을 세세하게 설명해주기 때문에 JAX 입문서로 아주 알맞은 도서라는 생각이 들었다. 특히 함수형 프로그래밍 개념만을 설명하기 위해 별도 지면을 할애했다는 점에서는 JAX의 의미를 제대로 전달하겠다는 강한 의지도 보였다. 아마 JAX로 입문하기까지 가장 큰 장벽은 앞서 내가 떠올린 것과 같이 “왜 꼭 이것이어야 하는가?” 라는 의문일 텐데, 이 책을 읽는다면 그 장벽 정도는 충분히 넘을 수 있겠다. numpy 하나로 모델을 구현하는 정도로 low-level에서 모델링과 학습 과정 등을 유연하게 통제할 수 있다는 점이 JAX/Flax의 가장 강력한 정체성이라고 느꼈다. 구글 TPU를 사용하는 ML엔지니어라면 시간을 들여서라도 JAX를 적용할 가치가 있을 듯하다. 그 외에 CLIP, GPT 같은 최신 모델의 fine-tuning 을 예제로 다룬 점도 인상적이었다. ML 분야에 입문한 이후로 출판서를 활용해서 공부를 하는 건 정말 오랜만인데, 역시 최신 책이니 최신 모델도 다루는구나 - 싶었다. 다만 책 서문에서 이미 밝혔다시피 딥러닝 개념과 프레임워크에 대한 기본적인 지식이 있어야 책의 내용을 제대로 이해할 수 있다는 점은 염두에 둘 필요가 있겠다. 확실히 ‘초급서’라기보단 ‘입문서’로 보는 게 맞다. 또한 워낙에 고급 프레임워크다보니까 JAX/Flax 자체가 서비스(서빙)보다는 연구에 적합한 도구라는 생각이 들었다. 책 읽기 전과 비슷하게 이것이 이것이 필요할까? 라는 질문은 여전히 깔끔하게 해명되진 않았지만, 책을 읽고 나서 언젠가 JAX를 써보고 싶다는 욕심은 보다 뚜렷해졌다. 리뷰어로 선정하여 도서를 제공해준 출판사 제이펍에 진심으로 감사하다는 말씀을 표하며 본 리뷰를 마무리하겠다.]]></summary></entry><entry><title type="html">📖 『컴퓨터 구조와 운영체제 핵심 노트』(길벗) 리뷰</title><link href="https://woocosmos.github.io/gilbut-ca-os/" rel="alternate" type="text/html" title="📖 『컴퓨터 구조와 운영체제 핵심 노트』(길벗) 리뷰" /><published>2024-09-16T00:00:00+09:00</published><updated>2024-09-16T00:00:00+09:00</updated><id>https://woocosmos.github.io/gilbut-ca-os</id><content type="html" xml:base="https://woocosmos.github.io/gilbut-ca-os/"><![CDATA[<p><img src="https://github.com/user-attachments/assets/61989b8a-92e7-4007-a47e-da9374e74260" alt="image" class="center-image" /></p>

<p><br />
<a href="https://blog.naver.com/gilbutzigy/223556929788">길벗 개발자 리뷰어(25차)</a>에 선정되어 책 『<a href="https://www.gilbut.co.kr/book/view?bookcode=BN004105"><strong>컴퓨터 구조와 운영체제 핵심 노트</strong></a>』를 무료로 제공 받았다.</p>

<dl>
  <dt>도서명</dt>
  <dd>컴퓨터 구조와 운영체제 핵심 노트</dd>
  <dt>지은이</dt>
  <dd>서지영</dd>
  <dt>발행사</dt>
  <dd>(주)도서출판 길벗</dd>
  <dt>초판 발행</dt>
  <dd>2024년 5월 30일</dd>
  <dt>정가</dt>
  <dd>25,000원</dd>
</dl>

<p><br />
출판사 길벗은 이전에 <a href="https://www.gilbut.co.kr/book/view?bookcode=BN004005">모두의 네트워크 기초</a>라는 책으로 접해 익숙하다. 컴퓨터 지식 관련 서적을 많이 출판하기 때문에 전공자, 비전공자를 가리지 않고 공부가 필요한 사람들이 참고하면 좋겠다.</p>

<p>서문에서 밝히듯 이 책은 개념적으로 이해하기 어려운 컴퓨터 구조와 운영체제를 그림을 통해 핵심 위주로 이해하는 것을 목표로 한다. 추천 독자는 아래와 같다.</p>
<ul>
  <li>IT 분야에 입문하려는 사람</li>
  <li>IT 분야 취업을 위해 빠르게 핵심 내용을 익혀야 하는 학생</li>
  <li>IT 분야 취업 후, 컴퓨터/운영체제 지식이 필요한 사람</li>
  <li>컴퓨터 원리를 이해하려는 개발자</li>
</ul>

<hr />

<p>책은 2부에 걸쳐 컴퓨터 구조와 운영체제를 각각 다룬다.</p>

<style>
table th {
    background-color: #f0f0f0; /* 원하는 색상 코드로 변경 */
}

table td:first-child {
    white-space: nowrap; /* 줄바꿈 없애기 */
}
</style>

<table>
  <thead>
    <tr>
      <th style="text-align: center">주제</th>
      <th style="text-align: left">키워드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>컴퓨터 구조</strong></td>
      <td style="text-align: left">데이터 처리, 명령어, CPU, 하드웨어, 캐시 메모리, 보조기억 장치, 입출력 장치, 병렬처리</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>운영체제</strong></td>
      <td style="text-align: left">프로세스, CPU 스케줄링, 교착상태, 메모리 할당, 가상 메모리, 파일 시스템</td>
    </tr>
  </tbody>
</table>

<p><br />
『컴퓨터 구조와 운영체제 핵심 노트』는 이름 그대로 핵심을 깔끔하게 정리해준다.<br />
이를 테면 컴퓨터의 기본 구조(하드웨어)에 대해 책은 아래와 같이 요약한다.</p>

<blockquote>
  <p>CPU, 기억 장치, 입출력 장치가 컴퓨터를 구성하는 기본 구조입니다. 그리고 이들 간 데이터 및 명령어 전달은 시스템 버스가 담당합니다.</p>
</blockquote>

<p><br />
<img src="https://github.com/user-attachments/assets/01e244f5-6b18-46fb-8a1f-f0d425574206" alt="IMG_3188" width="80%" /></p>

<p>중요한 내용은 이렇게 그림으로 표현해 이해에 도움을 준다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/ee294654-484c-40ad-93a5-1dcf2a2a91ba" alt="IMG_3190" width="80%" /></p>

<p>각 구성 요소를 짚은 다음 <u>실제 컴퓨터가 동작하는 원리</u>를 살펴보기 때문에 더욱 개념적으로 와닿았다.<br />
남는 공간에 스스로 이해한 내용을 다시 정리, 작성하면서 공부했다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/3b951e46-1b47-486e-946b-ea08f1b02ef0" alt="IMG_3191" width="80%" /></p>

<p>나의 경우 기본적인 내용일수록 공부하면서 충분히 이해하고 넘어가도 시간이 지나면 자꾸 까먹는 경향이 있다. 정리본을 계속 들추어보는 것도 한계가 있어서 이번 리뷰를 계기로 아예 시험 공부를 하듯 암기를 해두려 한다.<br />
각 챕터 말미에 제공되는 ‘확인 문제’는 이러한 나의 니즈에 딱 맞는다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/c791d107-37af-42e8-a698-e87f1db1f67d" alt="IMG_3192" width="80%" /></p>

<p>그뿐만 아니라 간단하게라도 예제 코드를 포함하고 있어 도움에 이해가 됐다. 그런데 어떤 예제는 C언어로, 어떤 예제는 파이썬으로 적혀 있어 일관성이 떨어지는 점은 아쉽다. 물론 본문에서는 참고용으로만 봐달라고 언급하고 있다.</p>

<hr />

<p>전반적인 개념을 핵심 위주로 정리하는 책이기 때문에 세부 주제를 깊이 있게 탐색하고자 하는 독자라면 다소 아쉬움이 남을 수 있겠다. 『컴퓨터 구조와 운영체제 핵심 노트』는 <u>컴퓨터 과학에 입문하거나 배운 내용을 복습하는 용도</u>로 <strong>적극 추천</strong>한다.</p>

<p>베타 리더 후기 중에서 심화 학습용 도서로 (마찬가지로 올해 길벗에서 출판한) 『<a href="https://www.gilbut.co.kr/book/view?bookcode=BN004024">컴퓨터 밑바닥의 비밀</a>』을 추천하고 있다. 장바구니에 넣어두어야겠다.</p>

<p>개발자 리뷰어로 선정해주시고 도서까지 제공해준 출판사 길벗에 감사의 인사를 전달하며 본 리뷰를 마무리하겠다.</p>]]></content><author><name></name></author><category term="리뷰" /><summary type="html"><![CDATA[길벗 개발자 리뷰어(25차)에 선정되어 책 『컴퓨터 구조와 운영체제 핵심 노트』를 무료로 제공 받았다. 도서명 컴퓨터 구조와 운영체제 핵심 노트 지은이 서지영 발행사 (주)도서출판 길벗 초판 발행 2024년 5월 30일 정가 25,000원 출판사 길벗은 이전에 모두의 네트워크 기초라는 책으로 접해 익숙하다. 컴퓨터 지식 관련 서적을 많이 출판하기 때문에 전공자, 비전공자를 가리지 않고 공부가 필요한 사람들이 참고하면 좋겠다. 서문에서 밝히듯 이 책은 개념적으로 이해하기 어려운 컴퓨터 구조와 운영체제를 그림을 통해 핵심 위주로 이해하는 것을 목표로 한다. 추천 독자는 아래와 같다. IT 분야에 입문하려는 사람 IT 분야 취업을 위해 빠르게 핵심 내용을 익혀야 하는 학생 IT 분야 취업 후, 컴퓨터/운영체제 지식이 필요한 사람 컴퓨터 원리를 이해하려는 개발자 책은 2부에 걸쳐 컴퓨터 구조와 운영체제를 각각 다룬다. 주제 키워드 컴퓨터 구조 데이터 처리, 명령어, CPU, 하드웨어, 캐시 메모리, 보조기억 장치, 입출력 장치, 병렬처리 운영체제 프로세스, CPU 스케줄링, 교착상태, 메모리 할당, 가상 메모리, 파일 시스템 『컴퓨터 구조와 운영체제 핵심 노트』는 이름 그대로 핵심을 깔끔하게 정리해준다. 이를 테면 컴퓨터의 기본 구조(하드웨어)에 대해 책은 아래와 같이 요약한다. CPU, 기억 장치, 입출력 장치가 컴퓨터를 구성하는 기본 구조입니다. 그리고 이들 간 데이터 및 명령어 전달은 시스템 버스가 담당합니다. 중요한 내용은 이렇게 그림으로 표현해 이해에 도움을 준다. 각 구성 요소를 짚은 다음 실제 컴퓨터가 동작하는 원리를 살펴보기 때문에 더욱 개념적으로 와닿았다. 남는 공간에 스스로 이해한 내용을 다시 정리, 작성하면서 공부했다. 나의 경우 기본적인 내용일수록 공부하면서 충분히 이해하고 넘어가도 시간이 지나면 자꾸 까먹는 경향이 있다. 정리본을 계속 들추어보는 것도 한계가 있어서 이번 리뷰를 계기로 아예 시험 공부를 하듯 암기를 해두려 한다. 각 챕터 말미에 제공되는 ‘확인 문제’는 이러한 나의 니즈에 딱 맞는다. 그뿐만 아니라 간단하게라도 예제 코드를 포함하고 있어 도움에 이해가 됐다. 그런데 어떤 예제는 C언어로, 어떤 예제는 파이썬으로 적혀 있어 일관성이 떨어지는 점은 아쉽다. 물론 본문에서는 참고용으로만 봐달라고 언급하고 있다. 전반적인 개념을 핵심 위주로 정리하는 책이기 때문에 세부 주제를 깊이 있게 탐색하고자 하는 독자라면 다소 아쉬움이 남을 수 있겠다. 『컴퓨터 구조와 운영체제 핵심 노트』는 컴퓨터 과학에 입문하거나 배운 내용을 복습하는 용도로 적극 추천한다. 베타 리더 후기 중에서 심화 학습용 도서로 (마찬가지로 올해 길벗에서 출판한) 『컴퓨터 밑바닥의 비밀』을 추천하고 있다. 장바구니에 넣어두어야겠다. 개발자 리뷰어로 선정해주시고 도서까지 제공해준 출판사 길벗에 감사의 인사를 전달하며 본 리뷰를 마무리하겠다.]]></summary></entry><entry><title type="html">GitHub Actions 활용한 태스크 및 배포 자동화</title><link href="https://woocosmos.github.io/github-action/" rel="alternate" type="text/html" title="GitHub Actions 활용한 태스크 및 배포 자동화" /><published>2024-08-30T00:00:00+09:00</published><updated>2024-08-30T00:00:00+09:00</updated><id>https://woocosmos.github.io/github-action</id><content type="html" xml:base="https://woocosmos.github.io/github-action/"><![CDATA[<p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- CI/CD 플랫폼인 GitHub Actions의 기능과 구성 요소를 살펴봤다
- GitHub Actions를 활용하여 특정 스크립트를 작동시키거나 로컬로 빌드한 내용을 배포하는 태스크를 자동화했다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p><a href="https://docs.github.com/ko/actions">GitHub Actions</a>를 사용하여 특정 스크립트를 실행시키고 배포하는 워크플로를 자동화한다.</p>

<p>자동화가 필요한 이유는 두 가지다.</p>

<ol>
  <li>블로그 포스트가 늘어남에 따라 <a href="https://woocosmos.github.io/search-page-dev/#%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%B6%94%EC%B2%9C">추천 키워드의 점수</a>를 새롭게 집계하고 업데이트해야 한다</li>
  <li>로컬에서 사이트를 직접 빌드한 다음에 <a href="http://woocosmos.github.io/blog-history/#gh-pages-%EC%83%9D%EC%84%B1">gh-pages 브랜치</a>에 반영함으로써 배포해야 한다</li>
</ol>

<p>따라서 이번 포스트에서는 태스크의 최신화와 효율화를 위해 GitHub Actions의 워크플로를 구성해보겠다.</p>

<h1 id="github-actions">GitHub Actions</h1>

<p><strong>GitHub Actions</strong>는 빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 <strong>CI/CD 플랫폼</strong>이다.</p>

<blockquote>
  <p>CI/CD : Continuous Integration(지속적 통합) 및 Continuous Delivery/Deployment(지속적 제공/배포). 소프트웨어의 개발 라이프사이클을 효율화, 가속화 하는 DevOps 개념.</p>
</blockquote>

<p><img src="https://github.com/user-attachments/assets/b23f798b-4dc2-4415-a8ff-8eb446c6dce4" alt="image" /></p>

<p>코드 변경에 따라 블로그 콘텐츠를 업데이트한다는 점에서 CI 개념과 연결되고, Jekyll 사이트를 배포한다는 점에서 CD 개념과 연결된다. (<em>정확히 말하자면 CI는 여러 작업자가 commit한 작업을 효율적이고 빠르게 통합함을 목표로 한다</em>)</p>

<p>GitHub Actions는 PR, Push 등 <strong>이벤트</strong>가 발생할 때 <strong>워크플로</strong>를 실행시킬 수 있다. 자체 인프라에서 워크플로를 실행할 수 있지만 GitHub에서도 주요 OS의 가상 머신을 통해 <strong>서버</strong>를 제공하고 있다. 각 구성 요소를 살펴보겠다.</p>

<h2 id="구성-요소">구성 요소</h2>
<p><strong>Workflows(워크플로)</strong><br />
하나 이상의 작업으로 구성된 프로세스. YAML 파일로 정의하며 특정 조건에 따라 트리거 된다. 여러 워크플로를 생성할 수 있고, 한 워크플로 안에서 다른 워크플로를 참조할 수도 있다.</p>

<p><strong>Events(이벤트)</strong><br />
워크플로의 실행을 트리거 하는 활동이다. GitHub Actions 에서 사용할 수 있는 <a href="https://docs.github.com/ko/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows">이벤트의 리스트</a>를 참고하자.</p>

<p><strong>Jobs(작업)</strong><br />
워크플로 안에서 단계로 구성된 집합. 이 단계들은 같은 실행기(runner) 안에서 작동하기 때문에 데이터를 공유할 수 있다. 디폴트로 작업들끼리는 종속성이 없기 때문에 병렬로 실행되나, 한 작업이 다른 작업에 종속된다면 완료를 기다린다.</p>

<p><strong>runner(실행기)</strong><br />
워크플로를 실행하는 서버. 하나의 runner는 한 번에 하나의 작업(job)을 실행할 수 있다.</p>

<h1 id="시작하기">시작하기</h1>

<p>root 경로에서 <code class="language-plaintext highlighter-rouge">.github/workflows</code> 폴더를 생성, 해당 위치에 test.yml 파일을 작성한다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Test</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">post/**'</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">my_first_job</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">step-example</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">echo Hello World!</span>
</code></pre></div></div>

<p>post로 시작하는 브랜치에 push 이벤트가 발생할 때 트리거 되는 워크플로를 정의했다. my_frist_job 이라는 작업이 실행될 텐데, ubuntu 실행기에서 Hello World 를 출력하는 step을 포함하고 있다.</p>

<p>yml 파일을 저장한 후, post/github-actions 브랜치에 push 해보았다. 그 결과는 프로젝트 레포지토리의 Actions 탭에서 확인할 수 있다</p>

<p><img src="https://github.com/user-attachments/assets/c657fa7a-03ce-41ef-85cb-3843bed9b570" alt="image" /></p>

<p>왼쪽 탭에 Test 라는 워크플로가 생성되어 있고 워크플로의 실행 내역이 표시되어 있다. post/github-actions에 push 함으로써 트리거된 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/fa4487ef-855d-4617-a003-15904ba4ed74" alt="image" width="80%" />
<img src="https://github.com/user-attachments/assets/c6b5fc64-481c-4be5-aba8-ae5d34be5d79" alt="image" width="50%" /></p>

<p>my_frist_job 작업이 성공적으로 실행되었고 그것을 눌러 step-example 단계도 실행되었음을 확인할 수 있다. 이제 본격 나의 태스크에 적용해보겠다.</p>

<h2 id="키워드-업데이트">키워드 업데이트</h2>

<p>추천 키워드를 업데이트할 조건을 정한 후, 그에 따른 트리거와 작업 내용을 YAML 파일로 작성했다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Workflow for updating keywords</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">pull_request</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>
    <span class="na">types</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">closed</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">my-job</span><span class="pi">:</span>
    <span class="na">if</span><span class="pi">:</span> <span class="s">(github.event_name == 'pull_request' &amp;&amp;</span>
            <span class="s">github.event.pull_request.merged == </span><span class="kc">true</span><span class="s"> &amp;&amp;</span> 
            <span class="s">startsWith(github.event.pull_request.head.ref, 'post/')) ||</span>
        <span class="s">(github.event_name == 'push' &amp;&amp;</span>
            <span class="s">contains(github.event.head_commit.message, 'post'))</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Approach the Codes</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Python</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-python@v5</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">python-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>
          <span class="na">cache</span><span class="pi">:</span> <span class="s1">'</span><span class="s">pip'</span>
          
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install Ubuntu Dependencies</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">sudo apt-get update</span>
          <span class="s">sudo apt-get install -y g++ openjdk-8-jdk</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install Python Dependencies</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">python -m pip install -r $/requirements.txt</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Run the Script</span>
        <span class="na">run</span><span class="pi">:</span>
          <span class="s">python $/assets/recommend.py</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure Git</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">git config --global user.name "${GITHUB_ACTOR}"</span>
          <span class="s">git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Check for Differences</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">check_diff</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">git add $/keywords.json</span>
          <span class="s">if git diff --cached --quiet; then</span>
            <span class="s">echo "No changes detected"</span>
            <span class="s">echo "has_changes=false" &gt;&gt; $GITHUB_OUTPUT</span>
          <span class="s">else</span>
            <span class="s">echo "has_changes=true" &gt;&gt; $GITHUB_OUTPUT</span>
          <span class="s">fi</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Commit the Change</span>
        <span class="na">if</span><span class="pi">:</span> <span class="s">steps.check_diff.outputs.has_changes == 'true'</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">echo "pushing the file ..."</span>
          <span class="s">git commit -m "[automation] keywords updated"</span>
          <span class="s">git push</span>
</code></pre></div></div>

<p>워크플로가 트리거 되는 조건은 아래와 같다.</p>

<ul>
  <li>post로 시작하는 브랜치의 PR를 완료했을 때 (보통 post 브랜치에서 포스트를 작성한 후 완성했을 때 master로 merge시키기 때문)</li>
  <li>push 의 커밋 메세지에 ‘post’가 포함되어 있을 때 (master 브랜치에서 바로 수정하여 push할 때도 있으므로)</li>
</ul>

<p>‘my-job’ 작업은 환경을 세팅하고(1~4번) 스크립트를 실행시키고(5번) 변경 사항을 git push 하는(6~8번) 일련의 단계들을 포함하고 있다.</p>

<hr />
<ol>
  <li>Approach the Codes</li>
  <li>Set up Python
    <ul>
      <li><code class="language-plaintext highlighter-rouge">actions/setup-python@v5</code> : GitHub Actions에서 제공하는 파이썬 환경이다</li>
      <li><code class="language-plaintext highlighter-rouge">cache: 'pip'</code> : GitHub Actions는 <a href="https://docs.github.com/ko/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows"><strong>캐싱 기능</strong></a>을 제공하는데, 이 옵션을 명시해주면 pip 캐시를 복원하여 활용하고 캐시가 없을 경우 새로 설치한다</li>
    </ul>
  </li>
  <li>Install Ubuntu Dependencies</li>
  <li>Install Python Dependencies
    <ul>
      <li>프로젝트의 root 경로는 <code class="language-plaintext highlighter-rouge">${{ github.workspace }}</code>라는 변수로 접근할 수 있다</li>
    </ul>
  </li>
  <li>Run the Script</li>
  <li>Configure Git</li>
  <li>Check for Differences
    <ul>
      <li><code class="language-plaintext highlighter-rouge">keywords.json</code> 파일만 stage 에 올리고 변경사항이 있는지 확인한다. 이 부분을 추가하지 않으면 nothing to commit 에러가 발생하며 워크플로가 중단된다.</li>
      <li>이 플래그는 <code class="language-plaintext highlighter-rouge">has_changes</code>라는 변수에 저장되어 다음 step에서 사용된다</li>
    </ul>
  </li>
  <li>Commit the Change
    <ul>
      <li>앞선 단계에서 선언한 <code class="language-plaintext highlighter-rouge">has_changes</code>으로 if 조건을 명시하고, 앞서 stage에 올린 파일을 리모트에 반영한다<br />
<b></b></li>
    </ul>
  </li>
</ol>

<p>참고로 konlpy 를 사용하는 만큼 환경 구축이 까다로울 것 같아서, docker로 ubuntu 컨테이너를 하나 띄워서 시뮬레이션 했다. 나중의 활용을 위해 여기에 커맨드를 정리해둔다.<br />
volume binding 하지 않고 docker cp 명령어로 파이썬 파일을 복제해 썼다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-d</span> <span class="nt">--name</span> fake-github-actions ubuntu:latest <span class="nb">tail</span> <span class="nt">-f</span> /dev/null
docker <span class="nb">cp</span> /path/to/recommend.py fake-github-actions:/root/recommend.py
docker <span class="nb">exec </span>it fake-github-actions /bin/bash
<span class="c"># 파이썬 설치 후 Ubuntu, python 의 어떤 dependencies가 필요한지 테스트</span>
</code></pre></div></div>

<p>흥미로운 지점은 <strong><code class="language-plaintext highlighter-rouge">cache: 'pip'</code>를 사용하지 않았을 때 실행시간이 더 짧았다</strong>는 점인데, pip로 설치하는 패키지의 개수가 많지 않아 오히려 <strong>캐시를 복원해오는 데 시간이 더 소요</strong>되는 것으로 보인다. 이는 전체 시스템 디렉토리를 캐싱해야 하는 Ubuntu 패키지에 대해서도 마찬가지다. 따라서 최종 코드에서는 해당 옵션을 <u>제외</u>했다.</p>

<h2 id="배포-자동화">배포 자동화</h2>

<p>배포는 <a href="https://github.com/jeffreytse/jekyll-deploy-action">JEKYLL DEPLOY ACTION</a>이라는 액션을 사용했다. 개발 스토리를 살펴보면,</p>

<blockquote>
  <p>GitHub Pages는 <em>허용된 플러그인</em>만 <em>안전 모드</em> 상에서 실행해주기 때문에, 커스텀 플러그인을 사용하는 경우 로컬에서 직접 빌드하고 gh-pages로 배포해야 할 때가 있다.</p>
</blockquote>

<p><a href="https://woocosmos.github.io/blog-history/#gh-pages-%EC%83%9D%EC%84%B1">나의 니즈</a>에 딱 맞는 action이라 바로 사용해보기로 했다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Build and Deploy to Github Pages</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build_and_deploy</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>

      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/cache@v4</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">.asdf/**</span>
            <span class="s">vendor/bundle</span>
          <span class="na">key</span><span class="pi">:</span> <span class="s">${{ runner.os }}-cache-${{ hashFiles('**/cache.key') }}</span>
          <span class="na">restore-keys</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">${{ runner.os }}-cache-</span>

      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">jeffreytse/jekyll-deploy-action@v0.6.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">provider</span><span class="pi">:</span> <span class="s1">'</span><span class="s">github'</span>         
          <span class="na">token</span><span class="pi">:</span> <span class="s">${{ secrets.GITHUB_TOKEN }}</span> 
          <span class="na">branch</span><span class="pi">:</span> <span class="s1">'</span><span class="s">gh-pages'</span>         
          <span class="na">jekyll_src</span><span class="pi">:</span> <span class="s1">'</span><span class="s">./'</span>    
      
</code></pre></div></div>

<p>이미 <code class="language-plaintext highlighter-rouge">gh-pages</code> 브랜치를 만들어 배포에 사용하고 있었기 때문에 수정 없이 그대로 적용할 수 있었다. 이 워크플로를 통해 jeykll 환경을 구성, master를 기준으로 build하고 <code class="language-plaintext highlighter-rouge">gh-pages</code> 에 반영하는 과정을 자동화했다. master 브랜치로 push 이벤트가 발생할 때마다 자동으로 배포가 되는 셈이다.</p>

<p><em>+ 2024-09-16 업데이트</em></p>

<p>2주 만에 블로그를 업데이트하고 master로 push 했더니 <strong>error: RPC failed; HTTP 400 curl 92 HTTP/2 stream 7 was not closed cleanly: CANCEL (err 8)</strong> 라는 에러와 함께 배포에 실패했다. <a href="https://github.com/jeffreytse/jekyll-deploy-action/issues/81">이슈 채널에 동일한 에러를 호소하는 사람</a>이 있었다. 답변에서 안내해주는 대로 SSH 옵션을 추가했다.</p>

<blockquote>
  <p>Note: SSH approach has higher priority than HTTP approach when you provide both at the same time.</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">jeffreytse/jekyll-deploy-action@v0.6.0</span>
  <span class="na">with</span><span class="pi">:</span>
  <span class="s">...</span>
  <span class="na">ssh_private_key</span><span class="pi">:</span> <span class="s">$</span>
  <span class="s">...</span>
</code></pre></div></div>

<p>하지만 마찬가지로 에러가 발생해서 <code class="language-plaintext highlighter-rouge">jekyll-deploy-action</code>의 버전을 master로 바꾸어보았다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">jeffreytse/jekyll-deploy-action@master</span>
</code></pre></div></div>

<p>배포에 성공했다. master 브랜치에 관련 에러가 이제 막 반영된 모양이다. (심지어 지금 시간 기준 50분 전에 올라온 <a href="https://github.com/jeffreytse/jekyll-deploy-action/issues/89">동일한 이슈</a>도 있다..)</p>

<h1 id="나가며">나가며</h1>

<p>이로써 GitHub Actions를 활용하여 매우 간편하게 CI/CD를 자동화해보았다. 액션의 yaml 파일을 구성하는 과정이 docker-compose.yml 를 작성하는 것과 유사해서 금방 해낼 수 있었던 것 같다.<br />
이번 경험은 cache를 재사용하는 것이 무조건 빠르다는 선입견을 깨게 된 계기가 되기도 했다.</p>

<p>실무 환경에서 CI/CD 작업을 처리할 때 Jenkins(젠킨스)도 많이 활용하는 것으로 알고 있다. 실제로 내가 속한 조직에서 ML모델 추론과 웹 서버 호스팅을 Jenkins으로 관리하기도 했다. 기회가 된다면 다음에는 Jenkins도 써보고 싶다.</p>]]></content><author><name></name></author><category term="DevOps" /><summary type="html"><![CDATA[요약 - CI/CD 플랫폼인 GitHub Actions의 기능과 구성 요소를 살펴봤다 - GitHub Actions를 활용하여 특정 스크립트를 작동시키거나 로컬로 빌드한 내용을 배포하는 태스크를 자동화했다 개요 GitHub Actions를 사용하여 특정 스크립트를 실행시키고 배포하는 워크플로를 자동화한다. 자동화가 필요한 이유는 두 가지다. 블로그 포스트가 늘어남에 따라 추천 키워드의 점수를 새롭게 집계하고 업데이트해야 한다 로컬에서 사이트를 직접 빌드한 다음에 gh-pages 브랜치에 반영함으로써 배포해야 한다 따라서 이번 포스트에서는 태스크의 최신화와 효율화를 위해 GitHub Actions의 워크플로를 구성해보겠다. GitHub Actions GitHub Actions는 빌드, 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼이다. CI/CD : Continuous Integration(지속적 통합) 및 Continuous Delivery/Deployment(지속적 제공/배포). 소프트웨어의 개발 라이프사이클을 효율화, 가속화 하는 DevOps 개념. 코드 변경에 따라 블로그 콘텐츠를 업데이트한다는 점에서 CI 개념과 연결되고, Jekyll 사이트를 배포한다는 점에서 CD 개념과 연결된다. (정확히 말하자면 CI는 여러 작업자가 commit한 작업을 효율적이고 빠르게 통합함을 목표로 한다) GitHub Actions는 PR, Push 등 이벤트가 발생할 때 워크플로를 실행시킬 수 있다. 자체 인프라에서 워크플로를 실행할 수 있지만 GitHub에서도 주요 OS의 가상 머신을 통해 서버를 제공하고 있다. 각 구성 요소를 살펴보겠다. 구성 요소 Workflows(워크플로) 하나 이상의 작업으로 구성된 프로세스. YAML 파일로 정의하며 특정 조건에 따라 트리거 된다. 여러 워크플로를 생성할 수 있고, 한 워크플로 안에서 다른 워크플로를 참조할 수도 있다. Events(이벤트) 워크플로의 실행을 트리거 하는 활동이다. GitHub Actions 에서 사용할 수 있는 이벤트의 리스트를 참고하자. Jobs(작업) 워크플로 안에서 단계로 구성된 집합. 이 단계들은 같은 실행기(runner) 안에서 작동하기 때문에 데이터를 공유할 수 있다. 디폴트로 작업들끼리는 종속성이 없기 때문에 병렬로 실행되나, 한 작업이 다른 작업에 종속된다면 완료를 기다린다. runner(실행기) 워크플로를 실행하는 서버. 하나의 runner는 한 번에 하나의 작업(job)을 실행할 수 있다. 시작하기 root 경로에서 .github/workflows 폴더를 생성, 해당 위치에 test.yml 파일을 작성한다. name: Test on: push: branches: - 'post/**' jobs: my_first_job: runs-on: ubuntu-latest steps: - name: step-example run: echo Hello World! post로 시작하는 브랜치에 push 이벤트가 발생할 때 트리거 되는 워크플로를 정의했다. my_frist_job 이라는 작업이 실행될 텐데, ubuntu 실행기에서 Hello World 를 출력하는 step을 포함하고 있다. yml 파일을 저장한 후, post/github-actions 브랜치에 push 해보았다. 그 결과는 프로젝트 레포지토리의 Actions 탭에서 확인할 수 있다 왼쪽 탭에 Test 라는 워크플로가 생성되어 있고 워크플로의 실행 내역이 표시되어 있다. post/github-actions에 push 함으로써 트리거된 것이다. my_frist_job 작업이 성공적으로 실행되었고 그것을 눌러 step-example 단계도 실행되었음을 확인할 수 있다. 이제 본격 나의 태스크에 적용해보겠다. 키워드 업데이트 추천 키워드를 업데이트할 조건을 정한 후, 그에 따른 트리거와 작업 내용을 YAML 파일로 작성했다. name: Workflow for updating keywords on: pull_request: branches: - master types: - closed push: branches: - master jobs: my-job: if: (github.event_name == 'pull_request' &amp;&amp; github.event.pull_request.merged == true &amp;&amp; startsWith(github.event.pull_request.head.ref, 'post/')) || (github.event_name == 'push' &amp;&amp; contains(github.event.head_commit.message, 'post')) runs-on: ubuntu-latest steps: - name: Approach the Codes uses: actions/checkout@v3 - name: Set up Python uses: actions/setup-python@v5 with: python-version: '3.8' cache: 'pip' - name: Install Ubuntu Dependencies run: | sudo apt-get update sudo apt-get install -y g++ openjdk-8-jdk - name: Install Python Dependencies run: | python -m pip install -r $/requirements.txt - name: Run the Script run: python $/assets/recommend.py - name: Configure Git run: | git config --global user.name "${GITHUB_ACTOR}" git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com" - name: Check for Differences id: check_diff run: | git add $/keywords.json if git diff --cached --quiet; then echo "No changes detected" echo "has_changes=false" &gt;&gt; $GITHUB_OUTPUT else echo "has_changes=true" &gt;&gt; $GITHUB_OUTPUT fi - name: Commit the Change if: steps.check_diff.outputs.has_changes == 'true' run: | echo "pushing the file ..." git commit -m "[automation] keywords updated" git push 워크플로가 트리거 되는 조건은 아래와 같다. post로 시작하는 브랜치의 PR를 완료했을 때 (보통 post 브랜치에서 포스트를 작성한 후 완성했을 때 master로 merge시키기 때문) push 의 커밋 메세지에 ‘post’가 포함되어 있을 때 (master 브랜치에서 바로 수정하여 push할 때도 있으므로) ‘my-job’ 작업은 환경을 세팅하고(1~4번) 스크립트를 실행시키고(5번) 변경 사항을 git push 하는(6~8번) 일련의 단계들을 포함하고 있다. Approach the Codes Set up Python actions/setup-python@v5 : GitHub Actions에서 제공하는 파이썬 환경이다 cache: 'pip' : GitHub Actions는 캐싱 기능을 제공하는데, 이 옵션을 명시해주면 pip 캐시를 복원하여 활용하고 캐시가 없을 경우 새로 설치한다 Install Ubuntu Dependencies Install Python Dependencies 프로젝트의 root 경로는 ${{ github.workspace }}라는 변수로 접근할 수 있다 Run the Script Configure Git Check for Differences keywords.json 파일만 stage 에 올리고 변경사항이 있는지 확인한다. 이 부분을 추가하지 않으면 nothing to commit 에러가 발생하며 워크플로가 중단된다. 이 플래그는 has_changes라는 변수에 저장되어 다음 step에서 사용된다 Commit the Change 앞선 단계에서 선언한 has_changes으로 if 조건을 명시하고, 앞서 stage에 올린 파일을 리모트에 반영한다 참고로 konlpy 를 사용하는 만큼 환경 구축이 까다로울 것 같아서, docker로 ubuntu 컨테이너를 하나 띄워서 시뮬레이션 했다. 나중의 활용을 위해 여기에 커맨드를 정리해둔다. volume binding 하지 않고 docker cp 명령어로 파이썬 파일을 복제해 썼다. docker run --rm -d --name fake-github-actions ubuntu:latest tail -f /dev/null docker cp /path/to/recommend.py fake-github-actions:/root/recommend.py docker exec it fake-github-actions /bin/bash # 파이썬 설치 후 Ubuntu, python 의 어떤 dependencies가 필요한지 테스트 흥미로운 지점은 cache: 'pip'를 사용하지 않았을 때 실행시간이 더 짧았다는 점인데, pip로 설치하는 패키지의 개수가 많지 않아 오히려 캐시를 복원해오는 데 시간이 더 소요되는 것으로 보인다. 이는 전체 시스템 디렉토리를 캐싱해야 하는 Ubuntu 패키지에 대해서도 마찬가지다. 따라서 최종 코드에서는 해당 옵션을 제외했다. 배포 자동화 배포는 JEKYLL DEPLOY ACTION이라는 액션을 사용했다. 개발 스토리를 살펴보면, GitHub Pages는 허용된 플러그인만 안전 모드 상에서 실행해주기 때문에, 커스텀 플러그인을 사용하는 경우 로컬에서 직접 빌드하고 gh-pages로 배포해야 할 때가 있다. 나의 니즈에 딱 맞는 action이라 바로 사용해보기로 했다. name: Build and Deploy to Github Pages on: push: branches: - master jobs: build_and_deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/cache@v4 with: path: | .asdf/** vendor/bundle key: ${{ runner.os }}-cache-${{ hashFiles('**/cache.key') }} restore-keys: | ${{ runner.os }}-cache- - uses: jeffreytse/jekyll-deploy-action@v0.6.0 with: provider: 'github' token: ${{ secrets.GITHUB_TOKEN }} branch: 'gh-pages' jekyll_src: './' 이미 gh-pages 브랜치를 만들어 배포에 사용하고 있었기 때문에 수정 없이 그대로 적용할 수 있었다. 이 워크플로를 통해 jeykll 환경을 구성, master를 기준으로 build하고 gh-pages 에 반영하는 과정을 자동화했다. master 브랜치로 push 이벤트가 발생할 때마다 자동으로 배포가 되는 셈이다. + 2024-09-16 업데이트 2주 만에 블로그를 업데이트하고 master로 push 했더니 error: RPC failed; HTTP 400 curl 92 HTTP/2 stream 7 was not closed cleanly: CANCEL (err 8) 라는 에러와 함께 배포에 실패했다. 이슈 채널에 동일한 에러를 호소하는 사람이 있었다. 답변에서 안내해주는 대로 SSH 옵션을 추가했다. Note: SSH approach has higher priority than HTTP approach when you provide both at the same time. - uses: jeffreytse/jekyll-deploy-action@v0.6.0 with: ... ssh_private_key: $ ... 하지만 마찬가지로 에러가 발생해서 jekyll-deploy-action의 버전을 master로 바꾸어보았다. - uses: jeffreytse/jekyll-deploy-action@master 배포에 성공했다. master 브랜치에 관련 에러가 이제 막 반영된 모양이다. (심지어 지금 시간 기준 50분 전에 올라온 동일한 이슈도 있다..) 나가며 이로써 GitHub Actions를 활용하여 매우 간편하게 CI/CD를 자동화해보았다. 액션의 yaml 파일을 구성하는 과정이 docker-compose.yml 를 작성하는 것과 유사해서 금방 해낼 수 있었던 것 같다. 이번 경험은 cache를 재사용하는 것이 무조건 빠르다는 선입견을 깨게 된 계기가 되기도 했다. 실무 환경에서 CI/CD 작업을 처리할 때 Jenkins(젠킨스)도 많이 활용하는 것으로 알고 있다. 실제로 내가 속한 조직에서 ML모델 추론과 웹 서버 호스팅을 Jenkins으로 관리하기도 했다. 기회가 된다면 다음에는 Jenkins도 써보고 싶다.]]></summary></entry><entry><title type="html">블로그 키워드 추천 및 검색 기능 구현기</title><link href="https://woocosmos.github.io/search-page-dev/" rel="alternate" type="text/html" title="블로그 키워드 추천 및 검색 기능 구현기" /><published>2024-08-26T00:00:00+09:00</published><updated>2024-08-26T00:00:00+09:00</updated><id>https://woocosmos.github.io/search-page-dev</id><content type="html" xml:base="https://woocosmos.github.io/search-page-dev/"><![CDATA[<p><strong>요약</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- simple-jekyll-search 라이브러리를 활용하여 검색 기능을 추가했다
- 탭에서 접근할 수 있는 검색 페이지를 구성하고 검색 결과를 적절하게 시각화했다
- TF-IDF 값을 활용하여 검색할 키워드를 추천했다
</code></pre></div></div>

<h1 id="개요">개요</h1>

<p><a href="https://github.com/aweekj/kiko-now">Kiko Now</a> Jekyll 테마에 검색 기능이 없는 관계로 <strong>직접 검색 페이지를 구성하고 JS 라이브러리로 검색 기능을 적용</strong>했다. 블로그에 포스트가 쌓일수록 검색 기능이 필수적이라고 생각했다. 태그 기반의 문서 분류 방식은 한계가 명확하고, 특정 문서를 찾을 때도 검색이 가장 간편하기 때문이다.</p>

<p>블로그 개발 과정은 <a href="https://woocosmos.github.io/blog-history/">특정 포스트</a>에 아카이빙하고 있지만, 해당 기능은 분량이 많아 별도로 기록한다.</p>

<h1 id="기본-기능">기본 기능</h1>
<p>입력 키워드로 블로그 내 모든 컨텐츠에 대해 검색하는 기본 기능부터 적용한다.</p>

<p><a href="https://github.com/christian-fei/Simple-Jekyll-Search"><strong>Simple-Jekyll-Search</strong></a> 라이브러리를 적용했다. 브라우저 단[Client-Side]에서 작동하기 때문에 별도 서버나 DB를 구축할 필요가 없다. 적용 과정 역시 간단하다.</p>

<h3 class="no_toc"> 첫째, search.json 생성 </h3>

<p>블로그의 root 위치에 아래 <code class="language-plaintext highlighter-rouge">search.json</code> 파일을 만든다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">---</span><span class="w">
</span><span class="err">layout:</span><span class="w"> </span><span class="err">none</span><span class="w">
</span><span class="err">---</span><span class="w">
</span><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">post</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">site.posts</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"title"</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.title | escape }}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"tags"</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.tags | join: ', ' }}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"date"</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.date | date: '%Y.%m.%d'}}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"url"</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ site.url }}{{ post.url }}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{{ post.content | strip_html | strip_newlines | escape }}"</span><span class="w">
    </span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">unless</span><span class="w"> </span><span class="err">forloop.last</span><span class="w"> </span><span class="err">%</span><span class="p">},{</span><span class="err">%</span><span class="w"> </span><span class="err">endunless</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
  </span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">endfor</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>
<p>기존 코드에 <code class="language-plaintext highlighter-rouge">post.content</code> 를 추가하여 본문 텍스트도 가져오게 했다. 이때 <code class="language-plaintext highlighter-rouge">strip_html</code> 등 몇 가지 Jekyll 문법을 더했다. 이를 통해 <code class="language-plaintext highlighter-rouge">{baseurl}/search.json</code> 주소로 json 파일에 접근할 수 있다. 브라우저로부터 이 파일을 읽어와 검색 데이터로 활용할 것이다.</p>

<p><img src="https://github.com/user-attachments/assets/e2a40f6a-eaea-465f-ab02-42408c060258" alt="image" style="border:black solid 0.5px; padding:10px; width:50%;" class="center-image" />
<br /></p>

<h3 class="no_toc"> 둘째, JavaSript 소스 추가 </h3>

<p><a href="https://github.com/christian-fei/Simple-Jekyll-Search/blob/master/example/js/simple-jekyll-search.js">simple-jekyll-search.js</a>를 다운 받아 어디든 위치시킨다. 이 스크립트는 <strong><code class="language-plaintext highlighter-rouge">search.json</code>으로부터 데이터를 읽어와 입력어에 매칭되는 내용을 찾는</strong> 함수 <code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code>를 정의하고 있다.</p>

<p>그 다음 <a href="https://github.com/woocosmos/woocosmos.github.io/blob/master/assets/search-and-return.js">search-and-return.js</a>도 다운 받아 같은 위치에 붙여넣는다. <strong><code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code> 함수를 실행시켜서 결과값을 받아와 처리하는</strong> 부분을 별도 스크립트로 작성한 것이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">sjs</span> <span class="o">=</span> <span class="nc">SimpleJekyllSearch</span><span class="p">({</span>
    <span class="na">searchInput</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">search-input</span><span class="dl">'</span><span class="p">),</span>
    <span class="na">resultsContainer</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">results-container</span><span class="dl">'</span><span class="p">),</span>
    <span class="na">json</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/search.json</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">searchResultTemplate</span><span class="p">:</span> <span class="p">...</span>
    <span class="na">noResultsText</span><span class="p">:</span> <span class="dl">'</span><span class="s1">😴 검색 결과가 없습니다</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">templateMiddleware</span> <span class="p">:</span> <span class="p">...</span>
<span class="p">)}</span>
</code></pre></div></div>

<p>나는 assets 라는 폴더를 만들어 이곳에 JS 소스를 모아두기로 했다. 두 스크립트는 다음 서술할 검색 페이지에서 실행시킬 것이다.</p>

<h3 class="no_toc"> 셋째, 검색 페이지 구성 </h3>

<p>root 위치에 <code class="language-plaintext highlighter-rouge">search</code> 폴더를 생성하고 그 아래 <code class="language-plaintext highlighter-rouge">index.html</code> 파일을 생성한다. 앞서 추가한 JS 스크립트가 실행되면서 검색어 입출력이 진행되는 곳이다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: page
permalink: /search
---

<span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"search"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"search-container"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"search"</span> <span class="na">id=</span><span class="s">"search-input"</span> <span class="na">placeholder=</span><span class="s">"  🤔 검색어를 입력하세요."</span><span class="nt">&gt;</span>
        <span class="nt">&lt;ul</span> <span class="na">id=</span><span class="s">"results-container"</span><span class="nt">&gt;&lt;/ul&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/ul&gt;</span>

<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ site.baseurl }}/assets/simple-jekyll-search.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"{{ site.baseurl }}/assets/search-and-return.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>이렇게 <code class="language-plaintext highlighter-rouge">{baseurl}/search</code> 주소로 접근할 수 있는 검색 페이지를 완성하였다.</p>

<p><img src="https://github.com/user-attachments/assets/a3b2710e-95b2-43d8-b4b7-cdb3375e2625" alt="image" style="border:black solid 0.5px; padding:10px;" class="center-image" /></p>

<p>한편, 무엇을 클릭했을 때 이 검색 페이지로 연결되도록 할 것인가? 나는 상단의 탭에 <strong>돋보기 아이콘</strong>을 추가했다. 이를 위해 돋보기 아이콘 svg와 검색 페이지를  연결하여 <code class="language-plaintext highlighter-rouge">_includes/nav.html</code>에 추가했다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">"search-icon"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"{{ site.baseurl }}/search"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;svg</span> 
      <span class="na">width=</span><span class="s">"24"</span> 
      <span class="na">height=</span><span class="s">"24"</span> 
      <span class="na">viewBox=</span><span class="s">"0 0 24 24"</span> 
      <span class="na">fill=</span><span class="s">"none"</span> 
      <span class="na">xmlns=</span><span class="s">"http://www.w3.org/2000/svg"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;path</span> <span class="na">d=</span><span class="s">"M10 ...생략"</span> <span class="na">fill=</span><span class="s">"currentColor"</span><span class="nt">&gt;&lt;/path&gt;</span>
    <span class="nt">&lt;/svg&gt;</span>
  <span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div></div>

<p><img src="https://github.com/user-attachments/assets/96ec0aaf-0692-4da4-b390-313138b53ad0" alt="image" style="border:black solid 0.5px; padding:10px;" class="center-image" /></p>

<p>이렇게 검색 페이지를 구성하고 검색용 라이브러리를 적용하는 과정을 마무리하였다.</p>

<h1 id="응용-기능">응용 기능</h1>
<p>기본 검색 기능에 더하여 키워드를 더 쉽게 찾고 검색 결과를 더 잘 표현하기 위해 개선한 사항이다.</p>

<h2 id="결과창-개선">결과창 개선</h2>

<p><img src="https://github.com/user-attachments/assets/2759e44c-1170-4c49-9e1a-297d646a8354" alt="image" style="border:black solid 0.5px; padding:10px;" /></p>

<p>이미지에 보듯 결과창에 추가한 내용은 다음과 같다.</p>

<ol>
  <li>검색어 하이라이트</li>
  <li>클릭시 본문 및 태그 페이지로 링크 연결</li>
  <li>본문 미리보기</li>
  <li>검색어가 언급된 횟수 표시</li>
  <li>아이콘과 함께 메타 정보 디스플레이
<br /></li>
</ol>

<p>이를 위해 <code class="language-plaintext highlighter-rouge">SimpleJekyllSearch</code> 함수의 <code class="language-plaintext highlighter-rouge">templateMiddleware</code>와 <code class="language-plaintext highlighter-rouge">searchResultTemplate</code> 인자를 활용할 것이다. 전자는 검색 결과가 있을 때 호출되는 함수이며 후자는 그 결과를 출력할 HTML 템플릿을 지정하는 인자다. 하나씩 짚어보도록 하겠다.<br />
<br /></p>

<p><code class="language-plaintext highlighter-rouge">templateMiddleware</code> 인자는 다음과 같이 정의된 함수를 필요로 한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">function </span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">template</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">prop</code>은 json의 key이고 <code class="language-plaintext highlighter-rouge">value</code>는 key에 대한 value를 의미한다. 이제 <code class="language-plaintext highlighter-rouge">prop</code>, 즉 ‘항목’에 따라 <code class="language-plaintext highlighter-rouge">value</code>를 처리할 것이다.</p>

<p><strong>URL</strong>과 <strong>날짜</strong> 항목은 json에 저장된 그대로 사용할 예정이기 때문에 바로 <code class="language-plaintext highlighter-rouge">value</code>를 반환하도록 했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">url</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">prop</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">date</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>나머지 <strong>제목, 태그, 본문</strong> 항목은 검색어 하이라이트를 적용하고 URL과 연결하는 작업이 필요하다.<br />
우선 검색어를 저장하고, 그것을 찾는 정규표현식 객체와 최종적으로 리턴될 변수를 선언한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">searchTerm</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">search-input</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RegExp</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">,</span> <span class="dl">"</span><span class="s2">gi</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">highlightedValue</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>제목</strong> 항목은 정규표현식 객체로 검색어(<code class="language-plaintext highlighter-rouge">$&amp;</code>)를 HTML 태그로 감싼다. 배경색깔을 바꾸고 폰트를 굵게 표시한다.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">title</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">highlightedValue</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="nx">regex</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;</span><span class="dl">'</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">highlightedValue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>태그</strong> 항목의 경우 <a href="https://woocosmos.github.io/tags/">태그 페이지</a>의 각 태그 링크와 연동했다.<br />
앞서 json을 생성하면서 쉼표로 join 했기 때문에 split하고 join하는 과정을 한번 더 거치는데, search.json을 개선해서 전처리를 간소화하는 대안도 고민해봐야겠다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span><span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">tags</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dest</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">origin</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">theTags</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="nx">tag</span> <span class="o">=&gt;</span> <span class="nx">tag</span><span class="p">.</span><span class="nf">trim</span><span class="p">());</span>
    
    <span class="nx">highlightedLinkedValue</span> <span class="o">=</span> <span class="nx">theTags</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">tag</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 하이라이트를 적용한다</span>
      <span class="kd">const</span> <span class="nx">highlightedTag</span> <span class="o">=</span> <span class="nx">tag</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="nx">regex</span><span class="p">,</span> <span class="dl">'</span><span class="s1">&lt;b style="background:gold"&gt;$&amp;&lt;/b&gt;</span><span class="dl">'</span><span class="p">);</span>
      <span class="c1">// 링크를 적용한다</span>
      <span class="k">return</span> <span class="s2">`&lt;a href="</span><span class="p">${</span><span class="nx">dest</span><span class="p">}</span><span class="s2">/tags/#</span><span class="p">${</span><span class="nx">tag</span><span class="p">}</span><span class="s2">"&gt;&lt;span&gt;</span><span class="p">${</span><span class="nx">highlightedTag</span><span class="p">}</span><span class="s2">&lt;/span&gt;&lt;/a&gt;`</span><span class="p">;</span>
    <span class="p">}).</span><span class="nf">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="nx">highlightedLinkedValue</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>마지막으로 <strong>본문</strong>을 보여주는 데 있어 두 가지 지점을 고려했다. 첫번째는 30개 단어까지 미리보기로 보여주는 것이고 두번째는 본문에서 match가 걸린 횟수를 명시하는 것이다.</p>

<p>첫번째 매치를 기준으로 앞뒤 15개 단어까지 슬라이스하였다. 본문에 매치가 없을 경우 처음부터 30개 단어를 가져온다. 마지막으로는 정규표현식 객체에 매치된 <code class="language-plaintext highlighter-rouge">matches</code>의 개수를 명시했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">\[</span><span class="sr">.*</span><span class="se">?\]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">matches</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="nx">regex</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">matchCnt</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">matches</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 띄어쓰기를 기준으로 토큰화한다</span>
    <span class="kd">const</span> <span class="nx">wordsArray</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">);</span>

    <span class="c1">// 검색된 단어를 기준으로 앞뒤 15개 토큰을 사용한다</span>
    <span class="kd">const</span> <span class="nx">matchIndex</span> <span class="o">=</span> <span class="nx">wordsArray</span><span class="p">.</span><span class="nf">findIndex</span><span class="p">(</span><span class="nx">word</span> <span class="o">=&gt;</span> <span class="nx">regex</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">word</span><span class="p">));</span>
    <span class="kd">const</span> <span class="nx">start</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">matchIndex</span> <span class="o">-</span> <span class="mi">15</span><span class="p">);</span> 
    <span class="kd">const</span> <span class="nx">end</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">wordsArray</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">matchIndex</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="kd">const</span> <span class="nx">truncatedValue</span> <span class="o">=</span> <span class="nx">wordsArray</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>

    <span class="c1">// 하이라이트를 적용한다</span>
    <span class="nx">highlightedValue</span> <span class="o">=</span> <span class="nx">truncatedValue</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span>
        <span class="nx">regex</span><span class="p">,</span>
        <span class="dl">'</span><span class="s1">&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;</span><span class="dl">'</span>
    <span class="p">);</span>
    <span class="nx">matchCnt</span> <span class="o">=</span> <span class="nx">matches</span><span class="p">.</span><span class="nx">length</span>

<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 본문에 검색어가 없을 경우 처음부터 30개 토큰을 가져온다</span>
    <span class="kd">const</span> <span class="nx">words</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sr">/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">).</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">highlightedValue</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">words</span><span class="p">}</span><span class="s2">...`</span><span class="p">;</span>
    <span class="nx">matchCnt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="c1">// 언급수</span>
<span class="nx">highlightedValue</span> <span class="o">+=</span> <span class="s2">`&lt;div style="padding-top:5px"&gt;&lt;span id="match-counter"&gt;본문에 &lt;b&gt;</span><span class="p">${</span><span class="nx">matchCnt</span><span class="p">}</span><span class="s2">&lt;/b&gt;번 언급되었습니다&lt;/span&gt;&lt;/div&gt;`</span><span class="p">;</span>
<span class="k">return</span> <span class="nx">highlightedValue</span><span class="p">;</span>
</code></pre></div></div>
<p><br />
이렇게 처리된 결과물은 <code class="language-plaintext highlighter-rouge">searchResultTemplate</code>에 정의한 HTML 템플릿대로 디스플레이 된다. 이곳에서 Font Awesome(폰트 어썸) 태그를 정의하여 아이콘으로 영역을 시각적으로 구분했다. 그리고 제목과 본문을 클릭했을 때 본문으로 연결해주는 <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> 태그를 추가했다</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">searchResultTemplate</span><span class="p">:</span> 
        <span class="dl">'</span><span class="s1">&lt;article&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;i class="fas fa-book fa-fw"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;{title}&lt;/a&gt;&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;i class="fas fa-clock fa-fw"&gt;&lt;/i&gt;&lt;span&gt;{date}&lt;/span&gt;&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;i class="fas fa-tag fa-fw"&gt;&lt;/i&gt;{tags}&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;div style="display:inline-flex"&gt;</span><span class="dl">'</span> <span class="o">+</span> 
            <span class="dl">'</span><span class="s1">&lt;i class="fas fa-pencil-alt fa-fw" style="padding-top:5px"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;&lt;span style="color:#343a40"&gt;{content}&lt;/span&gt;&lt;/a&gt;</span><span class="dl">'</span> <span class="o">+</span> 
        <span class="dl">'</span><span class="s1">&lt;/div&gt;</span><span class="dl">'</span><span class="o">+</span>
        <span class="dl">'</span><span class="s1">&lt;/article&gt;</span><span class="dl">'</span>
</code></pre></div></div>

<p>참고로 아이콘을 불러오기 위해서는 search 폴더의 <strong><code class="language-plaintext highlighter-rouge">index.html</code>에 폰트 어썸 링크를 추가</strong>해주어야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"&gt;

</code></pre></div></div>

<h2 id="키워드-추천">키워드 추천</h2>

<p><img src="https://github.com/user-attachments/assets/5e9706e8-610d-44de-b117-90876070a57f" alt="image" style="border:black solid 0.5px; padding:10px;" /></p>

<p>유저에게 무슨 키워드를 검색할지 가이드를 제공해주는 것은 어떨까?<br />
포스트 본문을 데이터로 활용하여 <strong>키워드의 중요도를 집계하고 상위 n개 키워드를 추천</strong>하는 기능을 떠올렸다.</p>

<p>아이디어는 이렇다.</p>
<ol>
  <li>블로그 전체에서 제목과 본문 텍스트를 수집하여 전처리하고 키워드를 추출한다</li>
  <li>블로그 포스트 개수를 고려하여 키워드별 TF-IDF를 집계하고 상위 5개를 저장한다</li>
  <li>추천 키워드를 불러와 검색 페이지에서 띄워준다</li>
</ol>

<p>1~2번은 Python으로 실행하고 3번은 JavaScript로 구현하기로 했다.<br />
<br /></p>

<p><strong>데이터 수집과 처리</strong><br />
<code class="language-plaintext highlighter-rouge">{baseurl}/search.json</code> 주소로 json 파일에 접근할 수 있다는 점을 기억하고 <code class="language-plaintext highlighter-rouge">requests</code> 모듈로 불러왔다. 그리고 그 중에서 제목과 본문만 저장했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">collect_contents</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">pttrn</span><span class="p">,</span> <span class="n">noTag</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    url   : search.json
    pttrn : escape 기호 제외하기 위한 정규표현식
    noTag : 데이터 수집에서 제외할 태그
    </span><span class="sh">'''</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">cleansed_response</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="n">pttrn</span><span class="p">,</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">normalized_response</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">\s+</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">,</span> <span class="n">cleansed_response</span><span class="p">)</span>
    
    <span class="n">json_data</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="nf">loads</span><span class="p">(</span><span class="n">normalized_response</span><span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="p">[</span><span class="n">post</span><span class="p">[</span><span class="sh">'</span><span class="s">title</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span> <span class="o">+</span> <span class="n">post</span><span class="p">[</span><span class="sh">'</span><span class="s">content</span><span class="sh">'</span><span class="p">]</span> <span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">json_data</span> <span class="k">if</span> <span class="n">noTag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">post</span><span class="p">[</span><span class="sh">'</span><span class="s">tags</span><span class="sh">'</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">contents</span>
</code></pre></div></div>

<p>수집한 데이터를 키워드 말뭉치 형태로 변환한다. 이때 영어와 한국어를 따로 추출하여 한 글자인 단어와 불용어 사전에 포함된 단어를 제외했다. 명사를 대상으로 하고 싶었기 때문에 <strong>한국어는 형태소 분석기를 사용하여 명사를 추출</strong>했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_corpus</span><span class="p">(</span><span class="n">contents</span><span class="p">):</span>
    <span class="c1"># eng_prc, kor_prc는 별도로 정의한 전처리 함수다
</span>    <span class="n">keywords_eng</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">eng_prc</span><span class="p">,</span> <span class="n">contents</span><span class="p">))</span>
    <span class="c1"># 한국어는 형태소 분석 후 명사만 사용된다
</span>    <span class="n">keywords_kor</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="n">kor_prc</span><span class="p">,</span> <span class="n">contents</span><span class="p">))</span>
    <span class="n">corpus</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">e</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">keywords_eng</span><span class="p">,</span> <span class="n">keywords_kor</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">corpus</span>
</code></pre></div></div>

<p>참고로 한국어 형태소 분석은 <code class="language-plaintext highlighter-rouge">konlpy</code>를 사용했다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">konlpy.tag</span> <span class="kn">import</span> <span class="n">Okt</span>

<span class="k">def</span> <span class="nf">kor_prc</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">okt</span> <span class="o">=</span> <span class="nc">Okt</span><span class="p">()</span>
    <span class="n">kor_res</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">okt</span><span class="p">.</span><span class="nf">nouns</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="nf">if </span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span><span class="p">):</span>
            <span class="n">kor_res</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kor_res</span>
</code></pre></div></div>

<p>불용어 사전은 <a href="https://gist.github.com/sebleier/554280">NLTK’s list of english stopwords</a>와 <a href="https://www.public.asu.edu/~rjansen/latexdoc/ltx-2.html">Latex 문법 리스트</a>를 크롤링해서 <code class="language-plaintext highlighter-rouge">stopwords.txt</code> 파일로 구축하였다. 더불어 <em>span, div</em>와 같은 HTML 태그도 불용어 사전에 포함했다.<br />
<br /></p>

<p><strong>TF-IDF 계산</strong><br />
TF-IDF(Term Frequency-Inverse Document Frequency)는 <strong>문서 안에서의 출현 빈도수와 전체 문서 집합에서의 희귀성을 적용한 가중치</strong>이다. scikit-learn 의 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">TfidfVectorizer</a>을 사용해 계산했다. 여러 개 포스트를 올리는 블로그 특성 상 주요 키워드를 추출하는 데 TF-IDF가 적합하다고 생각하여 적용했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_keywords</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">topN</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">asset_dir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">vectorizer</span> <span class="o">=</span> <span class="nc">TfidfVectorizer</span><span class="p">()</span>
    <span class="n">tfidf_matrix</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>

    <span class="n">feature_names</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="p">.</span><span class="nf">get_feature_names_out</span><span class="p">()</span>
    <span class="c1"># 단어가 열, 문서가 행이므로 각 단어에 대해 문서 전반의 값을 sum
</span>    <span class="n">sum_tfidf_scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">tfidf_matrix</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)).</span><span class="nf">flatten</span><span class="p">()</span>
    <span class="n">average_tfidf_score</span> <span class="o">=</span> <span class="n">sum_tfidf_scores</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">top_indices</span> <span class="o">=</span> <span class="n">sum_tfidf_scores</span><span class="p">.</span><span class="nf">argsort</span><span class="p">()[</span><span class="o">-</span><span class="n">topN</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">top_keywords</span> <span class="o">=</span> <span class="p">[[</span><span class="sh">'</span><span class="s">말뭉치 평균</span><span class="sh">'</span><span class="p">,</span> <span class="n">average_tfidf_score</span><span class="p">]]</span>
    <span class="n">top_keywords</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">feature_names</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="nf">round</span><span class="p">(</span><span class="n">sum_tfidf_scores</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">top_indices</span><span class="p">]</span>
    <span class="bp">...</span>
    <span class="c1"># 저장
</span>    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="n">json</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">top_keywords</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div></div>
<p>문서별로 단어의 TF-IDF 값이 계산되는데, 전체 블로그 관점에서 중요도를 고려해야 하므로 단어 단위로 총합 값을 계산했다. 또 추출된 키워드의 중요도를 상대적으로 비교할 수 있도록 전체 키워드의 평균 TF-IDF 값도 함께 저장했다.<br />
<br /></p>

<p><strong>추천 키워드 디스플레이</strong><br />
파이썬으로 계산한 결과는 <code class="language-plaintext highlighter-rouge">keywords.json</code> 이라는 이름으로 따로 저장했다. 첫번째 요소는 전체 말뭉치 평균이고, 그 아래부터 1위, 2위 … 5위에 해당한다. [키워드, 점수] 쌍의 리스트로 이루어져 있다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="err">'말뭉치</span><span class="w"> </span><span class="err">평균'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.05</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'클러스터'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.67</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'toc'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.42</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'포인트'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.38</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'편차'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.38</span><span class="p">],</span><span class="w"> 
 </span><span class="p">[</span><span class="err">'평균'</span><span class="p">,</span><span class="w"> </span><span class="mf">0.33</span><span class="p">]]</span><span class="w">
</span></code></pre></div></div>

<p>이제 이것을 읽어 검색 페이지에서 보여주는 JavaScript를 작성한다. 해당 스크립트는 search 폴더의 <code class="language-plaintext highlighter-rouge">index.html</code> 에서 실행된다. 먼저 json을 읽어온 후 반복문으로 HTML 태그를 추가했다. 키워드를 클릭하면 바로 검색되도록 click 이벤트를 추가했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 미리 추출한 키워드 json 데이터를 불러온다</span>
<span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">keywords.json</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>
<span class="p">...</span>
<span class="c1">// 첫번째 요소는 전체 평균이므로 두번째 요소부터 반복문을 시행한다</span>
<span class="nx">data</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">rnk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">li</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">li</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">span</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">);</span>

    <span class="c1">// 키워드를 읽어온다</span>
    <span class="nx">span</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="c1">// 클릭할 경우 해당 키워드를 search-input 입력창으로 전달한다</span>
    <span class="nx">span</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kd">const</span> <span class="nx">searchInput</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">search-input</span><span class="dl">'</span><span class="p">);</span>
                    <span class="nx">searchInput</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

                    <span class="c1">// trigger</span>
                    <span class="kd">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Event</span><span class="p">(</span><span class="dl">'</span><span class="s1">input</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">bubbles</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
                    <span class="nx">searchInput</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
                <span class="p">});</span>
    <span class="p">...</span>
</code></pre></div></div>
<p class="center"><img src="https://github.com/user-attachments/assets/5f04c3c4-89b7-4074-a014-4f4103eeddda" alt="image" style="border:black solid 0.5px; padding:10px;" class="center-image" />
클릭하면 검색창에 그 키워드가 입력되면서 검색 기능이 발동된다.</p>

<p>마지막으로 <em>이 키워드들이 왜 추천되는지</em> 도움말 팝업을 추가해보았다. 아이콘 위에 마우스를 호버하면 텍스트 설명이 뜨는 방식이다. 각 추천 키워드의 점수도 <code class="language-plaintext highlighter-rouge">obj[1]</code>으로 읽어올 수 있으므로 팝업 코드를 forEach문에 추가했다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 도움말 아이콘 팝업</span>
<span class="kd">const</span> <span class="nx">svgIcon</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">span</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">svgIcon</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">`&lt;svg width="25" height="25" viewBox="0 0 16 16" 생략..&gt; &lt;/svg&gt;`</span><span class="p">;</span>
<span class="nx">paragraph</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">svgIcon</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">totalAvg</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">tooltip</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">tooltip</span><span class="p">.</span><span class="nx">className</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">tooltip</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">tooltip</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s2">`TF-IDF 점수를 기반으로 상위 5개 키워드를 추천합니다\n
                      현재 블로그의 전체 평균 TF-IDF는 </span><span class="p">${</span><span class="nx">totalAvg</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span><span class="s2">점입니다\n
                      추천 키워드에 마우스를 올려 점수를 비교해보세요`</span><span class="p">;</span>
<span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">whiteSpace</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">pre</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// '\n'이 적용되려면</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nx">tooltip</span><span class="p">);</span>

<span class="nx">svgIcon</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseenter</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">block</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageX</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageY</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">svgIcon</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mousemove</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageX</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">event</span><span class="p">.</span><span class="nx">pageY</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span><span class="s2">px`</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">svgIcon</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">mouseleave</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">tooltip</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>자동화</strong><br />
끝으로 TF-IDF를 계산하는 파이썬 스크립트의 실행만 자동화하면 된다. 이 부분은 GitHub Actions로 처리했으며 <a href="https://woocosmos.github.io/github-action/">GitHub Actions 활용한 태스크 및 배포 자동화</a>에서 그 과정을 확인할 수 있다.</p>

<h1 id="기타">기타</h1>
<p>JS에서 실행할 수 있는 <a href="https://github.com/NOT2ho/notPOS_kr">한국어 토크나이저</a>도 있다. 사이트를 불러올 때마다 점수를 연산하기는 어려울 것 같아서 결국 python으로 구현했지만, 충분히 활용 가치가 있을 것 같아서 기록해둔다</p>]]></content><author><name></name></author><category term="JavaScript" /><category term="NLP" /><summary type="html"><![CDATA[요약 - simple-jekyll-search 라이브러리를 활용하여 검색 기능을 추가했다 - 탭에서 접근할 수 있는 검색 페이지를 구성하고 검색 결과를 적절하게 시각화했다 - TF-IDF 값을 활용하여 검색할 키워드를 추천했다 개요 Kiko Now Jekyll 테마에 검색 기능이 없는 관계로 직접 검색 페이지를 구성하고 JS 라이브러리로 검색 기능을 적용했다. 블로그에 포스트가 쌓일수록 검색 기능이 필수적이라고 생각했다. 태그 기반의 문서 분류 방식은 한계가 명확하고, 특정 문서를 찾을 때도 검색이 가장 간편하기 때문이다. 블로그 개발 과정은 특정 포스트에 아카이빙하고 있지만, 해당 기능은 분량이 많아 별도로 기록한다. 기본 기능 입력 키워드로 블로그 내 모든 컨텐츠에 대해 검색하는 기본 기능부터 적용한다. Simple-Jekyll-Search 라이브러리를 적용했다. 브라우저 단[Client-Side]에서 작동하기 때문에 별도 서버나 DB를 구축할 필요가 없다. 적용 과정 역시 간단하다. 첫째, search.json 생성 블로그의 root 위치에 아래 search.json 파일을 만든다. --- layout: none --- [ {% for post in site.posts %} { "title" : "{{ post.title | escape }}", "tags" : "{{ post.tags | join: ', ' }}", "date" : "{{ post.date | date: '%Y.%m.%d'}}", "url" : "{{ site.url }}{{ post.url }}", "content": "{{ post.content | strip_html | strip_newlines | escape }}" } {% unless forloop.last %},{% endunless %} {% endfor %} ] 기존 코드에 post.content 를 추가하여 본문 텍스트도 가져오게 했다. 이때 strip_html 등 몇 가지 Jekyll 문법을 더했다. 이를 통해 {baseurl}/search.json 주소로 json 파일에 접근할 수 있다. 브라우저로부터 이 파일을 읽어와 검색 데이터로 활용할 것이다. 둘째, JavaSript 소스 추가 simple-jekyll-search.js를 다운 받아 어디든 위치시킨다. 이 스크립트는 search.json으로부터 데이터를 읽어와 입력어에 매칭되는 내용을 찾는 함수 SimpleJekyllSearch를 정의하고 있다. 그 다음 search-and-return.js도 다운 받아 같은 위치에 붙여넣는다. SimpleJekyllSearch 함수를 실행시켜서 결과값을 받아와 처리하는 부분을 별도 스크립트로 작성한 것이다. var sjs = SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('results-container'), json: '/search.json', searchResultTemplate: ... noResultsText: '😴 검색 결과가 없습니다', templateMiddleware : ... )} 나는 assets 라는 폴더를 만들어 이곳에 JS 소스를 모아두기로 했다. 두 스크립트는 다음 서술할 검색 페이지에서 실행시킬 것이다. 셋째, 검색 페이지 구성 root 위치에 search 폴더를 생성하고 그 아래 index.html 파일을 생성한다. 앞서 추가한 JS 스크립트가 실행되면서 검색어 입출력이 진행되는 곳이다. --- layout: page permalink: /search --- &lt;ul class="search"&gt; &lt;div id="search-container"&gt; &lt;input type="search" id="search-input" placeholder=" 🤔 검색어를 입력하세요."&gt; &lt;ul id="results-container"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/ul&gt; &lt;script src="{{ site.baseurl }}/assets/simple-jekyll-search.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="{{ site.baseurl }}/assets/search-and-return.js" type="text/javascript"&gt;&lt;/script&gt; 이렇게 {baseurl}/search 주소로 접근할 수 있는 검색 페이지를 완성하였다. 한편, 무엇을 클릭했을 때 이 검색 페이지로 연결되도록 할 것인가? 나는 상단의 탭에 돋보기 아이콘을 추가했다. 이를 위해 돋보기 아이콘 svg와 검색 페이지를 연결하여 _includes/nav.html에 추가했다. &lt;ul class="search-icon"&gt; &lt;a href="{{ site.baseurl }}/search"&gt; &lt;svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"&gt; &lt;path d="M10 ...생략" fill="currentColor"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/a&gt; &lt;/ul&gt; 이렇게 검색 페이지를 구성하고 검색용 라이브러리를 적용하는 과정을 마무리하였다. 응용 기능 기본 검색 기능에 더하여 키워드를 더 쉽게 찾고 검색 결과를 더 잘 표현하기 위해 개선한 사항이다. 결과창 개선 이미지에 보듯 결과창에 추가한 내용은 다음과 같다. 검색어 하이라이트 클릭시 본문 및 태그 페이지로 링크 연결 본문 미리보기 검색어가 언급된 횟수 표시 아이콘과 함께 메타 정보 디스플레이 이를 위해 SimpleJekyllSearch 함수의 templateMiddleware와 searchResultTemplate 인자를 활용할 것이다. 전자는 검색 결과가 있을 때 호출되는 함수이며 후자는 그 결과를 출력할 HTML 템플릿을 지정하는 인자다. 하나씩 짚어보도록 하겠다. templateMiddleware 인자는 다음과 같이 정의된 함수를 필요로 한다. function (prop, value, template) { return value } prop은 json의 key이고 value는 key에 대한 value를 의미한다. 이제 prop, 즉 ‘항목’에 따라 value를 처리할 것이다. URL과 날짜 항목은 json에 저장된 그대로 사용할 예정이기 때문에 바로 value를 반환하도록 했다. if (prop === "url" || prop === 'date') { return value; } 나머지 제목, 태그, 본문 항목은 검색어 하이라이트를 적용하고 URL과 연결하는 작업이 필요하다. 우선 검색어를 저장하고, 그것을 찾는 정규표현식 객체와 최종적으로 리턴될 변수를 선언한다. const searchTerm = document.getElementById("search-input").value; const regex = new RegExp(searchTerm, "gi"); let highlightedValue; 제목 항목은 정규표현식 객체로 검색어($&amp;)를 HTML 태그로 감싼다. 배경색깔을 바꾸고 폰트를 굵게 표시한다. if (prop === 'title') { highlightedValue = value.replace(regex, '&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;') return highlightedValue; } 태그 항목의 경우 태그 페이지의 각 태그 링크와 연동했다. 앞서 json을 생성하면서 쉼표로 join 했기 때문에 split하고 join하는 과정을 한번 더 거치는데, search.json을 개선해서 전처리를 간소화하는 대안도 고민해봐야겠다. if (prop === 'tags') { const dest = window.location.origin; const theTags = value.split(', ').map(tag =&gt; tag.trim()); highlightedLinkedValue = theTags.map(tag =&gt; { // 하이라이트를 적용한다 const highlightedTag = tag.replace(regex, '&lt;b style="background:gold"&gt;$&amp;&lt;/b&gt;'); // 링크를 적용한다 return `&lt;a href="${dest}/tags/#${tag}"&gt;&lt;span&gt;${highlightedTag}&lt;/span&gt;&lt;/a&gt;`; }).join(', '); return highlightedLinkedValue; } 마지막으로 본문을 보여주는 데 있어 두 가지 지점을 고려했다. 첫번째는 30개 단어까지 미리보기로 보여주는 것이고 두번째는 본문에서 match가 걸린 횟수를 명시하는 것이다. 첫번째 매치를 기준으로 앞뒤 15개 단어까지 슬라이스하였다. 본문에 매치가 없을 경우 처음부터 30개 단어를 가져온다. 마지막으로는 정규표현식 객체에 매치된 matches의 개수를 명시했다. value = value.replace(/\[.*?\]/g, ''); const matches = value.match(regex); let matchCnt; if (matches) { // 띄어쓰기를 기준으로 토큰화한다 const wordsArray = value.split(/\s+/); // 검색된 단어를 기준으로 앞뒤 15개 토큰을 사용한다 const matchIndex = wordsArray.findIndex(word =&gt; regex.test(word)); const start = Math.max(0, matchIndex - 15); const end = Math.min(wordsArray.length, matchIndex + 15 + 1); const truncatedValue = wordsArray.slice(start, end).join(" "); // 하이라이트를 적용한다 highlightedValue = truncatedValue.replace( regex, '&lt;span style="background:gold"&gt;&lt;b&gt;$&amp;&lt;/b&gt;&lt;/span&gt;' ); matchCnt = matches.length } else { // 본문에 검색어가 없을 경우 처음부터 30개 토큰을 가져온다 const words = value.split(/\s+/).slice(0, 30).join(" "); highlightedValue = `${words}...`; matchCnt = 0 } // 언급수 highlightedValue += `&lt;div style="padding-top:5px"&gt;&lt;span id="match-counter"&gt;본문에 &lt;b&gt;${matchCnt}&lt;/b&gt;번 언급되었습니다&lt;/span&gt;&lt;/div&gt;`; return highlightedValue; 이렇게 처리된 결과물은 searchResultTemplate에 정의한 HTML 템플릿대로 디스플레이 된다. 이곳에서 Font Awesome(폰트 어썸) 태그를 정의하여 아이콘으로 영역을 시각적으로 구분했다. 그리고 제목과 본문을 클릭했을 때 본문으로 연결해주는 &lt;a&gt; 태그를 추가했다 searchResultTemplate: '&lt;article&gt;'+ '&lt;div&gt;&lt;i class="fas fa-book fa-fw"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;{title}&lt;/a&gt;&lt;/div&gt;'+ '&lt;div&gt;&lt;i class="fas fa-clock fa-fw"&gt;&lt;/i&gt;&lt;span&gt;{date}&lt;/span&gt;&lt;/div&gt;'+ '&lt;div&gt;&lt;i class="fas fa-tag fa-fw"&gt;&lt;/i&gt;{tags}&lt;/div&gt;'+ '&lt;div style="display:inline-flex"&gt;' + '&lt;i class="fas fa-pencil-alt fa-fw" style="padding-top:5px"&gt;&lt;/i&gt;&lt;a href="{url}"&gt;&lt;span style="color:#343a40"&gt;{content}&lt;/span&gt;&lt;/a&gt;' + '&lt;/div&gt;'+ '&lt;/article&gt;' 참고로 아이콘을 불러오기 위해서는 search 폴더의 index.html에 폰트 어썸 링크를 추가해주어야 한다. &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"&gt; 키워드 추천 유저에게 무슨 키워드를 검색할지 가이드를 제공해주는 것은 어떨까? 포스트 본문을 데이터로 활용하여 키워드의 중요도를 집계하고 상위 n개 키워드를 추천하는 기능을 떠올렸다. 아이디어는 이렇다. 블로그 전체에서 제목과 본문 텍스트를 수집하여 전처리하고 키워드를 추출한다 블로그 포스트 개수를 고려하여 키워드별 TF-IDF를 집계하고 상위 5개를 저장한다 추천 키워드를 불러와 검색 페이지에서 띄워준다 1~2번은 Python으로 실행하고 3번은 JavaScript로 구현하기로 했다. 데이터 수집과 처리 {baseurl}/search.json 주소로 json 파일에 접근할 수 있다는 점을 기억하고 requests 모듈로 불러왔다. 그리고 그 중에서 제목과 본문만 저장했다. def collect_contents(url, pttrn, noTag): ''' url : search.json pttrn : escape 기호 제외하기 위한 정규표현식 noTag : 데이터 수집에서 제외할 태그 ''' response = requests.get(url, verify=False) cleansed_response = re.sub(pttrn, ' ', response.text) normalized_response = re.sub(r'\s+', ' ', cleansed_response) json_data = json.loads(normalized_response) contents = [post['title'] + ' ' + post['content'] for post in json_data if noTag not in post['tags']] return contents 수집한 데이터를 키워드 말뭉치 형태로 변환한다. 이때 영어와 한국어를 따로 추출하여 한 글자인 단어와 불용어 사전에 포함된 단어를 제외했다. 명사를 대상으로 하고 싶었기 때문에 한국어는 형태소 분석기를 사용하여 명사를 추출했다. def create_corpus(contents): # eng_prc, kor_prc는 별도로 정의한 전처리 함수다 keywords_eng = list(map(eng_prc, contents)) # 한국어는 형태소 분석 후 명사만 사용된다 keywords_kor = list(map(kor_prc, contents)) corpus = [' '.join(e+k) for e, k in zip(keywords_eng, keywords_kor)] return corpus 참고로 한국어 형태소 분석은 konlpy를 사용했다. from konlpy.tag import Okt def kor_prc(c): okt = Okt() kor_res =[] for k in okt.nouns(c): if (len(k) &gt; 1) &amp; (k not in stop_words): kor_res.append(k) return kor_res 불용어 사전은 NLTK’s list of english stopwords와 Latex 문법 리스트를 크롤링해서 stopwords.txt 파일로 구축하였다. 더불어 span, div와 같은 HTML 태그도 불용어 사전에 포함했다. TF-IDF 계산 TF-IDF(Term Frequency-Inverse Document Frequency)는 문서 안에서의 출현 빈도수와 전체 문서 집합에서의 희귀성을 적용한 가중치이다. scikit-learn 의 TfidfVectorizer을 사용해 계산했다. 여러 개 포스트를 올리는 블로그 특성 상 주요 키워드를 추출하는 데 TF-IDF가 적합하다고 생각하여 적용했다. def extract_keywords(corpus, topN=5, asset_dir=None): vectorizer = TfidfVectorizer() tfidf_matrix = vectorizer.fit_transform(corpus) feature_names = vectorizer.get_feature_names_out() # 단어가 열, 문서가 행이므로 각 단어에 대해 문서 전반의 값을 sum sum_tfidf_scores = np.array(tfidf_matrix.sum(axis=0)).flatten() average_tfidf_score = sum_tfidf_scores.mean().round(2) top_indices = sum_tfidf_scores.argsort()[-topN:][::-1] top_keywords = [['말뭉치 평균', average_tfidf_score]] top_keywords += [[feature_names[idx], round(sum_tfidf_scores[idx], 2)] for idx in top_indices] ... # 저장 with open(save_path, 'w') as f: json.dump(top_keywords, f) 문서별로 단어의 TF-IDF 값이 계산되는데, 전체 블로그 관점에서 중요도를 고려해야 하므로 단어 단위로 총합 값을 계산했다. 또 추출된 키워드의 중요도를 상대적으로 비교할 수 있도록 전체 키워드의 평균 TF-IDF 값도 함께 저장했다. 추천 키워드 디스플레이 파이썬으로 계산한 결과는 keywords.json 이라는 이름으로 따로 저장했다. 첫번째 요소는 전체 말뭉치 평균이고, 그 아래부터 1위, 2위 … 5위에 해당한다. [키워드, 점수] 쌍의 리스트로 이루어져 있다. [['말뭉치 평균', 0.05], ['클러스터', 0.67], ['toc', 0.42], ['포인트', 0.38], ['편차', 0.38], ['평균', 0.33]] 이제 이것을 읽어 검색 페이지에서 보여주는 JavaScript를 작성한다. 해당 스크립트는 search 폴더의 index.html 에서 실행된다. 먼저 json을 읽어온 후 반복문으로 HTML 태그를 추가했다. 키워드를 클릭하면 바로 검색되도록 click 이벤트를 추가했다. // 미리 추출한 키워드 json 데이터를 불러온다 const response = await fetch('keywords.json'); const data = await response.json(); ... // 첫번째 요소는 전체 평균이므로 두번째 요소부터 반복문을 시행한다 data.slice(1).forEach((obj, rnk) =&gt; { const li = document.createElement('li'); const span = document.createElement('span'); // 키워드를 읽어온다 span.textContent = obj[0]; // 클릭할 경우 해당 키워드를 search-input 입력창으로 전달한다 span.addEventListener('click', function(event) { const searchInput = document.getElementById('search-input'); searchInput.value = obj[0]; // trigger const e = new Event('input', { bubbles: true }); searchInput.dispatchEvent(e); }); ... 클릭하면 검색창에 그 키워드가 입력되면서 검색 기능이 발동된다. 마지막으로 이 키워드들이 왜 추천되는지 도움말 팝업을 추가해보았다. 아이콘 위에 마우스를 호버하면 텍스트 설명이 뜨는 방식이다. 각 추천 키워드의 점수도 obj[1]으로 읽어올 수 있으므로 팝업 코드를 forEach문에 추가했다. // 도움말 아이콘 팝업 const svgIcon = document.createElement('span') svgIcon.innerHTML = `&lt;svg width="25" height="25" viewBox="0 0 16 16" 생략..&gt; &lt;/svg&gt;`; paragraph.appendChild(svgIcon); const totalAvg = data[0] const tooltip = document.createElement('div'); tooltip.className = 'tooltip'; tooltip.textContent = `TF-IDF 점수를 기반으로 상위 5개 키워드를 추천합니다\n 현재 블로그의 전체 평균 TF-IDF는 ${totalAvg[1]}점입니다\n 추천 키워드에 마우스를 올려 점수를 비교해보세요`; tooltip.style.whiteSpace = 'pre'; // '\n'이 적용되려면 document.body.appendChild(tooltip); svgIcon.addEventListener('mouseenter', (event) =&gt; { tooltip.style.display = 'block'; tooltip.style.left = `${event.pageX + 10}px`; tooltip.style.top = `${event.pageY + 10}px`; }); svgIcon.addEventListener('mousemove', (event) =&gt; { tooltip.style.left = `${event.pageX + 10}px`; tooltip.style.top = `${event.pageY + 10}px`; }); svgIcon.addEventListener('mouseleave', () =&gt; { tooltip.style.display = 'none'; }); 자동화 끝으로 TF-IDF를 계산하는 파이썬 스크립트의 실행만 자동화하면 된다. 이 부분은 GitHub Actions로 처리했으며 GitHub Actions 활용한 태스크 및 배포 자동화에서 그 과정을 확인할 수 있다. 기타 JS에서 실행할 수 있는 한국어 토크나이저도 있다. 사이트를 불러올 때마다 점수를 연산하기는 어려울 것 같아서 결국 python으로 구현했지만, 충분히 활용 가치가 있을 것 같아서 기록해둔다]]></summary></entry><entry><title type="html">수학, 통계 개념 모음집</title><link href="https://woocosmos.github.io/basic-statistics/" rel="alternate" type="text/html" title="수학, 통계 개념 모음집" /><published>2024-08-21T00:00:00+09:00</published><updated>2024-08-21T00:00:00+09:00</updated><id>https://woocosmos.github.io/basic-statistics</id><content type="html" xml:base="https://woocosmos.github.io/basic-statistics/"><![CDATA[<p>수학 및 통계 용어와 수식을 정의하고 ML 관점에서의 직관을 서술한다.</p>

<h1 id="평균-분산-표준편차">평균, 분산, 표준편차</h1>

\[\bar{x} = \frac{x_{1}+ x_{2} + \dots +x_{n}}{n}\]

<p>데이터 값을 모두 더한 다음(sum), 값의 개수(데이터 사이즈)로 나눈다 👉 <mark>평균</mark></p>
<blockquote>
  <p>데이터 포인트들의 대표값</p>
</blockquote>

<p><br /></p>

\[\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}\]

<dl>
  <dt>편차</dt>
  <dd>데이터별로 평균과의 차이를 구한다. 이때 <strong>편차의 총합은 $0$</strong>이다.</dd>
</dl>

\[\begin{aligned}
&amp; (x_{1}-m) + (x_{2}-m) + \dots + (x_{n}-m) \\
&amp; = (x_{1}+x_{2}+\dots+x_{n}) - n \times m \\
&amp; = n \times m - n \times m \\
&amp; = 0
\end{aligned}\]

<dl>
  <dt>편차제곱</dt>
  <dd>편차별로 제곱한다(squared deviations)</dd>
  <dt>편차제곱의 평균</dt>
  <dd>편차제곱을 모두 더한 다음(제곱합, sum of squares), 값의 개수로 나눈다<br />
👉 <mark>분산</mark></dd>
</dl>

<blockquote>
  <p>데이터 포인트들이 평균으로부터 얼마나 퍼져 있는지, 얼마나 벗어나 있는지 의미한다</p>
</blockquote>

<blockquote>
  <p><strong>High Variance</strong>: 분산이 큰 데이터로 학습된 모델은 입력값이 조금만 변화해도 민감하게 반응하여 출력값이 크게 바뀌기 때문에 예측의 안정성이 떨어진다</p>
</blockquote>

<p><br /></p>

\[\sqrt{\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}}\]

<p>분산의 제곱근 👉 <mark>표준편차</mark></p>
<blockquote>
  <p>제곱된 값에 루트를 씌움으로써 원래 데이터의 스케일(단위)에 맞추고 해석을 직관적으로 만든다</p>
</blockquote>

<h1 id="norm">Norm</h1>
<p><strong>벡터의 크기(길이)</strong></p>
<ul>
  <li>$p$는 Norm의 차수를 의미한다.</li>
</ul>

<h2 id="l1-norm-맨해튼-거리">L1 Norm (맨해튼 거리)</h2>
<p>내용</p>

<h2 id="l2-norm-유클리드-거리">L2 Norm (유클리드 거리)</h2>

\[\sqrt{\sum_{i=1} |x_{i}|^{2}}\]

<p>$p=2$ 인 Norm. 피타고라스 정리를 기반으로 n차원 좌표 평면(유클리드 공간)에서의 크기를 계산한다.</p>

<blockquote>
  <p>활용 : L2 정규화, KNN 알고리즘, K-means 알고리즘</p>
</blockquote>

<p><br /></p>

<h1 id="수학">수학</h1>
<h2 id="집합">집합</h2>
<p><strong>단조 감소(monotonically decreasing)</strong><br />
\(\lim_{x\to\infty} A_{n} = \cap_{n=1}^{\infty}A_{n}\)</p>

<p>집합이 갈수록 작아져서 모든 집합 $A$들의 교집합이 가장 작은 집합과 같아지는 것이다.</p>
<blockquote>
  <p>K-Means 알고리즘의 목적함수[WCSS]는 단조 감소한다</p>
</blockquote>

<h2 id="용어집">용어집</h2>
<dl>
  <dt>identity</dt>
  <dd>항등식. 언제나 성립하는 등식. 좌변과 우변의 값이 항상 같다.</dd>
</dl>]]></content><author><name></name></author><category term="수학" /><category term="통계" /><summary type="html"><![CDATA[수학 및 통계 용어와 수식을 정의하고 ML 관점에서의 직관을 서술한다. 평균, 분산, 표준편차 \[\bar{x} = \frac{x_{1}+ x_{2} + \dots +x_{n}}{n}\] 데이터 값을 모두 더한 다음(sum), 값의 개수(데이터 사이즈)로 나눈다 👉 평균 데이터 포인트들의 대표값 \[\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}\] 편차 데이터별로 평균과의 차이를 구한다. 이때 편차의 총합은 $0$이다. \[\begin{aligned} &amp; (x_{1}-m) + (x_{2}-m) + \dots + (x_{n}-m) \\ &amp; = (x_{1}+x_{2}+\dots+x_{n}) - n \times m \\ &amp; = n \times m - n \times m \\ &amp; = 0 \end{aligned}\] 편차제곱 편차별로 제곱한다(squared deviations) 편차제곱의 평균 편차제곱을 모두 더한 다음(제곱합, sum of squares), 값의 개수로 나눈다 👉 분산 데이터 포인트들이 평균으로부터 얼마나 퍼져 있는지, 얼마나 벗어나 있는지 의미한다 High Variance: 분산이 큰 데이터로 학습된 모델은 입력값이 조금만 변화해도 민감하게 반응하여 출력값이 크게 바뀌기 때문에 예측의 안정성이 떨어진다 \[\sqrt{\frac{\sum_{n}^{i}{({x}_{i} - \bar{x})^{2}}}{n}}\] 분산의 제곱근 👉 표준편차 제곱된 값에 루트를 씌움으로써 원래 데이터의 스케일(단위)에 맞추고 해석을 직관적으로 만든다 Norm 벡터의 크기(길이) $p$는 Norm의 차수를 의미한다. L1 Norm (맨해튼 거리) 내용 L2 Norm (유클리드 거리) \[\sqrt{\sum_{i=1} |x_{i}|^{2}}\] $p=2$ 인 Norm. 피타고라스 정리를 기반으로 n차원 좌표 평면(유클리드 공간)에서의 크기를 계산한다. 활용 : L2 정규화, KNN 알고리즘, K-means 알고리즘 수학 집합 단조 감소(monotonically decreasing) \(\lim_{x\to\infty} A_{n} = \cap_{n=1}^{\infty}A_{n}\) 집합이 갈수록 작아져서 모든 집합 $A$들의 교집합이 가장 작은 집합과 같아지는 것이다. K-Means 알고리즘의 목적함수[WCSS]는 단조 감소한다 용어집 identity 항등식. 언제나 성립하는 등식. 좌변과 우변의 값이 항상 같다.]]></summary></entry></feed>